<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LittleYe233&#39;s Blog</title>
  
  
  <link href="https://blog.tamako.work/atom.xml" rel="self"/>
  
  <link href="https://blog.tamako.work/"/>
  <updated>2023-10-27T12:38:28.000Z</updated>
  <id>https://blog.tamako.work/</id>
  
  <author>
    <name>LittleYe233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 使用 Gradle 命令行签名 APK</title>
    <link href="https://blog.tamako.work/techdev/android/sign-apk-gradlew/"/>
    <id>https://blog.tamako.work/techdev/android/sign-apk-gradlew/</id>
    <published>2023-10-27T12:38:28.000Z</published>
    <updated>2023-10-27T12:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要探讨如何使用 Android 项目包含的 <code>gradlew</code> 命令行程序签名 APK 文件. 这同时适用于 Debug 和 Release 等多个 variants. 以下以 Linux/OS X 环境为例.</p><p>笔者编译环境为 Gradle 8.0+ 和 Kotlin Gradle Settings, 对于 Groovy Gradle Settings 可能无等效方案.</p><span id="more"></span><h2 id="原理与主要思路"><a href="#原理与主要思路" class="headerlink" title="原理与主要思路"></a>原理与主要思路</h2><p>在 Android 项目根目录下执行如下命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assemble</span><br></pre></td></tr></table></figure><p>即可以生成所有 variants 对应的 APK 文件, 并根据 variant 名称分别存放于 <code>app/build/outputs/apk/&lt;variant&gt;</code> 中. 一般默认生成的 Android 项目包含 Debug 和 Release 两个 variants, 也可以分别使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assembleDebug</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assembleRelease</span><br></pre></td></tr></table></figure><p>生成对应 variant 的 APK.</p><p>但是在默认的 Gradle 配置中, 如此生成的 APK 文件是未签名的. 例如 Release variant 生成的 APK 文件默认会包含后缀名 “unsigned”. 若需要对其签名, 则需要传入对应的选项 (option) 实现.</p><p>本文选择在<strong>应用</strong>的 <code>build.gradle.kts</code> 中添加签名所需的选项, 并利用 Kotlin 语言 (相较于 Groovy) 的优势分离出敏感信息. 这样无需修改命令行指令即可编译出签名文件, 同时在不包含签名密钥的情况下也可以编译出未签名文件, 不影响编译命令原本的输出结果.</p><p><code>build.gradle.kts</code> 中控制签名的选项主要是 <code>android.signingConfigs</code> 和 <code>android.buildTypes.&lt;variant&gt;.signingConfig</code>. 前者用于指定密钥数据库位置, 密码等敏感信息作为一个 signing config, 后者用于指定该 variant 使用何种 signing config.</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="设置密钥信息"><a href="#设置密钥信息" class="headerlink" title="设置密钥信息"></a>设置密钥信息</h3><p>假定存储敏感信息的文件名为 <code>credentials.properties</code>. 我们选择利用 <code>java.util.Properties</code> 读取该文件. 在该文件中写入类似如下的内容:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">STORE_FILE</span>=/path/to/keystore.jks    <span class="comment"># Key store 路径</span></span><br><span class="line"><span class="attr">STORE_PASSWORD</span>=password             <span class="comment"># Key store 密码</span></span><br><span class="line"><span class="attr">KEY_ALIAS</span>=MyApp                     <span class="comment"># Key 别名 (alias)</span></span><br><span class="line"><span class="attr">KEY_PASSWORD</span>=password               <span class="comment"># Key 密码</span></span><br></pre></td></tr></table></figure><p>以上内容需要符合 Java <code>Properties</code> 的语法规则, <strong>特别注意</strong>等号 (<code>=</code>) 等只要出现在键名之后则不需要特别转义, 但是反斜杠 (<code>\</code>) 需要特别转义为 <code>\\</code>.</p><h3 id="在-build-gradle-kts-中指定密钥"><a href="#在-build-gradle-kts-中指定密钥" class="headerlink" title="在 build.gradle.kts 中指定密钥"></a>在 <code>build.gradle.kts</code> 中指定密钥</h3><p>打开<strong>应用</strong>的 <code>build.gradle.kts</code>, 在开头添加[^1]</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f = rootProject.file(<span class="string">&quot;credentials.properties&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> credentials: Properties? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (f.exists() &amp;&amp; f.isFile) &#123;</span><br><span class="line">    credentials = Properties().apply &#123;</span><br><span class="line">        load(rootProject.file(<span class="string">&quot;credentials.properties&quot;</span>).reader())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码表示仅在 <code>credentials.properties</code> 文件存在时才读取并将其存入 <code>credentials</code> 变量中. 其他类似的写法皆可.</p><p>再在 <code>android &#123;&#125;</code> 语句块中添加如下内容[^2]:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (credentials != <span class="literal">null</span>) &#123;</span><br><span class="line">        signingConfigs &#123;</span><br><span class="line">            create(<span class="string">&quot;release&quot;</span>) &#123;</span><br><span class="line">                storeFile = credentials!![<span class="string">&quot;STORE_FILE&quot;</span>]?.let &#123; file(it) &#125;</span><br><span class="line">                storePassword = credentials!![<span class="string">&quot;STORE_PASSWORD&quot;</span>].toString()</span><br><span class="line">                keyAlias = credentials!![<span class="string">&quot;KEY_ALIAS&quot;</span>].toString()</span><br><span class="line">                keyPassword = credentials!![<span class="string">&quot;KEY_PASSWORD&quot;</span>].toString()</span><br><span class="line">                enableV1Signing = <span class="literal">true</span></span><br><span class="line">                enableV2Signing = <span class="literal">true</span></span><br><span class="line">                enableV3Signing = <span class="literal">true</span></span><br><span class="line">                enableV4Signing = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (credentials != <span class="literal">null</span>) &#123;</span><br><span class="line">                signingConfig = signingConfigs.getByName(<span class="string">&quot;release&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在 <code>credentials</code> 正确读入密钥信息后设置相应的 signing config, 并开启 v1 至 v4 的<a href="https://source.android.com/docs/security/features/apksigning">应用签名方案</a>, 随后设置仅对 Release 的 variant 签名.</p><p>如此, 使用 <code>./gradlew assembleRelease</code> 命令即可生成签名后的 APK 了.</p><h2 id="验证-APK-签名"><a href="#验证-APK-签名" class="headerlink" title="验证 APK 签名"></a>验证 APK 签名</h2><p>使用 <code>jarsigner</code> 程序即可检查签名的有效性[^3]:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verify -verbose -certs /path/to/my/signed/apk.apk</span><br></pre></td></tr></table></figure><p>如果输出中 <code>CN=</code> 后为自己的密钥的签发者, 则说明 APK 签名成功.</p><h2 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h2><p><strong>若使用 Git 等版本控制工具, 请务必将 <code>credentials.properties</code> 忽略掉!</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[^1]: <a href="https://stackoverflow.com/a/71934561/12002560">https://stackoverflow.com/a/71934561/12002560</a>.<br>[^2]: <a href="https://gist.github.com/mileskrell/7074c10cb3298a2c9d75e733be7061c2">https://gist.github.com/mileskrell/7074c10cb3298a2c9d75e733be7061c2</a>.<br>[^3]: <a href="https://stackoverflow.com/a/7104680/12002560">https://stackoverflow.com/a/7104680/12002560</a>.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要探讨如何使用 Android 项目包含的 &lt;code&gt;gradlew&lt;/code&gt; 命令行程序签名 APK 文件. 这同时适用于 Debug 和 Release 等多个 variants. 以下以 Linux/OS X 环境为例.&lt;/p&gt;
&lt;p&gt;笔者编译环境为 Gradle 8.0+ 和 Kotlin Gradle Settings, 对于 Groovy Gradle Settings 可能无等效方案.&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    <category term="Tutorial" scheme="https://blog.tamako.work/categories/Essay/Tutorial/"/>
    
    
    <category term="Android" scheme="https://blog.tamako.work/tags/Android/"/>
    
    <category term="Gradle" scheme="https://blog.tamako.work/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>【文件格式探究】EP.2 WAV 音频文件格式</title>
    <link href="https://blog.tamako.work/techdev/format/wav/"/>
    <id>https://blog.tamako.work/techdev/format/wav/</id>
    <published>2023-07-15T20:41:45.000Z</published>
    <updated>2023-07-26T12:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>“WAV” 全名 “Waveform Audio File Format”, 是一种常见的存储音频信息的文件格式标准, 从其名称上即可看出其存储的是音频的波形信息. 一般 WAV 存储的音频是未压缩的, 且遵循 <a href="https://en.wikipedia.org/wiki/Resource_Interchange_File_Format">RIFF 标准</a>来构建文件内容, 相较于其他音频格式省去了解压缩等处理, 复杂度较低. 本文将通过一个真实的 WAV 格式文件示例, 一一说明 WAV 文件格式中各个数据块的含义和位置, 并提供简单地读写 WAV 文件的代码实现, 并最终尝试生成自定义波形的 WAV 文件. 本文除涉及 WAV 格式最重要的文件头和数据块之外, 还将讲解 LIST-INFO 元信息格式在 WAV 中的应用.</p><span id="more"></span><h2 id="前置知识-音频的数位化表示"><a href="#前置知识-音频的数位化表示" class="headerlink" title="前置知识: 音频的数位化表示"></a>前置知识: 音频的数位化表示</h2><p>声现象的本质是振动. 发声源通过产生人耳可听范围内某一频率的振动, 人耳即可以听到声音. 若将扬声器的表面看作一个富有弹性的平面, 且初始状态静止于零形变处, 那么扬声器在工作时, 可以认为其表面不停地向内或向外产生相对于初始状态的位移 - 这被称为 “振幅”. 扬声器工作时其表面的位移量, 可以看作是一个关于时间的函数.</p><p>上述场景在真实世界中很容易理解, 但在计算机中需要考虑一些很重要的问题, 例如: 计算机存储数据的精度是有限的, 而真实世界中完全可能出现在时间等于 $\pi$ 秒时振幅为 $\sqrt{2}$; 同理, 扬声器的振幅可以为 $1$, 也可以为 $1e10$. 计算机如何存储精度要求极高或如此巨大的数字? 答案很简单: 不存储. 但我们自然希望尽可能精确且全面地记录下这些振幅以及对应的时刻, 这就牵扯到后面提到的 “PCM” (Pulse-code modulation, 脉冲编码调制).</p><h3 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h3><p>调制可以理解为将输入信号转变为另一个信号的过程. 而在我们上述的场景中, 当我们面对一个信息量巨大且信息精度很高的 “真实世界信号” (或者应该称之为 “模拟信号”) 时, 我们希望通过一种调制方式将其转变为计算机可接受的 “数字信号”. 一种应用相当普遍的调制方式即为 PCM, 它经常用于模数转换.</p><p>简单来说, PCM 是在时域上对模拟信号的时间轴和振幅轴同时做量化处理, 使之可以用一系列有限值来表示. 为方便起见, 本文仅考虑 LPCM (Linear pulse-code modulation) - 一种量化等级线性均匀排布的调制方式. 因为这种调制方式太过常见, 若无特别说明, 以下的 “PCM” 均指代 “LPCM”.</p><p>从数学上来说, 若要将振幅范围 $[0,A]$ 线性映射到一系列量化值 ${0,1,\cdots,N}$, 则对于某一振幅 $x\in[0,A]$, 其将会被量化到 $\mathrm{round}\left(\dfrac{x}{A}N\right)$, 其中 $\mathrm{round}(\cdot)$ 表示四舍五入. 显然 $N$ 决定了我们量化的精度. 较大的 $N$ 对于较大的 $A$ 也可以保持较好的量化效果 (如果不去除这些振幅较大的值), 对于较小的 $A$ 可以使其量化结果更接近于真实值.</p><p>一般来说, 量化范围内能表示的所有整数所需要的比特位数被称为<strong>位深</strong> (bit depth), 常见的位深有 8-bit, 16-bit, 24-bit, 分别表示量化范围内可以表示 $2^8$, $2^{16}$, $2^{24}$ 个连续整数. 实际应用中, 一般 8-bit PCM 的量化范围为 $[0,2^8)$, (或 $[0,256)$) 也就是无符号整数; 而超过这一位深的量化范围 (以 16-bit 为例) 通常表示为 $[-2^{15},2^{15})$ (或 $[-32768,32768)$), 也就是有符号整数. 对于前者, 其零振幅时的量化值为 $2^7$ (或 128); 对于后者, 其零振幅时的量化值为 0.</p><p>此时仍然还有一个需要讨论的问题 - 时间轴如何量化? 一般来说我们仅考虑线性均匀采样, 以一个固定的<strong>采样率</strong> (sample rate). 这是与位深类似的概念 - 显然采样率越高, 采样就越精确, 但这会带来很大的存储和处理成本; 而采样率下降, 甚至可能连模拟信号的频率信息都会丢失 (想象频率为 1Hz 的正弦波以 1Hz 均匀采样, 每次采样的结果都是相同的振幅).</p><p>对于采样率的下限, 在数字信号处理领域有著名的 <a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">Nyquist-Shannon sampling theorem</a> (奈奎斯特-香农采样定理), 表明采样率应不小于波形最高频率的 2 倍, 才可能保证波形的各个分量的频率信息不丢失. 而根据傅里叶变换, 任何函数都可以分解为不同频率的正余弦函数之和. 因此, 在仅考虑幅度超过一定阈值的频率分量的情况下 (这是考虑到傅里叶变换的结果可能包含无穷多个频率分量, 但一般实际情况高频分量的幅度都很小; 限定幅度阈值后可以认为波形的正余弦分量有最高频率), 任何波形都可以应用这一定理, 从而推得采样率的下限.</p><p>实际上, 在很多场合下, 采样率仅仅超过最高频率的 2 倍是远远不够的. 在工程相关领域, 这个倍数可以达到 6 倍左右. 一般我们接触到的音频文件的采样率多在 44,100Hz, 少数能达到 48,000Hz 或更高. 人耳能听到的振动频率范围在 20Hz~20,000Hz 左右, 显然 44,100Hz 已经超过 Nyquist-Shannon sampling theorem 所要求的采样率下限. 一般音乐的波形频率不会达到如此高的频率. 以 MIDI 能表示的音高为例, 音符事件的音调最大值 127 (对应音高为 G9) 对应的频率约为 12544Hz, 接近于采样率的四分之一.</p><p>对于 PCM 而言, 最重要的两个参数即是上述的<strong>位深</strong>和<strong>采样率</strong>.</p><h2 id="WAV-文件格式的结构"><a href="#WAV-文件格式的结构" class="headerlink" title="WAV 文件格式的结构"></a>WAV 文件格式的结构</h2><p>接下来我们将正式开始讨论 WAV 文件格式是如何构建的. 前文中提到 WAV 格式遵循 RIFF 标准, 因此 WAV 格式本身即是 RIFF 标准中的一个 “RIFF” chunk, 并具有规定的文件头. 除去文件头剩余的文件内容被分为一些 sub-chunk, 例如规定音频格式具体信息的 “fmt “ (注意这里的空格, 很快将知道为什么) sub-chunk 和定义音频波形具体数据的 “data” sub-chunk, 还可能包含 “LIST” 元信息 sub-chunk. 按照 RIFF 标准, “RIFF” 和 “LIST” chunk 的剩余文件内容 (或者也可以理解为这些 chunks 的数据部分) 是其他 sub-chunks, 而 “fmt “ 和 “data” 此类普通的 sub-chunks 的数据部分就是普通的二进制数据流.</p><p>更详细地, 按照 RIFF 标准, 所有的数据都是以 chunk 的形式存储. 这些 chunk 都具有如下的结构:</p><table><thead><tr><th align="center">长度 (字节数)</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">chunk 的 ASCII 标识符 (“RIFF”, “LIST” 等)</td></tr><tr><td align="center">4</td><td align="center">chunk 的 “数据部分” 的长度</td></tr><tr><td align="center">剩余</td><td align="center">chunk 的 “数据部分”</td></tr></tbody></table><p>其中对于 “RIFF” 和 “LIST” 两种特殊的 chunks, 其 “数据部分” 又可以拆分为:</p><table><thead><tr><th align="center">长度 (字节数)</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">chunk “数据部分” 的 ASCII 标识符<br>(例如 WAV 格式的 “WAVE”, 元信息的 “INFO”)</td></tr><tr><td align="center">剩余</td><td align="center">sub-chunk 1, sub-chunk 2, …</td></tr></tbody></table><p>显然这里的 ASCII 标识符的长度必须为 4 个字节, 因此 “fmt” 后添加了一个空格以填充空隙. 类似的有 AVI 格式的 “RIFF” chunk, 其 “数据部分” 的 ASCII 标识符为 “AVI “, 同样包含一个末尾的空格.</p><p>值得注意的是, 这里涉及到各个 chunk 的不同域 (field), 只有 ASCII 标识符是大端序 (big-endian) 的, 其他的都是小端序 (little-endian). 在后续的例子中我们可以看出这二者的区别.</p><p>以及, 对于某些情况, 整个 chunk 如果长度不为偶数, 通常会加入一个 padding space (以 <code>\x00</code> 填充). 在本文所述的场景中, <code>\x00</code> 被填充在整个 chunk 的末尾, 并<strong>不将其计入整个 chunk 的长度</strong>. 这也会在后续的例子中说明.</p><p>接下来将详细讨论不同的 sub-chunks. 为方便起见, 对于它们我们仍然称为 “chunks”.</p><h3 id="“fmt-“-chunk"><a href="#“fmt-“-chunk" class="headerlink" title="“fmt “ chunk"></a>“fmt “ chunk</h3><p>除去该 chunk 的前 8 个固定字节不谈, 我们仅讨论其 “数据部分” 的结构:</p><table><thead><tr><th align="center">长度 (字节数)</th><th align="center">域名 (field name)</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">AudioFormat</td><td align="center">音频格式, 表征普通的 PCM 或压缩处理</td></tr><tr><td align="center">2</td><td align="center">NumChannels</td><td align="center">频道 (声道) 数</td></tr><tr><td align="center">4</td><td align="center">SampleRate</td><td align="center">采样率 (单位 Hz)</td></tr><tr><td align="center">4</td><td align="center">ByteRate</td><td align="center">每秒钟所占字节数</td></tr><tr><td align="center">2</td><td align="center">BlockAlign</td><td align="center">每个样本在所有频道所占字节数之和</td></tr><tr><td align="center">2</td><td align="center">BitsPerSample</td><td align="center">位深</td></tr><tr><td align="center">2</td><td align="center">ExtraParamSize</td><td align="center">(可选) 额外参数长度</td></tr><tr><td align="center">剩余</td><td align="center">ExtraParams</td><td align="center">额外参数</td></tr></tbody></table><p>对于部分 fields 有如下的说明 (以下数字取值均用十进制表示):</p><ul><li>AudioFormat<ul><li>PCM 未压缩: 1</li><li>其他压缩形式: 其他值</li></ul></li><li>NumChannels<ul><li>单声道: 1</li><li>双声道: 2</li><li>7.1 声道: 8</li></ul></li><li>ByteRate: 计算式为 <code>SampleRate * NumChannels * BitsPerSample / 8</code></li><li>BlockAlign: 计算式为 <code>NumChannels * BitsPerSample / 8</code></li></ul><h3 id="“LIST”-chunk-可选"><a href="#“LIST”-chunk-可选" class="headerlink" title="“LIST” chunk (可选)"></a>“LIST” chunk (可选)</h3><p>上文提及该 chunk 是用来记录 WAV 格式的元信息, 诸如歌曲名, 艺术家, 专辑等等. 这些信息存储在下属的 sub-chunks 内, 且原则上都是<strong>可选</strong>的. 需要注意在必要的时候为 chunk 的末尾补 padding space. 以下列举可能出现的 sub-chunk 的标识符及其含义.</p><table><thead><tr><th align="center">标识符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">INAM</td><td align="center">音频 (track) 标题</td></tr><tr><td align="center">IPRD</td><td align="center">专辑标题</td></tr><tr><td align="center">IART</td><td align="center">创作者</td></tr><tr><td align="center">ICRD</td><td align="center">创作日期 (格式为 “YYYY-MM-DD”, 但通常只会保留年份 “YYYY”)</td></tr><tr><td align="center">ITRK</td><td align="center">音频在专辑中的序号</td></tr><tr><td align="center">ICMT</td><td align="center">注释 (comment) 文本</td></tr><tr><td align="center">IKEY</td><td align="center">工程或文件的关键词</td></tr><tr><td align="center">ISFT</td><td align="center">创建该音频的软件</td></tr><tr><td align="center">IENG</td><td align="center">参与创建该音频的工程师 (engineer). 若有多人则用 <code>;</code> 和半角空格隔开.</td></tr><tr><td align="center">IGNR</td><td align="center">流派</td></tr><tr><td align="center">ICOP</td><td align="center">版权信息</td></tr><tr><td align="center">ISBJ</td><td align="center">主题 (subject)</td></tr><tr><td align="center">ISRC</td><td align="center">提供音频原始主题的人或组织</td></tr></tbody></table><h3 id="“data”-chunk"><a href="#“data”-chunk" class="headerlink" title="“data” chunk"></a>“data” chunk</h3><p>这个 chunk 最终依照时间顺序存储各个样本 (sample) 的 PCM 量化数据. 直接考虑其 “数据部分” - 这是一个 (通常很长的) 连续二进制流. 这个二进制流由诸多 samples 组成, 每个 sample 顺序存储不同声道的数据 (且每个 sample 需要结束在偶数字节位置, 不过对于 16-bit 位深的音频通常一定是满足这个条件的), 而每个声道在该样本下的数据为一个固定比特位数的整数 (这个位数由位深决定). 更具体的解释见后文的示例文件.</p><h2 id="WAV-文件示例"><a href="#WAV-文件示例" class="headerlink" title="WAV 文件示例"></a>WAV 文件示例</h2><p>以下截取<a href="https://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%AB%E3%82%AB%E3%83%88%E3%83%9F%E3%83%A6%E3%82%AD">ハルカトミユキ</a>的音乐作品<a href="http://www.iroduku.jp/products/detail.php?p=1&c=2&id=m1">《17才》</a>的一个 WAV 格式音频文件的前 0xead0 (十进制 60,112) 行部分内容, 并以 <code>hexdump</code> 命令的形式呈现.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00000000  52 49 46 46 4e 68 e1 02  57 41 56 45 4c 49 53 54  |RIFFNh..WAVELIST|</span><br><span class="line">00000010  90 00 00 00 49 4e 46 4f  49 41 52 54 0f 00 00 00  |....INFOIART....|</span><br><span class="line">00000020  a5 cf a5 eb a5 ab a5 c8  a5 df a5 e6 a5 ad 00 00  |................|</span><br><span class="line">00000030  49 4e 41 4d 05 00 00 00  31 37 b2 c5 00 00 49 50  |INAM....17....IP|</span><br><span class="line">00000040  52 44 16 00 00 00 31 37  b2 c5 20 5b c6 da e9 67  |RD....17.. [...g|</span><br><span class="line">00000050  c9 fa ae 62 cf de b6 a8  b1 50 5d 00 49 47 4e 52  |...b.....P].IGNR|</span><br><span class="line">00000060  14 00 00 00 49 6e 64 69  65 20 2f 20 41 6c 74 65  |....Indie / Alte|</span><br><span class="line">00000070  72 6e 61 74 69 76 65 00  49 54 4f 43 1a 00 00 00  |rnative.ITOC....|</span><br><span class="line">00000080  34 2b 39 36 2b 35 30 44  39 2b 39 31 46 43 2b 44  |4+96+50D9+91FC+D|</span><br><span class="line">00000090  32 45 39 2b 31 31 42 37  34 00 49 54 52 4b 02 00  |2E9+11B74.ITRK..|</span><br><span class="line">000000a0  00 00 31 00 66 6d 74 20  12 00 00 00 01 00 02 00  |..1.fmt ........|</span><br><span class="line">000000b0  44 ac 00 00 10 b1 02 00  04 00 10 00 00 00 64 61  |D.............da|</span><br><span class="line">000000c0  74 61 90 67 e1 02 00 00  00 00 00 00 00 00 00 00  |ta.g............|</span><br><span class="line">000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">0000ead0  00 00 00 00 00 00 01 00  00 00 00 00 00 00 00 00  |................|</span><br></pre></td></tr></table></figure><p>简单说明上述的数据呈现形式: 最左侧的 8 位十六进制数表示该行首个字节在文件中的位置 (offset); 每行中间排列 16 个 2 位十六进制数 (8 位二进制数, 1 个字节); 最右侧是各个对应数据的 ASCII 形式; 大量相同行的数据将会以 <code>*</code> 省略.</p><p>后面我们将要涉及到前文暂按下不表的 “小端序”. 简单来说, 小端序指的是将一个超过 8 位的整数按照字节切分后逆向排列各个部分存储在计算机中的方式. 举例来说, 若一个 32 位整数在计算机中存储为 “01 02 03 04” (忽略方便阅读的空格, 后同), 则该整数的实际值应为 0x04030201. 与之相对, 大端序即是将其顺向排列, 也就是 0x04030201 存储为 “04 03 02 01”.</p><p>接下来, 我们将一一剖析其中的各种信息.</p><h3 id="“RIFF”-chunk-头"><a href="#“RIFF”-chunk-头" class="headerlink" title="“RIFF” chunk 头"></a>“RIFF” chunk 头</h3><p>这可谓是整个小姐最容易分析的部分: 考虑位置 0x0 ~ +8 (表示从 0x0 位置到 0x0+8=0x8 位置, 包含左端点但不包含右端点, 后同), 前 4 个字节是该 chunk 的标识符 “RIFF”, 后 4 个字节表征该文件去除该 chunk 文件头后的字节数. <code>4e 68 e1 02</code> 应该理解为 0x02e1684e, 也即 48326734 (约 46 MiB, 与文件系统显示的大小相符). 位置 0x8 ~ +4 为 “RIFF” chunk 的 “数据部分” 的 ASCII 标识符 “WAVE”.</p><h3 id="“LIST”-chunk-的结构"><a href="#“LIST”-chunk-的结构" class="headerlink" title="“LIST” chunk 的结构"></a>“LIST” chunk 的结构</h3><p>位置 0x12 ~ +12 类似<a href="#riff-chunk-%E5%A4%B4">上一小节</a>. 略去.</p><p>位置 0x24 ~ +24 为 “IART” chunk. “IART” 的 ASCII 标识符略去. 注意到位置 0x28 ~ +4 标示的 chunk “数据部分” 大小为 0x0000000f 也即 15. 位置 0x20 ~ +15 的字节流使用 <a href="https://en.wikipedia.org/wiki/GB_18030">GB18030 编码</a>解码后恰好得到的是 “ハルカトミユキ” (不包含引号, 后同) 附加一个空字符 <code>\x00</code> - 这应该是 CD 在 Windows 平台抓取时平台默认在元信息后增加空白字符所致, 不影响分析; 后续出现类似情况不再赘述. 位置 0x2f 则是 padding space.</p><p>后续 “IPRD”, “IGNR”, “ITOC”, “ITRK” chunks 的分析类似. 另外可以看到 “IPRD” chunk 后即没有 padding space, 符合前文的分析.</p><h3 id="“fmt-“-chunk-的结构"><a href="#“fmt-“-chunk-的结构" class="headerlink" title="“fmt “ chunk 的结构"></a>“fmt “ chunk 的结构</h3><p>相较于其他的 chunks, 这个 chunk 因为连续排布了很多信息, 很容易看错. 这个 chunk 的位置为 0xa4 ~ +26. 略去与前述小节类似的 0xa4 ~ +8 的部分, 直接考虑后续的 18 个字节. 以下以表格形式呈现不同位置的数据及其表达的信息.</p><table><thead><tr><th align="center">位置</th><th align="center">域名 (field name)</th><th align="center">原始数据</th><th align="center">实际<strong>十进制</strong>数</th></tr></thead><tbody><tr><td align="center">0xac ~ +2</td><td align="center">AudioFormat</td><td align="center"><code>01 00</code></td><td align="center">1</td></tr><tr><td align="center">0xae ~ +2</td><td align="center">NumChannels</td><td align="center"><code>02 00</code></td><td align="center">2</td></tr><tr><td align="center">0xb0 ~ +4</td><td align="center">SampleRate</td><td align="center"><code>44 ac 00 00</code></td><td align="center">44100</td></tr><tr><td align="center">0xb4 ~ +4</td><td align="center">ByteRate</td><td align="center"><code>10 b1 02 00</code></td><td align="center">176400</td></tr><tr><td align="center">0xb8 ~ +2</td><td align="center">BlockAlign</td><td align="center"><code>04 00</code></td><td align="center">4</td></tr><tr><td align="center">0xba ~ +2</td><td align="center">BitsPerSample</td><td align="center"><code>10 00</code></td><td align="center">16</td></tr><tr><td align="center">0xbc ~ +2</td><td align="center">ExtraParamSize</td><td align="center"><code>00 00</code></td><td align="center">0</td></tr></tbody></table><h3 id="“data”-chunk-的结构"><a href="#“data”-chunk-的结构" class="headerlink" title="“data” chunk 的结构"></a>“data” chunk 的结构</h3><p>从位置 0xbe 开始直至文件末尾都是 “data” chunk. 前 4 个字节同样略去不解释. 这里可以看到位置 0xd0 ~ 0xead0 几乎都全是空字节 <code>\x00</code>, 表示没有音频输出. 0xead0 - 0xd0 为十进制 59,904, 在采样率 44,100Hz 前提下大约为持续 1.4 秒, 符合音乐录音开头空白的通常时长.</p><p>因为原音频文件中很难找到各个 sample 之间差异较大的位置, 我将以虚构的一段 “data” chunk 的 “数据部分” 作解释 (假设位深和声道数不变):</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 02 03 04 05 06 07 08</span><br></pre></td></tr></table></figure><p>上述 8 个字节总共包含 4 个 samples - <code>01 02</code>, <code>03 04</code>, <code>05 06</code>, <code>07 08</code>. 每个 sample 包含 2 个声道的数据, 以第 1 个 sample 举例则是 <code>01</code> 和 <code>02</code>. 其中第 1 个声道的数据为 <code>01</code>, 表示其 PCM 量化值为十进制的 1.</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><!-- 以下将给出笔者的简单读写 WAV 文件的 Rust 语言实现. 为方便起见, 以下实现并没有做严格的错误处理. --><p>待补充.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>本文大量引用如下网络资源:</p><ul><li><a href="https://en.wikipedia.org/wiki/WAV">WAV - Wikipedia</a>.</li><li><a href="https://en.wikipedia.org/wiki/Pulse-code_modulation">Pulse-code modulation - Wikipedia</a>.</li><li><a href="https://stackoverflow.com/a/5891128/12002560">iphone - PCM audio amplitude values? - Stack Overflow</a>.</li><li><a href="http://blog.ccyg.studio/article/be12c2ee-d47c-4098-9782-ca76da3035e4/">音高和频率的关系</a>.</li><li><a href="https://en.wikipedia.org/wiki/Resource_Interchange_File_Format">Resource Interchange File Format - Wikipedia</a>.</li><li><a href="http://tiny.systems/software/soundProgrammer/WavFormatDocs.pdf">http://tiny.systems/software/soundProgrammer/WavFormatDocs.pdf</a>.</li><li><a href="https://www.robotplanet.dk/audio/wav_meta_data/">Wav Meta Data - Audio - RobotPlanet</a>.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;“WAV” 全名 “Waveform Audio File Format”, 是一种常见的存储音频信息的文件格式标准, 从其名称上即可看出其存储的是音频的波形信息. 一般 WAV 存储的音频是未压缩的, 且遵循 &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Interchange_File_Format&quot;&gt;RIFF 标准&lt;/a&gt;来构建文件内容, 相较于其他音频格式省去了解压缩等处理, 复杂度较低. 本文将通过一个真实的 WAV 格式文件示例, 一一说明 WAV 文件格式中各个数据块的含义和位置, 并提供简单地读写 WAV 文件的代码实现, 并最终尝试生成自定义波形的 WAV 文件. 本文除涉及 WAV 格式最重要的文件头和数据块之外, 还将讲解 LIST-INFO 元信息格式在 WAV 中的应用.&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="File Format" scheme="https://blog.tamako.work/tags/File-Format/"/>
    
    <category term="WAV" scheme="https://blog.tamako.work/tags/WAV/"/>
    
    <category term="Audio" scheme="https://blog.tamako.work/tags/Audio/"/>
    
    <category term="PCM" scheme="https://blog.tamako.work/tags/PCM/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux 安装 TiddlyWiki + 配置服务 + 添加自定义插件 + Cloudflare 代理 + Caddy 反向代理</title>
    <link href="https://blog.tamako.work/techdev/arch/tiddlywiki/"/>
    <id>https://blog.tamako.work/techdev/arch/tiddlywiki/</id>
    <published>2023-05-12T07:28:26.000Z</published>
    <updated>2023-05-12T12:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将覆盖 TiddlyWiki Node.JS 版本在 Arch Linux 上的安装, 并涉及配置 TiddlyWiki 服务, 添加自定义插件, 在 Cloudflare 代理 DNS 的情形下设置 Caddy 反向代理的内容.</p><span id="more"></span><blockquote><p>笔者因为自己和身边发生了各种各样的事情, 疲于更新博客. 今天只能随手写写.</p></blockquote><h2 id="较详细的本文将覆盖的内容"><a href="#较详细的本文将覆盖的内容" class="headerlink" title="较详细的本文将覆盖的内容"></a>较详细的本文将覆盖的内容</h2><ul><li>TiddlyWiki<ul><li>安装</li><li>配置一个 systemd 服务</li><li>将自定义插件放置在统一目录下</li></ul></li><li>Cloudflare<ul><li>添加 DNS 记录</li><li>申请 API token</li></ul></li><li>Caddy<ul><li>编译自定义 build</li><li>配置反向代理</li><li>添加 HTTP basic auth</li></ul></li><li>测试</li></ul><h2 id="相关软件包和工具"><a href="#相关软件包和工具" class="headerlink" title="相关软件包和工具"></a>相关软件包和工具</h2><ul><li><a href="https://tiddlywiki.com/">TiddlyWiki</a>: 一个非线性个人 wiki;</li><li><a href="https://github.com/caddyserver/xcaddy">xcaddy</a>: 自定义编译 <code>caddy</code>;</li><li><a href="https://github.com/caddyserver/caddy">caddy</a>: 反向代理.</li></ul><h2 id="TiddlyWiki"><a href="#TiddlyWiki" class="headerlink" title="TiddlyWiki"></a>TiddlyWiki</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tiddlywiki</span><br></pre></td></tr></table></figure><h3 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tiddlywiki --version</span><br><span class="line">5.2.7</span><br></pre></td></tr></table></figure><h3 id="初始化并监听"><a href="#初始化并监听" class="headerlink" title="初始化并监听"></a>初始化并监听</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/mywiki</span><br><span class="line">tiddlywiki . --init</span><br><span class="line"><span class="comment"># 默认 host=127.0.0.1 port=8080</span></span><br><span class="line">tiddlywiki . --listen</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">tiddlywiki . --listen host=0.0.0.0 port=8081</span><br></pre></td></tr></table></figure><p>若在终端中输出了诸如缺少 <code>&quot;tiddlywiki/filesystem&quot;</code>, <code>&quot;tiddlywiki/tiddlyweb&quot;</code> 插件的消息, 请在 <code>/path/to/mywiki</code> 中的 <code>tiddlywiki.info</code> 对应位置添加如下内容:</p><figure class="highlight json"><figcaption><span>tiddlywiki.info</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;tiddlywiki/filesystem&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tiddlywiki/tiddlyweb&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>随后重新监听.</p><h3 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h3><p>为方便控制启动参数, 可以考虑在 <code>/path/to/mywiki</code> 中新建如下的启动脚本 (例如, 命名为 <code>server.sh</code>):</p><figure class="highlight shell"><figcaption><span>server.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">tiddlywiki `dirname $0` --listen $@</span><br></pre></td></tr></table></figure><p>并使用 <code>chmod +x server.sh</code> 使其可以被执行.</p><p>确认 TiddlyWiki 可以正常工作后, 新建 <code>/usr/lib/systemd/system/tiddlywiki.service</code> 文件, 添加如下内容:</p><figure class="highlight text"><figcaption><span>tiddlywiki.service</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=A non-linear personal web notebook</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/usr/local/etc/tiddlywiki/env</span><br><span class="line">ExecStart=/path/to/mywiki/server.sh</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>其中 <code>/usr/local/etc/tiddlywiki/env</code> 是一个环境变量文件, 可以忽略. 后面的操作可以向其添加必要的环境变量.</p><h3 id="统一存储自定义插件"><a href="#统一存储自定义插件" class="headerlink" title="统一存储自定义插件"></a>统一存储自定义插件</h3><p>TiddlyWiki 在 <code>/path/to/mywiki/plugins</code> 文件夹下的插件是不包含命名空间的[^1], 但若要在插件文件夹内以 <code>&lt;命名空间&gt;/&lt;插件名称&gt;</code> 的形式存储, 又不想修改 <code>/usr/local/lib/node_modules/tiddlywiki/plugins</code> 文件夹的内容, 则可以使用环境变量 <code>TIDDLYWIKI_PLUGIN_PATH</code> 指定一个 “额外” 的插件文件夹[^2]. 假设这个文件夹是 <code>/usr/local/share/tiddlywiki/plugins</code>, 那么只需要在 <code>/usr/local/etc/tiddlywiki/env</code> 文件中添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIDDLYWIKI_PLUGIN_PATH=/usr/local/share/tiddlywiki/plugins</span><br></pre></td></tr></table></figure><p>这样, 在该文件夹下添加诸如 <code>author/name</code> 的插件, 在 <code>tiddlywiki.info</code> 中即可如同添加官方插件一般在 <code>plugins</code> 数组下添加 <code>&quot;author/name&quot;</code> 字符串即可.</p><h3 id="本章节相关操作涉及到的需要手动更改的文件-夹"><a href="#本章节相关操作涉及到的需要手动更改的文件-夹" class="headerlink" title="本章节相关操作涉及到的需要手动更改的文件 (夹)"></a>本章节相关操作涉及到的需要手动更改的文件 (夹)</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/path/to/mywiki/</span><br><span class="line">/path/to/mywiki/server.sh</span><br><span class="line">/usr/lib/systemd/system/tiddlywiki.service</span><br><span class="line">/usr/local/etc/tiddlywiki/env</span><br><span class="line">/usr/local/share/tiddlywiki/plugins/</span><br></pre></td></tr></table></figure><h2 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h2><h3 id="添加-DNS-记录"><a href="#添加-DNS-记录" class="headerlink" title="添加 DNS 记录"></a>添加 DNS 记录</h3><p>根据实际情况选择 A 记录或 AAAA 记录. Proxy status 选择默认的 “Proxied”.</p><h3 id="申请-API-token"><a href="#申请-API-token" class="headerlink" title="申请 API token"></a>申请 API token</h3><ul><li>右上角子菜单;</li><li>“My profile”;</li><li>左侧 “API Tokens”;</li><li>“Create Token”;</li><li>“Edit zone DNS” 选择 “Use template”;</li><li>“Zone Resources” 下可以选择指定的 zone;</li><li>如果确定服务器的 IP 可以设置 “Client IP Address Filtering”;</li><li>“Continue to summary”;</li><li>复制 API token.<br>[^3]</li></ul><h3 id="设置-SSL-TLS-加密模式"><a href="#设置-SSL-TLS-加密模式" class="headerlink" title="设置 SSL/TLS 加密模式"></a>设置 SSL/TLS 加密模式</h3><ul><li>域名管理页面;</li><li>左侧 “SSL/TLS”;</li><li>子菜单 “Overview”;</li><li>模式选择 “Full” 或者 “Full (strict)”[^4].<br>[^3]</li></ul><h2 id="Caddy"><a href="#Caddy" class="headerlink" title="Caddy"></a>Caddy</h2><p>因为 Cloudflare 的 DNS 记录设置中选择了 “Proxied”, 现在服务器前相当于添加了一个 Cloudflare 的反向代理, 所以 Caddy 默认获取证书使用的 ACME HTTP-01 模式无法使用, 故利用 Caddy 的一个 <a href="https://github.com/caddy-dns/cloudflare">Cloudflare 模块</a>使用 ACME DNS-01 模式获取证书 - 这个模式通过修改 Cloudflare 上指定域名的 DNS 记录用以验证.[^5] 但由于这个模块本身并不包含在大部分软件包管理器中, 故需要手动编译包含该模块的 Caddy.</p><h3 id="自定义编译"><a href="#自定义编译" class="headerlink" title="自定义编译"></a>自定义编译</h3><p>自定义编译使用了 Caddy 官方推出的 <code>xcaddy</code> 工具. 编译 Caddy 时需要下载大量 Go 模块, 可能会占用较大量磁盘空间.</p><h4 id="安装-xcaddy"><a href="#安装-xcaddy" class="headerlink" title="安装 xcaddy"></a>安装 <code>xcaddy</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S xcaddy-bin</span><br></pre></td></tr></table></figure><p>[^6]</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译时选择临时文件夹 <code>/tmp</code> 作为编译目录.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">xcaddy build --with github.com/caddy-dns/cloudflare</span><br></pre></td></tr></table></figure><p>待编译结束后, 将生成的 <code>caddy</code> 可执行文件复制到诸如 <code>/usr/local/bin</code> 文件夹即可. <strong>注意</strong>环境变量 <code>$PATH</code> 中 <code>/usr/local/bin</code> 的优先级一般高于 <code>/usr/bin</code>, 故如此操作会使自定义编译的 <code>caddy</code> 优先于发行版软件包管理器中安装的版本.</p><h3 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h3><p>笔者的 <code>/etc/caddy/Caddyfile</code> 中存在如下的配置:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import /etc/caddy/conf.d/*</span><br></pre></td></tr></table></figure><p>因此选择在 <code>/etc/caddy/conf.d/tiddlywiki</code> 的文件中编写:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;domain&gt;:443 &#123;</span><br><span class="line">    tls &#123;</span><br><span class="line">        dns cloudflare &lt;token&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse_proxy localhost:8080</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上假设 TiddlyWiki 暴露在本地网络的端口为 8080. <code>&lt;domain&gt;</code> 为 <a href="#%E6%B7%BB%E5%8A%A0-dns-%E8%AE%B0%E5%BD%95">“添加 DNS 记录”</a> 小节中设置的域名, <code>&lt;token&gt;</code> 为 <a href="#%E7%94%B3%E8%AF%B7-api-token">“申请 API token”</a> 小节中申请到的 API token.</p><p>随后, 格式化配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo caddy <span class="built_in">fmt</span> --overwrite /etc/caddy/Caddyfile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo caddy <span class="built_in">fmt</span> --overwrite /etc/caddy/conf.d/tiddlywiki</span><br></pre></td></tr></table></figure><p>此时则可以重启 Caddy 服务检查是否正确配置 Caddy.</p><h3 id="添加-HTTP-basic-auth"><a href="#添加-HTTP-basic-auth" class="headerlink" title="添加 HTTP basic auth"></a>添加 HTTP basic auth</h3><p>HTTP basic auth 的效果简单来说, 会在访问页面的时候提示输入用户名和密码.</p><p>先使用 Caddy 生成哈希后的密码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caddy_naiveproxy hash-password --plaintext &lt;plain password&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;plain password&gt;</code> 为明文密码. 随后修改对应的 Caddyfile:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;domain&gt;:443 &#123;</span><br><span class="line">    ...</span><br><span class="line">    basicauth /* &#123;</span><br><span class="line">        &lt;username&gt; &lt;hashed password&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;username&gt;</code> 为 HTTP basic auth 中的用户名, <code>&lt;hashed password&gt;</code> 为上一步操作中生成的明文密码的哈希结果.</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>略.</p><p>[^1]: <a href="https://tiddlywiki.com/static/PluginFolders.html">https://tiddlywiki.com/static/PluginFolders.html</a>.<br>[^2]: <a href="https://tiddlywiki.com/static/Environment%2520Variables%2520on%2520Node.js.html">https://tiddlywiki.com/static/Environment%2520Variables%2520on%2520Node.js.html</a>.<br>[^3]: <a href="https://samjmck.com/en/blog/using-caddy-with-cloudflare/#2-using-a-lets-encrypt-certificate">https://samjmck.com/en/blog/using-caddy-with-cloudflare/#2-using-a-lets-encrypt-certificate</a>.<br>[^4]: 因为以下示例使用 Caddy 自动申请 Let’s Encrypt 证书, 所以选择 “Full (strict)” 也不会被阻断连接.<br>[^5]: <a href="https://samjmck.com/en/blog/using-caddy-with-cloudflare/#configuration-with-proxy-enabled">https://samjmck.com/en/blog/using-caddy-with-cloudflare/#configuration-with-proxy-enabled</a>.<br>[^6]: <code>xcaddy-bin</code> 的版本可能略旧于 <code>xcaddy</code>, 但前者省略了编译 <code>xcaddy</code> 的过程.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将覆盖 TiddlyWiki Node.JS 版本在 Arch Linux 上的安装, 并涉及配置 TiddlyWiki 服务, 添加自定义插件, 在 Cloudflare 代理 DNS 的情形下设置 Caddy 反向代理的内容.&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    <category term="Tutorial" scheme="https://blog.tamako.work/categories/Essay/Tutorial/"/>
    
    
    <category term="Arch Linux" scheme="https://blog.tamako.work/tags/Arch-Linux/"/>
    
    <category term="TiddlyWiki" scheme="https://blog.tamako.work/tags/TiddlyWiki/"/>
    
    <category term="Cloudflare" scheme="https://blog.tamako.work/tags/Cloudflare/"/>
    
    <category term="Caddy" scheme="https://blog.tamako.work/tags/Caddy/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux 在 ASUS Zenbook S 13 OLED (UM5302TA) 上的 patch</title>
    <link href="https://blog.tamako.work/techdev/arch/um5302ta/"/>
    <id>https://blog.tamako.work/techdev/arch/um5302ta/</id>
    <published>2023-01-09T13:21:35.000Z</published>
    <updated>2023-01-09T13:21:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>笔者在 <a href="https://www.asus.com/ca-en/laptops/for-home/zenbook/zenbook-s-13-oled-um5302-amd-ryzen-6000-series/">ASUS Zenbook S 13 OLED (UM5302TA)</a> 上安装 Arch Linux 时, 发现仅使用 Arch Linux 官方提供的 <a href="https://archlinux.org/packages/core/x86_64/linux/">linux</a> 或 AUR 上的 <a href="https://aur.archlinux.org/packages/linux-mainline">linux-mainline</a> 等系统 packages 无法修复一些影响使用体验的问题. 其中一些问题已经得到了有效的解决方法, 乃至被添加入 Linux 源码中; 一些问题的 patch 尚未被纳入 Linux 源码库; 还有一些问题仍无解决方案.</p><p>修复这些问题的主要方式是在 Linux 内核源码中添加 patch, 或者是使用其他的方式 (例如修改 Bootloader 的行为) 来 “动态” 添加部分系统功能. 这些问题的大部分 patch 已经有了更为自动化的解决方案.</p><p>值得注意的是, 本文提及的各种 patch 理论上可以应用于其他发行版.</p><span id="more"></span><h2 id="存在的问题和-patch"><a href="#存在的问题和-patch" class="headerlink" title="存在的问题和 patch"></a>存在的问题和 patch</h2><p>GitHub 上的 <a href="https://github.com/latin-1/um5302ta">um5302ta</a> 仓库汇集了该机型安装 Linux 后存在的各种问题, 以及针对这些问题的 patch, 本文不再赘述. 撰写本文时, 该仓库的最后一个 commit 为 <a href="https://github.com/latin-1/um5302ta/tree/b40223a5f9dd394f886c1ada50b46813f31e8444">b40223a</a>.</p><p>被纳入 Linux 源码的 patch 分散在不同的内核版本, 最早可追溯到 5.19, 最晚则到了 6.1. 目前 Arch Linux 官方提供的 linux 包已经更新到了 6.1.4.arch1, 本文也以此为例.</p><p>根据该仓库的 <a href="https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/README.md">README.md</a>, 目前尚未解决的问题为<a href="https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/README.md#fingerprint">指纹</a>, 若无特别提及, 后文提到的 “问题” “所有问题” 并不包含指纹相关的内容.</p><p>而尚未被添加到 Linux 源码库中的问题则是<a href="https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/README.md#speaker">扬声器</a>的 DSDT patch 和 <a href="https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/README.md#s3-sleep-deep-not-recommended">S3 级别睡眠</a>的 patch. 扬声器的 patch 有两个, 经笔者测试至少可以解决如下的问题:</p><ul><li><a href="https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/patches/dsdt/spkr-dsd.patch"><code>dsdt/spkr-dsd.patch</code></a>: 解决扬声器没有声音的问题;</li><li><a href="https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/patches/kernel/cs35l42-hda-no-acpi-dsd-csc3551.patch"><code>kernel/cs35l42-hda-no-acpi-dsd-csc3551.patch</code></a>: 解决机载麦克风指示灯常亮的问题.</li></ul><p>S3 睡眠的 <a href="https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/patches/dsdt/s3.patch">patch</a> 未经过笔者测试.</p><p>同时对<a href="https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/README.md#microphone">麦克风</a>的 patch 存在已知的音量过小的问题. 本文不会涉及对此的讨论.</p><p>实际使用发现, 该机型仍然存在数字小键盘无法使用的问题并未在该仓库中提及. 该机型的数字小键盘和触控板合并, 需要通过触摸触控板某一位置开关. 由于该功能实用性有限, 且存在可能的操作上的困难, 本文也不会涉及到该问题.</p><h2 id="主要的解决方案"><a href="#主要的解决方案" class="headerlink" title="主要的解决方案"></a>主要的解决方案</h2><h3 id="linux-mainline-um5302ta-AUR-包"><a href="#linux-mainline-um5302ta-AUR-包" class="headerlink" title="linux-mainline-um5302ta AUR 包"></a><code>linux-mainline-um5302ta</code> AUR 包</h3><table><thead><tr><th align="center">Linux 分支</th><th align="center">Linux 版本</th><th align="center">是否需要编译系统包</th><th align="center">是否需要手动添加 patch</th></tr></thead><tbody><tr><td align="center">主线</td><td align="center">&gt;= 5.19.rc4</td><td align="center">是</td><td align="center">否</td></tr></tbody></table><p>在 Linux 最新的内核版本尚未达到 5.19 时, 所有问题可以通过这个 <a href="https://aur.archlinux.org/packages/linux-mainline-um5302ta">AUR 包</a>修复. 该包会对 Linux <strong>主线</strong>的 tagged version 源码添加必要的 patch, 并进行<strong>编译安装</strong>. 若系统中已经安装 <code>yay</code> 等 AUR helper, 可以在终端中运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S linux-mainline-um5302ta</span><br></pre></td></tr></table></figure><p>安装. 这一命令同时会打包并安装 linux-mainline-um5302ta 和 linux-mainline-um5302ta-headers 两个包. 需要注意的是, 编译内核需要一定的时间.</p><p>因为 um5302ta 这一仓库的存在, 该 AUR 包的作者已经停止维护, 但是理论上通过修改该包的 PKGBUILD 文件仍然可以在未来的内核版本中实现相同的效果.</p><h3 id="其他系统包配合-um5302ta-仓库的-patch"><a href="#其他系统包配合-um5302ta-仓库的-patch" class="headerlink" title="其他系统包配合 um5302ta 仓库的 patch"></a>其他系统包配合 um5302ta 仓库的 patch</h3><table><thead><tr><th align="center">Linux 分支</th><th align="center">Linux 版本</th><th align="center">是否需要编译系统包</th><th align="center">是否需要手动添加 patch</th></tr></thead><tbody><tr><td align="center">任意</td><td align="center">&gt;= 6.0.9</td><td align="center">是/否</td><td align="center">是</td></tr></tbody></table><p>按照 um5302ta 仓库提供的方案, 理论上绝大部分符合版本的 Linux 分支或基于前者的分支皆可以修复问题.</p><p>值得注意的是, <code>dsdt/spkr-dsd.patch</code> 无需编译完整的 Linux 源码包即可应用, 且一大优点是不会在更新内核的时候被覆盖, 因此对于如下不同需求的读者, 可以按照如下的参考路径解决问题, 并选读本节不同的子章节:</p><ul><li><strong>无需 S3 睡眠且不在意麦克风指示灯问题, 且不希望编译完整系统包</strong>: 安装 Arch Linux 官方提供的 linux, linux-zen 等系统包, 并阅读<a href="#%E7%BC%96%E8%AF%91-cpio-archive">编译 CPIO archive</a>子章节;</li><li><strong>无需 S3 睡眠且不在意麦克风指示灯问题, 但需要自行安装其他系统包, 或需要解决前述的两个问题</strong>: 阅读<a href="#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%8C%85">编译安装系统包</a>和<a href="#%E7%BC%96%E8%AF%91-cpio-archive">编译 CPIO archive</a>子章节, 并<a href="#%E5%BA%94%E7%94%A8%E9%80%82%E5%BD%93%E7%9A%84-patch">选择适当的 patch</a>;</li><li><strong>不希望改动 boot loader 行为</strong>: 阅读<a href="#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%8C%85">编译安装系统包</a>子章节, 并<a href="#%E5%BA%94%E7%94%A8%E9%80%82%E5%BD%93%E7%9A%84-patch">选择适当的 patch</a>.</li></ul><h4 id="应用适当的-patch"><a href="#应用适当的-patch" class="headerlink" title="应用适当的 patch"></a>应用适当的 patch</h4><p>Arch Linux 官方提供的系统包或从这些包中分支出的 AUR 包可以自动应用 patch. 读者需要做的是将所需的 patch 放置在 PKGBUILD 文件 (会在<a href="#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%8C%85">后文</a>提及) 的父目录中, 然后修改 PKGBUILD 文件的内容, 将 patch 的路径添加到其中的 <code>source</code> 变量中. 理论上仍然需要在 <code>sha256sums</code> 变量中添加对应 patch 的 SHA256, 但可以使用 <code>&#39;SKIP&#39;</code> 跳过校验.</p><p>例如, 若需要应用 <code>kernel/cs35l42-hda-no-acpi-dsd-csc3551.patch</code> 这个 patch, 则只需要直接将该 patch 下载到对应的文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/package <span class="comment"># 提前切换当前文件夹</span></span><br><span class="line">wget https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/patches/kernel/cs35l42-hda-no-acpi-dsd-csc3551.patch <span class="comment"># 下载 patch</span></span><br><span class="line">vim PKGBUILD</span><br></pre></td></tr></table></figure><p>然后作出类似如下的修改, 将</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>=(</span><br><span class="line">  <span class="string">&quot;<span class="variable">$_srcname</span>::git+https://github.com/archlinux/linux?signed#tag=<span class="variable">$_srctag</span>&quot;</span></span><br><span class="line">  config         <span class="comment"># the main kernel config file</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>=(</span><br><span class="line">  <span class="string">&quot;<span class="variable">$_srcname</span>::git+https://github.com/archlinux/linux?signed#tag=<span class="variable">$_srctag</span>&quot;</span></span><br><span class="line">  config         <span class="comment"># the main kernel config file</span></span><br><span class="line">  kernel/cs35l42-hda-no-acpi-dsd-csc3551.patch</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后将</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sha256sums=(<span class="string">&#x27;SKIP&#x27;</span></span><br><span class="line">            <span class="string">&#x27;0571ea17a2e38458096b679418197bbea8c414388f628d122517f3a1f3a31b3a&#x27;</span>)</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sha256sums=(<span class="string">&#x27;SKIP&#x27;</span></span><br><span class="line">            <span class="string">&#x27;0571ea17a2e38458096b679418197bbea8c414388f628d122517f3a1f3a31b3a&#x27;</span></span><br><span class="line">            <span class="string">&#x27;SKIP&#x27;</span>)</span><br></pre></td></tr></table></figure><p>添加多个 patch 的方法类似.</p><h4 id="编译安装系统包"><a href="#编译安装系统包" class="headerlink" title="编译安装系统包"></a>编译安装系统包</h4><p>Arch Linux 官方 fork 了 Linux 社区的源码库, 并提供了编译, 打包, 安装的 “脚本” (交由 <code>pacman</code> 执行, 并不完全等同于 Shell 脚本). 本文以 linux 系统包为例.</p><p>与 AUR 包不同, Arch Linux 官方维护的包存储于 GitHub 的 <a href="https://github.com/archlinux/svntogit-packages">svntogit-packages</a> 仓库, 但所有的软件包的相关数据存储于各个分支中, 故直接克隆该仓库会产生大量的无用数据. 笔者选择直接 pull 需要的分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> linux &amp;&amp; <span class="built_in">cd</span> linux</span><br><span class="line">git init</span><br><span class="line">git remote add origin https://github.com/archlinux/svntogit-packages.git</span><br><span class="line">git pull origin packages/linux</span><br><span class="line">git branch -M packages/linux <span class="comment"># 可选</span></span><br><span class="line"><span class="built_in">cd</span> trunk</span><br></pre></td></tr></table></figure><p>该文件夹的结构与 AUR 包相同, 可以看到其中存在 PKGBUILD 文件. 此时可以根据 “<a href="#%E5%BA%94%E7%94%A8%E9%80%82%E5%BD%93%E7%9A%84-patch">应用适当的 patch</a>“ 章节的内容将 patch 的信息添加至 PKGBUILD 中. 随后, 在终端中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><p>编译, 打包并安装. 这会产生 linux, linux-docs, linux-headers 三个包.</p><h4 id="编译-CPIO-archive"><a href="#编译-CPIO-archive" class="headerlink" title="编译 CPIO archive"></a>编译 CPIO archive</h4><p>重启应用新的内核后, 则需要应用 <code>dsdt/spkr-dsd.patch</code>. 对 DSDT 的介绍见<a href="https://wiki.archlinux.org/title/DSDT">此</a>. 大部分情况下, 读者只需要从 “<a href="https://wiki.archlinux.org/title/DSDT#Recompiling_it_yourself">Recompiling it yourself</a>“ 小节开始阅读.</p><p>首先需要安装 <a href="https://archlinux.org/packages/?name=acpica">acpica</a> 这个软件包. 然后在终端中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&quot;cat /sys/firmware/acpi/tables/DSDT &gt; dsdt.dat&quot;</span></span><br><span class="line">iasl -d dsdt.dat</span><br><span class="line">wget https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/patches/dsdt/spkr-dsd.patch</span><br><span class="line">patch -Np1 &lt; spkr-dsd.patch</span><br><span class="line">iasl -tc dsdt.dsl</span><br></pre></td></tr></table></figure><p>此时可以在当前目录找到 <code>dsdt.aml</code>. 再拉取 Linux 的源码, 切换当前目录到源码文件夹, 在终端中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p kernel/firmware/acpi</span><br><span class="line"><span class="built_in">cp</span> /path/to/dsdt.aml kernel/firmware/acpi <span class="comment"># 将 /path/to/dsdt.aml 更换为正确的路径</span></span><br><span class="line">find kernel | cpio -H newc --create &gt; acpi_override</span><br><span class="line">sudo <span class="built_in">cp</span> acpi_override /boot</span><br></pre></td></tr></table></figure><p><code>acpi_override</code> 是一个 CPIO archive 文件, 可以作为 initrd 被 boot loader 加载. 以 GRUB 为例, 修改 <code>/etc/default/grub</code> 文件, 在文件末尾添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load custom acpi_override</span></span><br><span class="line">GRUB_EARLY_INITRD_LINUX_CUSTOM=<span class="string">&quot;acpi_override&quot;</span></span><br></pre></td></tr></table></figure><p>此时这个 CPIO archive 则会在 initramfs 前加载. 使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>生成 grub 的配置文件. 可以检查该文件中是否已经写入 <code>acpi_override</code>, 例如:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initrd  /acpi_override /initramfs-linux.img</span><br></pre></td></tr></table></figure><p>重启设备, 该 patch 即被应用.</p><p><strong>[完]</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;笔者在 &lt;a href=&quot;https://www.asus.com/ca-en/laptops/for-home/zenbook/zenbook-s-13-oled-um5302-amd-ryzen-6000-series/&quot;&gt;ASUS Zenbook S 13 OLED (UM5302TA)&lt;/a&gt; 上安装 Arch Linux 时, 发现仅使用 Arch Linux 官方提供的 &lt;a href=&quot;https://archlinux.org/packages/core/x86_64/linux/&quot;&gt;linux&lt;/a&gt; 或 AUR 上的 &lt;a href=&quot;https://aur.archlinux.org/packages/linux-mainline&quot;&gt;linux-mainline&lt;/a&gt; 等系统 packages 无法修复一些影响使用体验的问题. 其中一些问题已经得到了有效的解决方法, 乃至被添加入 Linux 源码中; 一些问题的 patch 尚未被纳入 Linux 源码库; 还有一些问题仍无解决方案.&lt;/p&gt;
&lt;p&gt;修复这些问题的主要方式是在 Linux 内核源码中添加 patch, 或者是使用其他的方式 (例如修改 Bootloader 的行为) 来 “动态” 添加部分系统功能. 这些问题的大部分 patch 已经有了更为自动化的解决方案.&lt;/p&gt;
&lt;p&gt;值得注意的是, 本文提及的各种 patch 理论上可以应用于其他发行版.&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    <category term="Tutorial" scheme="https://blog.tamako.work/categories/Essay/Tutorial/"/>
    
    
    <category term="Arch Linux" scheme="https://blog.tamako.work/tags/Arch-Linux/"/>
    
    <category term="Kernel" scheme="https://blog.tamako.work/tags/Kernel/"/>
    
    <category term="ASUS" scheme="https://blog.tamako.work/tags/ASUS/"/>
    
    <category term="UM5302TA" scheme="https://blog.tamako.work/tags/UM5302TA/"/>
    
    <category term="DSDT" scheme="https://blog.tamako.work/tags/DSDT/"/>
    
    <category term="ACPI" scheme="https://blog.tamako.work/tags/ACPI/"/>
    
  </entry>
  
  <entry>
    <title>使用 GPG 加密、解密和验证信息</title>
    <link href="https://blog.tamako.work/techdev/gpg-encryption-decryption-validation/"/>
    <id>https://blog.tamako.work/techdev/gpg-encryption-decryption-validation/</id>
    <published>2022-12-09T14:37:42.000Z</published>
    <updated>2022-12-09T14:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将主要利用 <a href="https://en.wikipedia.org/wiki/GNU_Privacy_Guard">GNU Privacy Guard</a> (简称 “GnuPG” 或 “GPG”) 完成信息的加密, 解密和验证任务. 本文不会对 GPG 的工作原理以及 OpenPGP 的规范 (参见 <a href="https://datatracker.ietf.org/doc/html/rfc4880">RFC 4880</a>) 做过多的解读. 仅针对完成上述的任务而言, 只需要对其了解大体的情况即可.</p><span id="more"></span><h2 id="简要原理"><a href="#简要原理" class="headerlink" title="简要原理"></a>简要原理</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4d/PGP_diagram.svg" alt="How PGP encryption works visually"></p><p>以上截取自 <a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">Pretty Good Privacy</a> 维基词条的 SVG <a href="https://en.wikipedia.org/wiki/File:PGP_diagram.svg">图像</a> (可能需要切换为亮色模式以看清图中的文字). 其中的大部分工作将会由 GPG 完成. 读者需要注意的是从图中可以看到 “receiver’s public key” 和 “receiver’s private key” - 这暗示 OpenPGP 标准中存在 “公钥” 和 “私钥” 两个概念, 且这两种密钥都归属于同一个人. 加密时, 信息发送者需要信息接收者的公钥; 解密时, 信息接收者需要自己的私钥.</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>笔者将主要使用本机的 Arch Linux 进行测试和演示. 同时会利用一台远端的 Linux 服务器用以演示双方通信操作.</p><h3 id="涉及软件包"><a href="#涉及软件包" class="headerlink" title="涉及软件包"></a>涉及软件包</h3><ul><li><code>core/gnupg</code> - 提供 <code>gpg</code></li><li><code>core/coreutils</code> - 提供 <code>tr</code>, <code>head</code></li><li><code>core/openssh</code> - 提供 <code>ssh</code>, <code>scp</code></li></ul><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p>本文中涉及到本地机器的所有工作将在 <code>~/Temp/gpg</code> 文件夹下进行. 该文件夹下有需要传输的信息 <code>message.txt</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> message.txt</span>        </span><br><span class="line">CjYIdc[&quot;Ns`3[BA\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A&#x27;R_h!9SU2v$oJ2SIKGp&quot;l</span><br></pre></td></tr></table></figure><h3 id="信息收发双方"><a href="#信息收发双方" class="headerlink" title="信息收发双方"></a>信息收发双方</h3><table><thead><tr><th align="center">角色</th><th align="center">用户名</th><th align="center">邮箱</th></tr></thead><tbody><tr><td align="center">发送者</td><td align="center"><code>test1</code></td><td align="center"><code>test1@foo.bar</code></td></tr><tr><td align="center">接收者</td><td align="center"><code>test2</code></td><td align="center"><code>test2@foo.bar</code></td></tr></tbody></table><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="安装-GPG"><a href="#安装-GPG" class="headerlink" title="安装 GPG"></a>安装 GPG</h3><p>Linux 环境无需多言. 对于 Windows 可以选择 <a href="https://www.gpg4win.org/">Gpg4win</a> - 这是一个 GPG 在 Windows 上的实现.</p><h3 id="生成强密码"><a href="#生成强密码" class="headerlink" title="生成强密码"></a>生成强密码</h3><p>后续的操作中可能会涉及到生成强密码的需求. 自然, 一个可以在脑中记住的强密码是最好不过的, 不过这里将演示一个利用 <code>/dev/urandom</code> 生成高强度密码的方法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tr</span> -dc <span class="string">&quot;[:graph:]&quot;</span> &lt; /dev/urandom | <span class="built_in">head</span> -c 64; <span class="built_in">echo</span> <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">Q-SU0QZA:&#123;6h%LLoR@Bd2M#jPOb.nu8&amp;xcimt&#125;atyo|G]O&#123;Ay&gt;+R;T&#x27;gGrUH)bWk</span><br></pre></td></tr></table></figure><p>其主要原理是, <code>tr</code> 可以 “translate or delete characters”<a href="https://man7.org/linux/man-pages/man1/tr.1.html">^1</a>. <code>tr</code> 从 <code>/dev/urandom</code> 设备文件中获取到随机字符流后, 可以仅保留符合 <code>[:graph:]</code> 条件 (“all printable characters, not including space”<a href="https://man7.org/linux/man-pages/man1/tr.1.html">^1</a>) 的字符, 再让 <code>head</code> 截取其中的前 64 个字符即可. 由此得到的则是长度为 64 的随机可见字符串.</p><p>同理, 若要生成 32 位仅包含小写字母和数字的字符串:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tr</span> -dc <span class="string">&quot;a-z0-9&quot;</span> &lt; /dev/urandom | <span class="built_in">head</span> -c 32; <span class="built_in">echo</span> <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">b2ylyqcs9x5gureu43b3ycw9txgww5sb</span><br></pre></td></tr></table></figure><h3 id="生成低熵随机数"><a href="#生成低熵随机数" class="headerlink" title="生成低熵随机数"></a>生成低熵随机数</h3><p>一些无头服务器可能无法满足 “低熵” 的条件, 从而导致生成的随机数不满足一些安全性要求较高的程序 (例如本文提到的 GPG) 的需求. Linux 上可以借助 <a href="https://wiki.archlinux.org/title/Haveged"><code>haveged</code></a>, <a href="https://wiki.archlinux.org/title/rng-tools"><code>rng-tools</code></a> 等来避免这种情况. 本文不再赘述.</p><h2 id="密钥操作"><a href="#密钥操作" class="headerlink" title="密钥操作"></a>密钥操作</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>使用 <code>gpg --full-generate-key</code> 来生成一个密钥对. 以下的代码块记录了终端中回显的整个过程.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --full-generate-key</span>      </span><br><span class="line">gpg (GnuPG) 2.2.40; Copyright (C) 2022 g10 Code GmbH</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Please select what kind of key you want:</span><br><span class="line">   (1) RSA and RSA (default)</span><br><span class="line">   (2) DSA and Elgamal</span><br><span class="line">   (3) DSA (sign only)</span><br><span class="line">   (4) RSA (sign only)</span><br><span class="line">  (14) Existing key from card</span><br><span class="line">Your selection? 1</span><br><span class="line">RSA keys may be between 1024 and 4096 bits long.</span><br><span class="line">What keysize do you want? (3072) 4096</span><br><span class="line">Requested keysize is 4096 bits</span><br><span class="line">Please specify how long the key should be valid.</span><br><span class="line">         0 = key does not expire</span><br><span class="line">      &lt;n&gt;  = key expires in n days</span><br><span class="line">      &lt;n&gt;w = key expires in n weeks</span><br><span class="line">      &lt;n&gt;m = key expires in n months</span><br><span class="line">      &lt;n&gt;y = key expires in n years</span><br><span class="line">Key is valid for? (0) 0</span><br><span class="line">Key does not expire at all</span><br><span class="line">Is this correct? (y/N) y</span><br><span class="line"></span><br><span class="line">GnuPG needs to construct a user ID to identify your key.</span><br><span class="line"></span><br><span class="line">Real name: test1</span><br><span class="line">Email address: test1@foo.bar</span><br><span class="line">Comment: test1&#x27;s PGP key</span><br><span class="line">You selected this USER-ID:</span><br><span class="line">    &quot;test1 (test1&#x27;s PGP key) &lt;test1@foo.bar&gt;&quot;</span><br><span class="line"></span><br><span class="line">Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o</span><br><span class="line">We need to generate a lot of random bytes. It is a good idea to perform</span><br><span class="line">some other action (type on the keyboard, move the mouse, utilize the</span><br><span class="line">disks) during the prime generation; this gives the random number</span><br><span class="line">generator a better chance to gain enough entropy.</span><br><span class="line">We need to generate a lot of random bytes. It is a good idea to perform</span><br><span class="line">some other action (type on the keyboard, move the mouse, utilize the</span><br><span class="line">disks) during the prime generation; this gives the random number</span><br><span class="line">generator a better chance to gain enough entropy.</span><br><span class="line">gpg: revocation certificate stored as &#x27;/home/littleye233/.gnupg/openpgp-revocs.d/EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198.rev&#x27;</span><br><span class="line">public and secret key created and signed.</span><br><span class="line"></span><br><span class="line">pub   rsa4096 2022-12-09 [SC]</span><br><span class="line">      EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198</span><br><span class="line">uid                      test1 (test1&#x27;s PGP key) &lt;test1@foo.bar&gt;</span><br><span class="line">sub   rsa4096 2022-12-09 [E]</span><br></pre></td></tr></table></figure><p>其中需要用户回答如下几个问题:</p><ul><li>密钥的种类 - <code>RSA and RSA</code></li><li>RSA 密钥的长度 - <code>4096</code></li><li>密钥的有效期 - <code>key does not expire</code></li><li>确认信息正确性 - <code>y</code></li><li>真实姓名 - <code>test1</code></li><li>电子邮件地址 - <code>test1@foo.bar</code></li><li>注释 - <code>test1&#39;s PGP key</code></li><li>确认信息正确性 - <code>o</code></li><li><strong>(未回显)</strong> <strong>(可选)</strong> 密码片语 (passphrase)</li></ul><p>若设置密码片语, 在解密时则需要输入该字符串.</p><h3 id="查看密钥"><a href="#查看密钥" class="headerlink" title="查看密钥"></a>查看密钥</h3><p>查看本机中导入或生成的密钥有多种形式.</p><h4 id="列出私钥和指纹"><a href="#列出私钥和指纹" class="headerlink" title="列出私钥和指纹"></a>列出私钥和指纹</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --list-secret-keys --keyid-format=long --with-fingerprint</span></span><br><span class="line">gpg: checking the trustdb</span><br><span class="line">gpg: marginals needed: 3  completes needed: 1  trust model: pgp</span><br><span class="line">gpg: depth: 0  valid:  11  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 11u</span><br><span class="line">/home/littleye233/.gnupg/pubring.kbx</span><br><span class="line">------------------------------------</span><br><span class="line">... 省略多个私钥 ...</span><br><span class="line"></span><br><span class="line">sec   rsa4096/46D85BAE755DB198 2022-12-09 [SC]</span><br><span class="line">      Key fingerprint = EB28 C6D4 2ACF C179 8DC7  D1CB 46D8 5BAE 755D B198</span><br><span class="line">uid                 [ultimate] test1 (test1&#x27;s PGP key) &lt;test1@foo.bar&gt;</span><br><span class="line">ssb   rsa4096/EEAD650E9DE15AB8 2022-12-09 [E]</span><br></pre></td></tr></table></figure><h4 id="列出公钥和指纹"><a href="#列出公钥和指纹" class="headerlink" title="列出公钥和指纹"></a>列出公钥和指纹</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --list-keys --keyid-format=long --with-fingerprint</span> </span><br><span class="line">/home/littleye233/.gnupg/pubring.kbx</span><br><span class="line">------------------------------------</span><br><span class="line">... 省略多个公钥 ...</span><br><span class="line"></span><br><span class="line">pub   rsa4096/46D85BAE755DB198 2022-12-09 [SC]</span><br><span class="line">      Key fingerprint = EB28 C6D4 2ACF C179 8DC7  D1CB 46D8 5BAE 755D B198</span><br><span class="line">uid                 [ultimate] test1 (test1&#x27;s PGP key) &lt;test1@foo.bar&gt;</span><br><span class="line">sub   rsa4096/EEAD650E9DE15AB8 2022-12-09 [E]</span><br></pre></td></tr></table></figure><p>如果仅仅需要获取公钥指纹 (Key fingerprint) 等信息, 这个指令和上一条指令呈现的结果几乎类似. 但前者同时可以列出导入的公钥 - 这对于加密和验证信息的工作很有用.</p><h4 id="导出公钥"><a href="#导出公钥" class="headerlink" title="导出公钥"></a>导出公钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --<span class="built_in">export</span> --armor 46D85BAE755DB198</span></span><br><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line">... 省略具体内容 ...</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure><p><code>--armor</code> 选项在 GPG 的<a href="https://linux.die.net/man/1/gpg">帮助文档</a>中有如下说明:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--armor</span><br><span class="line">-a     Create ASCII armored output.  The default is to create the binary OpenPGP format.</span><br></pre></td></tr></table></figure><p>这种输出形式便于在不同机器之间传输密钥<a href="https://gist.github.com/LittleYe233/ee3f54c21ae8f4fd6da7b4c06b50e7c6">^2</a>. 同时这也是一种很好的分享公钥的方式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output test1_at_foo_dot_bar.asc --export --armor 46D85BAE755DB198</span><br></pre></td></tr></table></figure><p>值得注意的是, 这里确定密钥使用的是密钥 ID - <code>46D85BAE755DB198</code>. 事实上, 换用真实姓名和电子邮箱也是可以用来确定密钥的. 这里可以看出, 如果对同一个真实姓名或电子邮箱生成了多个密钥, GPG 在搜索密钥时, 默认会从列表中的第一个符合条件的密钥开始. 这在一些场合下 (例如需要输入密码片语的情景, 此时为了跳过某个密钥可能需要反复关闭输入密码片语的窗口) 可能会比较烦人. 因此, 若确实有需要多个 PGP 密钥的场合, 请最好避免使用相同的真实姓名和电子邮箱.</p><h4 id="导出私钥"><a href="#导出私钥" class="headerlink" title="导出私钥"></a>导出私钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --export-secret-key 46D85BAE755DB198</span></span><br><span class="line">-----BEGIN PGP PRIVATE KEY BLOCK-----</span><br><span class="line">... 省略具体内容 ...</span><br><span class="line">-----END PGP PRIVATE KEY BLOCK-----</span><br></pre></td></tr></table></figure><h3 id="导入密钥"><a href="#导入密钥" class="headerlink" title="导入密钥"></a>导入密钥</h3><p>假设 test2 用户发送来了 Ta 的 PGP 公钥 (<code>test2_at_foo_dot_bar.asc</code>), 则此时可以使用 <code>gpg --import</code> 导入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --import test2_at_foo_dot_bar.asc</span><br></pre></td></tr></table></figure><p>对于远端机器, 则可以使用管道 (pipe)<a href="https://gist.github.com/LittleYe233/ee3f54c21ae8f4fd6da7b4c06b50e7c6">^2</a>:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sec   rsa4096/11B3A67EC13C2571 2022-12-09 [SC]</span><br><span class="line">      Key fingerprint = 5359 F3FA 8933 9C43 DB47  61A8 11B3 A67E C13C 2571</span><br><span class="line">uid                 [ultimate] test2 (test2&#x27;s PGP key) &lt;test2@foo.bar&gt;</span><br><span class="line">ssb   rsa4096/9C0A6E908BC7D25D 2022-12-09 [E]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh root@54.255.5.62 gpg --<span class="built_in">export</span> --armor 11B3A67EC13C2571 | gpg --import</span></span><br><span class="line">gpg: key 11B3A67EC13C2571: public key &quot;test2 (test2&#x27;s PGP key) &lt;test2@foo.bar&gt;&quot; imported</span><br><span class="line">gpg: Total number processed: 1</span><br><span class="line">gpg:               imported: 1</span><br></pre></td></tr></table></figure><h3 id="移除密钥"><a href="#移除密钥" class="headerlink" title="移除密钥"></a>移除密钥</h3><p>移除公钥需要 <code>--delete-keys</code> 选项:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --delete-keys test2@foo.bar</span><br></pre></td></tr></table></figure><p>移除私钥则需要 <code>--delete-secret-keys</code> 选项:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --delete-secret-keys test2@foo.bar</span><br></pre></td></tr></table></figure><h3 id="设置信任等级"><a href="#设置信任等级" class="headerlink" title="设置信任等级"></a>设置信任等级</h3><p>默认导入的密钥的信任等级是 “unknown”. 在后续解密和验证信息的时候, 则可能会出现如下的输出:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: WARNING: This key is not certified with a trusted signature!</span><br><span class="line">gpg:          There is no indication that the signature belongs to the owner.</span><br><span class="line">Primary key fingerprint: EB28 C6D4 2ACF C179 8DC7  D1CB 46D8 5BAE 755D B198</span><br></pre></td></tr></table></figure><p>此时则需要将信任等级更改为 “utimate” - 与本地生成的密钥的信任等级相同. 具体操作则是执行 <code>gpg --edit-key</code>. 例如, 在 test2 用户的远端服务器上更改 test1 用户的 PGP 密钥的信任等级时:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --edit-key test1@foo.bar</span></span><br><span class="line">gpg (GnuPG) 2.2.27; Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pub  rsa4096/46D85BAE755DB198</span><br><span class="line">     created: 2022-12-09  expires: never       usage: SC  </span><br><span class="line">     trust: full          validity: unknown</span><br><span class="line">sub  rsa4096/EEAD650E9DE15AB8</span><br><span class="line">     created: 2022-12-09  expires: never       usage: E   </span><br><span class="line">[ unknown] (1). test1 (test1&#x27;s PGP key) &lt;test1@foo.bar&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">gpg&gt; </span><span class="language-bash">trust</span></span><br><span class="line">pub  rsa4096/46D85BAE755DB198</span><br><span class="line">     created: 2022-12-09  expires: never       usage: SC  </span><br><span class="line">     trust: full          validity: unknown</span><br><span class="line">sub  rsa4096/EEAD650E9DE15AB8</span><br><span class="line">     created: 2022-12-09  expires: never       usage: E   </span><br><span class="line">[ unknown] (1). test1 (test1&#x27;s PGP key) &lt;test1@foo.bar&gt;</span><br><span class="line"></span><br><span class="line">Please decide how far you trust this user to correctly verify other users&#x27; keys</span><br><span class="line">(by looking at passports, checking fingerprints from different sources, etc.)</span><br><span class="line"></span><br><span class="line">  1 = I don&#x27;t know or won&#x27;t say</span><br><span class="line">  2 = I do NOT trust</span><br><span class="line">  3 = I trust marginally</span><br><span class="line">  4 = I trust fully</span><br><span class="line">  5 = I trust ultimately</span><br><span class="line">  m = back to the main menu</span><br><span class="line"></span><br><span class="line">Your decision? 5</span><br><span class="line">Do you really want to set this key to ultimate trust? (y/N) y</span><br><span class="line"></span><br><span class="line">pub  rsa4096/46D85BAE755DB198</span><br><span class="line">     created: 2022-12-09  expires: never       usage: SC  </span><br><span class="line">     trust: ultimate      validity: unknown</span><br><span class="line">sub  rsa4096/EEAD650E9DE15AB8</span><br><span class="line">     created: 2022-12-09  expires: never       usage: E   </span><br><span class="line">[ unknown] (1). test1 (test1&#x27;s PGP key) &lt;test1@foo.bar&gt;</span><br><span class="line">Please note that the shown key validity is not necessarily correct</span><br><span class="line">unless you restart the program.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">gpg&gt; </span><span class="language-bash">q</span></span><br></pre></td></tr></table></figure><h2 id="信息加密"><a href="#信息加密" class="headerlink" title="信息加密"></a>信息加密</h2><p>正如前文所述, 信息的加密需要信息接收者的公钥. 而刚刚笔者已经导入了 test2 用户的公钥. 现在则需要 <code>--encrypt</code> 选项来进行加密:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --encrypt --armor --recipient test2@foo.bar message.txt</span><br></pre></td></tr></table></figure><p><code>--armor</code> 的作用略去不提. <code>--recipient</code> 用以指定信息接收方 (这样其就可以使用自己的私钥解密), 可以指定多个 (诸如 <code>--recipient email1 --recipient email2</code> 的格式). 命令执行成功后, 当前目录会生成一个扩展名为 <code>.asc</code> 的文件 (<code>message.txt.asc</code>). 使用 <code>file</code> 查看其文件信息, 得到:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file message.txt.asc</span> </span><br><span class="line">message.txt.asc: PGP message Public-Key Encrypted Session Key (old)</span><br></pre></td></tr></table></figure><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p><code>--sign</code> 可以表明信息的发送者是谁. 默认签名使用 “默认密钥” (若未明确设置, 则是密钥列表的第一个密钥). 若要显式指定一个密钥, 则需要使用 <code>--local-user</code> 选项. 另外换用 <code>--default-key</code> 选项可以同时设置 “默认密钥”.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --encrypt --armor --sign --local-user test1@foo.bar --recipient test2@foo.bar message.txt</span><br></pre></td></tr></table></figure><p>当然, 签名操作需要验证签名方的密码片语, 如果有的话.</p><h2 id="信息解密"><a href="#信息解密" class="headerlink" title="信息解密"></a>信息解密</h2><p>解密时, 则需要使用 <code>--decrypt</code> 选项:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --decrypt message.txt.asc</span><br></pre></td></tr></table></figure><p>与加密操作不同的是, 解密时, GPG 会尝试所有的密钥, 无需自行指定密钥.</p><p>对于未签名的加密信息, 可能的输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --decrypt message.txt.asc</span>                                   </span><br><span class="line">CjYIdc[&quot;Ns`3[BA\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A&#x27;R_h!9SU2v$oJ2SIKGp&quot;l</span><br><span class="line">gpg: encrypted with RSA key, ID EEAD650E9DE15AB8</span><br><span class="line">gpg: encrypted with 4096-bit RSA key, ID 9C0A6E908BC7D25D, created 2022-12-09</span><br><span class="line">      &quot;test2 (test2&#x27;s PGP key) &lt;test2@foo.bar&gt;&quot;</span><br></pre></td></tr></table></figure><p>对于已签名的加密信息, 在信息发送者的公钥未导入时, 此时无法检查签名, 可能的输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --decrypt message.txt.asc</span></span><br><span class="line">CjYIdc[&quot;Ns`3[BA\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A&#x27;R_h!9SU2v$oJ2SIKGp&quot;l</span><br><span class="line">gpg: encrypted with 4096-bit RSA key, ID 9C0A6E908BC7D25D, created 2022-12-09</span><br><span class="line">      &quot;test2 (test2&#x27;s PGP key) &lt;test2@foo.bar&gt;&quot;</span><br><span class="line">gpg: Signature made Fri 09 Dec 2022 04:25:43 PM UTC</span><br><span class="line">gpg:                using RSA key EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198</span><br><span class="line">gpg:                issuer &quot;test1@foo.bar&quot;</span><br><span class="line">gpg: Can&#x27;t check signature: No public key</span><br></pre></td></tr></table></figure><p><a href="#%E5%AF%BC%E5%85%A5%E5%AF%86%E9%92%A5">导入</a>并<a href="#%E8%AE%BE%E7%BD%AE%E4%BF%A1%E4%BB%BB%E7%AD%89%E7%BA%A7">设置信任等级</a>后, 可能的输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --decrypt message.txt.asc</span>                    </span><br><span class="line">CjYIdc[&quot;Ns`3[BA\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A&#x27;R_h!9SU2v$oJ2SIKGp&quot;l</span><br><span class="line">gpg: encrypted with 4096-bit RSA key, ID 9C0A6E908BC7D25D, created 2022-12-09</span><br><span class="line">      &quot;test2 (test2&#x27;s PGP key) &lt;test2@foo.bar&gt;&quot;</span><br><span class="line">CjYIdc[&quot;Ns`3[BA\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A&#x27;R_h!9SU2v$oJ2SIKGp&quot;l</span><br><span class="line">gpg: Signature made Fri 09 Dec 2022 04:25:43 PM UTC</span><br><span class="line">gpg:                using RSA key EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198</span><br><span class="line">gpg:                issuer &quot;test1@foo.bar&quot;</span><br><span class="line">gpg: checking the trustdb</span><br><span class="line">gpg: marginals needed: 3  completes needed: 1  trust model: pgp</span><br><span class="line">gpg: depth: 0  valid:   4  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 4u</span><br><span class="line">gpg: Good signature from &quot;test1 (test1&#x27;s PGP key) &lt;test1@foo.bar&gt;&quot; [ultimate]</span><br></pre></td></tr></table></figure><h2 id="信息验证"><a href="#信息验证" class="headerlink" title="信息验证"></a>信息验证</h2><h3 id="分离密钥"><a href="#分离密钥" class="headerlink" title="分离密钥"></a>分离密钥</h3><p>之前生成的加密文件 <code>message.txt.asc</code> 包含了原始文件的信息. 如下的命令使用了 <code>--detach-sign</code> 选项, 则是生成一个分离式 (detached) 的密钥. 这可以用来在无需加密的场合验证身份:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --local-user 46D85BAE755DB198 --output message.txt.asc --detach-sign --armor message.txt</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --verify message.txt.asc message.txt</span></span><br><span class="line">gpg: Signature made Sat 10 Dec 2022 12:46:26 AM CST</span><br><span class="line">gpg:                using RSA key EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198</span><br><span class="line">gpg: Good signature from &quot;test1 (test1&#x27;s PGP key) &lt;test1@foo.bar&gt;&quot; [ultimate]</span><br></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将主要利用 &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Privacy_Guard&quot;&gt;GNU Privacy Guard&lt;/a&gt; (简称 “GnuPG” 或 “GPG”) 完成信息的加密, 解密和验证任务. 本文不会对 GPG 的工作原理以及 OpenPGP 的规范 (参见 &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc4880&quot;&gt;RFC 4880&lt;/a&gt;) 做过多的解读. 仅针对完成上述的任务而言, 只需要对其了解大体的情况即可.&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    <category term="Tutorial" scheme="https://blog.tamako.work/categories/Essay/Tutorial/"/>
    
    
    <category term="Information Security" scheme="https://blog.tamako.work/tags/Information-Security/"/>
    
    <category term="GPG" scheme="https://blog.tamako.work/tags/GPG/"/>
    
    <category term="OpenPGP" scheme="https://blog.tamako.work/tags/OpenPGP/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 简要语法快速学习</title>
    <link href="https://blog.tamako.work/techdev/kotlin/quick-learning/"/>
    <id>https://blog.tamako.work/techdev/kotlin/quick-learning/</id>
    <published>2022-12-07T12:03:58.000Z</published>
    <updated>2022-12-07T12:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为一些机缘巧合, 笔者需要研究一下 Android 应用程序的二次开发, 作为目标的软件恰好是使用 Kotlin 编写的, 而笔者尚无该编程语言的基础, 因此需要快速掌握 Kotlin 的一些重要语法.</p><span id="more"></span><p>笔者对 Kotlin 语法糖多早有所耳闻. 考虑到官方文档 (或者说, 笔者本次参考的资料) 未必对所有的语法特性都能面面俱到, 笔者在这篇文章中, 可能只会涉及到部分语法糖.</p><p>需要注意的是, 本文只会聚焦于 Kotlin 的<strong>语法规则</strong>, 并辅以一些具体例子, 并不会在这里谈 Kotlin 是如何<strong>编译</strong>源代码的, Kotlin 是如何应用到 <strong>Android 开发</strong>的, 诸如此类.</p><p>借用 Arch Linux 软件仓库 <a href="https://archlinux.org/packages/community/any/kotlin/">community/kotlin</a> 包的描述: Statically typed programming language that can interoperate with Java. 可以预料的是, Kotlin 和 Java 的语法规则有一定相似之处, 但笔者同样没有 Java 基础, 因此对这两门语言都比较陌生的读者也不用担心笔者跳过二者相似的部分不谈.</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h3><p>笔者主要参考的教程即为 Kotlin 的<a href="https://kotlinlang.org/docs/home.html">官方文档</a>, 并从 <a href="https://kotlinlang.org/docs/basic-syntax.html">Basic syntax</a> 章节开始.</p><p>同时, Kotlin 为已有变成基础的学习者提供了 <a href="https://kotlinlang.org/docs/learning-materials-overview.html">Learning materials overview</a> 的页面, 其中的第一章节同样是 Basic syntax.</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>Kotlin <a href="https://kotlinlang.org/docs/getting-started.html#install-kotlin">官方文档</a>中建议使用 <a href="https://www.jetbrains.com/idea/download/">IntelliJ IDEA</a> 和 <a href="https://developer.android.com/studio">Android Studio</a> 来进行 Kotlin 开发, 但对于语法学习则不必要使用这些 IDE (更何况后者从名字上就像是针对 Android 开发的). 本次学习过程中, 笔者选择在 Arch Linux 中直接安装 community/kotlin 的包 (版本号为 1.7.22) 作为编译环境, <a href="https://archlinux.org/packages/extra/x86_64/jdk17-openjdk/">extra/jdk17-openjdk</a> 包 (版本号为 17.0.5.u1) 作为生成的 JAR 包的运行环境. 读者可以搭配装载 Kotlin 相关<a href="https://marketplace.visualstudio.com/items?itemName=fwcd.kotlin">插件</a>的 <a href="https://code.visualstudio.com/">Visual Studio Code</a> 用以编辑 Kotlin 源代码.</p><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>这里笔者略去 JVM 等细节, 仅说明命令行环境下如何编译单文件 Kotlin 源代码.</p><p>假设需要编译的源代码文件路径为 <code>/path/to/kotlin-learning/helloworld.kt</code>. 保证 Java 运行时环境和 Kotlin 编译器安装的情况下, 执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/kotlin-learning</span><br><span class="line">kotlinc helloworld.kt -include-runtime -d helloworld.jar</span><br><span class="line">java -jar helloworld.jar</span><br></pre></td></tr></table></figure><h2 id="包的声明与导入"><a href="#包的声明与导入" class="headerlink" title="包的声明与导入"></a>包的声明与导入</h2><p>熟悉 Java 语法的读者应该很习惯诸如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp;</span><br></pre></td></tr></table></figure><p>的代码. 在 Kotlin 中一般仍然需要编写类似的结构, 这是因为 Kotlin 同样依赖”包” (package) 的结构来组织代码. 显而易见的是点分隔符 <code>.</code> 规定了包之间的层级关系. 暂时可以简单理解为这声明了代码文件的”ID”. 不过需要注意的是, Kotlin 中的包声明不必要与实际的文件系统结构一致, 也就是说, 声明了 <code>com.example.myapp</code> 的代码文件的路径不必要是 <code>com/example/myapp.kt</code>.</p><p>声明包名之后, 就可以通过 <code>import</code> 语句导入其他包, 乃至其他 (诸如顶级函数和属性, 枚举类型常数等):</p><figure class="highlight kotlin"><figcaption><span>package_example.kt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ktlearning,package_example</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入包 `OneFile`</span></span><br><span class="line"><span class="keyword">import</span> ktlearning.one_package.OneFile</span><br><span class="line"><span class="comment">// 导入包 `another_package` 下的所有子包</span></span><br><span class="line"><span class="keyword">import</span> ktlearning.another_package.*</span><br><span class="line"><span class="comment">// 避免包名冲突</span></span><br><span class="line"><span class="keyword">import</span> ktlearning.another_another_package.OneFile <span class="keyword">as</span> AnotherFile</span><br><span class="line"><span class="comment">// 导入顶级函数 `TopLevelFunc`</span></span><br><span class="line"><span class="keyword">import</span> ktlearning.another_another_package.AnotherFile.TopLevelFunc</span><br></pre></td></tr></table></figure><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>Kotlin 需要主函数作为程序的入口. 主函数通常写作:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类似于 Java 中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 Kotlin 的代码中, 可以看出这个主函数 <code>main(args)</code> 接受一个 <code>String</code> 类型的数组 (<code>Array</code>). 当然在当前版本的 Kotlin 中, 主函数可以省去 <code>args</code> 这一参数. 函数体中未使用该参数反而会触发警告.</p><p>对于这个参数, 一个常见的操作是直接将其转化为字符串并输出:</p><figure class="highlight kotlin"><figcaption><span>example.kt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(args.contentToString())</span><br></pre></td></tr></table></figure><p>例如 <code>java -jar example.jar foo 1024 &quot;bar baz&quot;</code> 的输出将为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[foo, 1024, bar baz]</span><br></pre></td></tr></table></figure><p>有趣的是, 若将 <code>.contentToString()</code> 删去, Kotlin 依然可以编译, 但最终可能会输出诸如</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;@4f47d241</span><br></pre></td></tr></table></figure><p>的错误结果.</p><h2 id="输出到标准输出-standard-output"><a href="#输出到标准输出-standard-output" class="headerlink" title="输出到标准输出 (standard output)"></a>输出到标准输出 (standard output)</h2><figure class="highlight kotlin"><figcaption><span>helloworld.kt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ktlearning.helloworld</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot; more &quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;hello world!\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello world!</span><br><span class="line">1 more hello world!</span><br></pre></td></tr></table></figure><p>Kotlin 支持 <code>print(message)</code> 和 <code>println(message)</code> 两种输出到标准输出的方式. 需要注意的是这两个函数只接受<strong>单一</strong>变量参数.</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>“属性” (property) 这个概念被归类于 Classes and objects 这一章节中. 这个术语可能更常在面向对象编程中提及. 当然, 本文之前涉及到的完整的可编译代码似乎并没有显式地涉及到面向对象 (例如, 没有出现 <code>class</code> 这一关键字), 不过 Kotlin 中依然将诸如其他编程语言中很早提及的 “不可变变量” (immutable variable) 和 “可变变量” (mutable variable) 都视为一种 “属性” - 这表明它们可以具有传统的 “变量” 所缺失的特性.</p><p>Kotlin 中同样有 “编译时常量” (compile-time constant) 的概念. 根据<a href="https://kotlinlang.org/docs/properties.html#compile-time-constants">官方文档</a>相关的表述, 这类属性若在编译时值已知, Kotlin 编译器则可以在编译期间将对其的引用替换为实际的值.</p><p>试图定义传统意义上的 “变量” 和 “常量” 时:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义不可变变量</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 定义可变变量</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="comment">// 定义编译时常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> PI = <span class="number">3.14159</span></span><br></pre></td></tr></table></figure><h3 id="getters-和-setters"><a href="#getters-和-setters" class="headerlink" title="getters 和 setters"></a>getters 和 setters</h3><p>如果可以提前涉及到一些面向对象的内容的话, 既然这些概念都可以被抽象为 “属性”, 那面向对象中 getter 和 setter 的存在就不可被略过了. Kotlin 中对可变属性的完整定义语法如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure><p>不可变属性的则如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    <span class="comment">// 不允许定义 setter</span></span><br></pre></td></tr></table></figure><p>一些简单的定义示例如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动推断为 `Int` 类型, 具有默认的 getter 和 setter</span></span><br><span class="line"><span class="keyword">var</span> initialized = <span class="number">1</span></span><br><span class="line"><span class="comment">// 为 `Int` 类型不可变属性设置自定义 getter</span></span><br><span class="line"><span class="keyword">val</span> area: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.width * <span class="keyword">this</span>.height</span><br><span class="line"><span class="comment">// 同时根据 getter 自动推断</span></span><br><span class="line"><span class="keyword">val</span> area2 <span class="keyword">get</span>() = <span class="keyword">this</span>.width * <span class="keyword">this</span>.height</span><br></pre></td></tr></table></figure><h3 id="backing-fields"><a href="#backing-fields" class="headerlink" title="backing fields"></a>backing fields</h3><p>若涉及到在属性的 setter 中为属性本身赋值时, 为避免出现无限递归的情形, Kotlin 引入了一个 “内部属性” <code>field</code> 用以 “临时” 存储属性值:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果将上述代码块中的 <code>field = value</code> 改为 <code>counter = value</code>, 编译器则会抛出堆栈溢出的错误.</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Kotlin 中任何事物皆是对象. 这里仅讨论一些基本的数据类型.</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table><thead><tr><th align="center">类型</th><th align="center">字节数</th></tr></thead><tbody><tr><td align="center"><code>Byte</code></td><td align="center">1</td></tr><tr><td align="center"><code>Short</code></td><td align="center">2</td></tr><tr><td align="center"><code>Int</code></td><td align="center">4</td></tr><tr><td align="center"><code>Long</code></td><td align="center">8</td></tr></tbody></table><p>与一些编程语言相同, 在类型自动推断中, 可以在数字末尾添加 <code>L</code> (例如 <code>1L</code>) 来声明其类型为 <code>Long</code> 而不是默认的 <code>Int</code>.</p><p>参见 <a href="https://kotlinlang.org/docs/numbers.html#integer-types">Integer types</a>.</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th align="center">类型</th><th align="center">字节数</th><th align="center">significant bits</th><th align="center">exponent bits</th><th align="center">decimal digits</th></tr></thead><tbody><tr><td align="center"><code>Float</code></td><td align="center">4</td><td align="center">24</td><td align="center">8</td><td align="center">6-7</td></tr><tr><td align="center"><code>Double</code></td><td align="center">8</td><td align="center">53</td><td align="center">11</td><td align="center">15-16</td></tr></tbody></table><p>同样, 在数字末尾添加 <code>f</code> 或 <code>F</code> (例如 <code>3.14f</code>) 来声明其类型为 <code>Float</code> 而不是默认的 <code>Double</code>.</p><p>需要注意的是, 浮点型和整型之间不会<strong>自动转换</strong>. 例如如下的代码会抛出编译错误:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Double</span>, b: <span class="type">Double</span>)</span></span> = a + b</span><br><span class="line"><span class="comment">// `1` 不是 `Double` 类型</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>参见 <a href="https://kotlinlang.org/docs/numbers.html#floating-point-types">Floating-point types</a>.</p><h3 id="无符号整型"><a href="#无符号整型" class="headerlink" title="无符号整型"></a>无符号整型</h3><p>只需要在原有的数据类型前添加 <code>U</code> (例如 <code>UByte</code>) 即可.</p><p>同样, 在数字末尾添加 <code>u</code> (例如 <code>1u</code>) 来声明其类型为无符号类型. 类似的, <code>ul</code> 或 <code>UL</code> 声明其类型为 <code>ULong</code>.</p><h3 id="特殊的数字表示"><a href="#特殊的数字表示" class="headerlink" title="特殊的数字表示"></a>特殊的数字表示</h3><p>除了上文提及的 <code>f</code> / <code>F</code> 和 <code>L</code>, Kotlin 还支持其他特别的数字表示方法:</p><table><thead><tr><th align="center">特殊表示</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">二进制整型</td><td align="center"><code>0b00001111</code></td></tr><tr><td align="center">八进制整型</td><td align="center"><strong>不支持</strong></td></tr><tr><td align="center">十六进制整型</td><td align="center"><code>0x0F</code></td></tr><tr><td align="center">科学计数法</td><td align="center"><code>1.0e24</code></td></tr></tbody></table><p>同时, Kotlin 支持在数字之间增加下划线 (<code>_</code>) 来增加可读性:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234_5678_9012_3456L</span></span><br><span class="line"><span class="keyword">val</span> socialSecurityNumber = <span class="number">999_99_9999L</span></span><br><span class="line"><span class="keyword">val</span> hexBytes = <span class="number">0xFF_EC_DE_5E</span></span><br><span class="line"><span class="keyword">val</span> bytes = <span class="number">0b11010010_01101001_10010100_10010010</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>上文中已经出现了主函数的定义和使用方法. 对于一个通常的函数, 例如实现两个整数的加法:</p><figure class="highlight kotlin"><figcaption><span>func_sum.kt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ktlearning.func_sum</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常的函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum1</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接定义其返回值的函数定义, 同时实现了类型推断</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum2</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义无返回值的函数 (`Unit` 可以省略)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Sum of <span class="variable">$a</span> and <span class="variable">$b</span> is <span class="subst">$&#123;a + b&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Sum of <span class="variable">$a</span> and <span class="variable">$b</span> is <span class="subst">$&#123;sum1(a, b)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Sum of <span class="variable">$a</span> and <span class="variable">$b</span> is <span class="subst">$&#123;sum2(a, b)&#125;</span>&quot;</span>)</span><br><span class="line">    printSum(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>直接用例子说明:</p><figure class="highlight kotlin"><figcaption><span>oop_shape.kt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ktlearning.oop_shape</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可继承的类前加 `open`</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Shape</span>(name: String) &#123;</span><br><span class="line">    <span class="comment">// the primary constructor</span></span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;My name is <span class="subst">$&#123;this.name&#125;</span>!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> area: <span class="built_in">Double</span> = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>(name: String, width: <span class="built_in">Double</span>, height: <span class="built_in">Double</span>) : Shape(name) &#123;</span><br><span class="line">    <span class="keyword">var</span> width = width</span><br><span class="line">    <span class="keyword">var</span> height = height</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载父类的属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> area: <span class="built_in">Double</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">this</span>.width * <span class="keyword">this</span>.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(name: String, radius: <span class="built_in">Double</span>) : Shape(name) &#123;</span><br><span class="line">    <span class="keyword">val</span> PI = <span class="number">3.1415926</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> radius = radius</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> area: <span class="built_in">Double</span></span><br><span class="line">        <span class="keyword">get</span>() = PI * <span class="keyword">this</span>.radius * <span class="keyword">this</span>.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> rect = Rectangle(<span class="string">&quot;My Rectangle&quot;</span>, <span class="number">2.0</span>, <span class="number">3.5</span>)</span><br><span class="line">    <span class="keyword">val</span> circ = Circle(<span class="string">&quot;My Circle&quot;</span>, <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">    rect.say()</span><br><span class="line">    circ.say()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;The area of <span class="subst">$&#123;rect.name&#125;</span> is <span class="subst">$&#123;rect.area&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;The area of <span class="subst">$&#123;circ.name&#125;</span> is <span class="subst">$&#123;circ.area&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">My name is My Rectangle!</span><br><span class="line">My name is My Circle!</span><br><span class="line">The area of My Rectangle is 7.0</span><br><span class="line">The area of My Circle is 12.5663704</span><br></pre></td></tr></table></figure><p>参见 <a href="https://kotlinlang.org/docs/basic-syntax.html#creating-classes-and-instances">Creating classes and instances</a>.</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    块注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    下面是内层块注释.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    <span class="comment">/* 内层块注释 */</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    上面是内层块注释</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h2><h3 id="if-语句块"><a href="#if-语句块" class="headerlink" title="if 语句块"></a><code>if</code> 语句块</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    println(a)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>相对的, C 中为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 中为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p><del>(个人认为 Python 的条件表达式的结构经常写错, 因为条件被插入在两个分支表达式之间.)</del></p><h3 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h3><p>Kotlin 中的 <code>when</code> 类似于 C 中的 <code>switch</code>, 但其用法更加灵活:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="comment">// 左侧可以是一个表达式, 用以匹配</span></span><br><span class="line">    <span class="number">1</span> -&gt; println(<span class="string">&quot;x == 1&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; println(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">    <span class="comment">// 不匹配上述所有表达式</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;x is neither 1 nor 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `when` 也可以作为表达式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">describe</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: String =</span><br><span class="line">    <span class="keyword">when</span> (obj) &#123;</span><br><span class="line">        <span class="number">1</span>          -&gt; <span class="string">&quot;One&quot;</span></span><br><span class="line">        <span class="string">&quot;Hello&quot;</span>    -&gt; <span class="string">&quot;Greeting&quot;</span></span><br><span class="line">        <span class="comment">// 可以包含条件表达式</span></span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Long</span>    -&gt; <span class="string">&quot;Long&quot;</span></span><br><span class="line">        !<span class="keyword">is</span> String -&gt; <span class="string">&quot;Not a string&quot;</span></span><br><span class="line">        <span class="keyword">else</span>       -&gt; <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPositive</span><span class="params">(x: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="comment">// 当覆盖所有可能性时, 无需 `else` 分支</span></span><br><span class="line">    x &gt; <span class="number">0</span> -&gt; <span class="literal">true</span></span><br><span class="line">    x &lt;= <span class="number">0</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">6</span> downTo <span class="number">0</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (elem <span class="keyword">in</span> array) &#123;</span><br><span class="line">    println(elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">    println(array[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i, elem) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">&quot;array[<span class="variable">$i</span>] = <span class="variable">$elem</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> y = retrieveData()</span><br><span class="line">&#125; <span class="keyword">while</span> (y != <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h2 id="可空值-nullable-values-和空值检查-null-checks"><a href="#可空值-nullable-values-和空值检查-null-checks" class="headerlink" title="可空值 (nullable values) 和空值检查 (null checks)"></a>可空值 (nullable values) 和空值检查 (null checks)</h2><p>可空类型需要在类型后添加 <code>?</code> 标识. <code>null</code> 则表示空值.</p><figure class="highlight kotlin"><figcaption><span>null_check.kt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若字符串不能表示一个整型, 则转化为 `null`</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> str.toIntOrNull()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printProduct</span><span class="params">(arg1: <span class="type">String</span>, arg2: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = parseInt(arg1)</span><br><span class="line">    <span class="keyword">val</span> y = parseInt(arg2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能直接使用 `x * y`, 因为 `x` 和 `y` 可能为 `null`</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; y != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 空值检查后, 其类型自动转化为非空的整型</span></span><br><span class="line">        println(x * y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;&#x27;<span class="variable">$arg1</span>&#x27; or &#x27;<span class="variable">$arg2</span>&#x27; is not a number&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printProduct(<span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">    printProduct(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">    printProduct(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">42</span><br><span class="line">&#x27;a&#x27; or &#x27;7&#x27; is not a number</span><br><span class="line">&#x27;a&#x27; or &#x27;b&#x27; is not a number</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为一些机缘巧合, 笔者需要研究一下 Android 应用程序的二次开发, 作为目标的软件恰好是使用 Kotlin 编写的, 而笔者尚无该编程语言的基础, 因此需要快速掌握 Kotlin 的一些重要语法.&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    <category term="Tutorial" scheme="https://blog.tamako.work/categories/Essay/Tutorial/"/>
    
    
    <category term="Kotlin" scheme="https://blog.tamako.work/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>【Arch Linux】使用 Wine 运行 Galgame</title>
    <link href="https://blog.tamako.work/techdev/arch/wine-galgame/"/>
    <id>https://blog.tamako.work/techdev/arch/wine-galgame/</id>
    <published>2022-08-24T16:03:09.000Z</published>
    <updated>2022-08-24T16:03:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍在 Arch Linux 上通过 Wine 运行 Galgame 的主要步骤. 理论上对其他 Linux 发行版也可作类似操作.</p><p>需要注意的是, 以下教程<strong>很可能</strong>只对日文原版的 Galgame 有效. 考虑到中国大陆大量汉化 Galgame 存在”壳”, 标准的 Wine 配置可能无法应对, 需要据情况自行分析.</p><span id="more"></span><h2 id="Wine"><a href="#Wine" class="headerlink" title="Wine"></a>Wine</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>对 Wine 的简要介绍可参见<a href="https://en.wikipedia.org/wiki/Wine_(software)">维基百科</a>和 <a href="https://wiki.archlinux.org/title/wine">Arch Linux Wiki 同名词条</a>, 并非本文重点, 故不作赘述.</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Wine 的开发和 Staging (包含一些修复和补丁等) 分支位于官方包仓库的 <a href="https://wiki.archlinux.org/title/Official_repositories#multilib">Multilib</a> 仓库, Stable 分支位于 AUR. 以 Staging 分支为例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S wine-staging</span><br></pre></td></tr></table></figure><p>同时可能需要安装 32 位的图形和音频驱动, 分别参见 Arch Linux Wiki 的 <a href="https://wiki.archlinux.org/title/wine#Graphics_drivers">Wine#Graphics drivers</a> 和 <a href="https://wiki.archlinux.org/title/wine#Sound">Wine#Sound</a> 章节.</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用 <code>winecfg</code> 进行 Wine 相关的配置. 一般情况下不需要做改动.</p><p>对于启动系统 UI 缩放的设备, 可以在 Graphics 选项卡下的 Screen resolution 设置项下等比例设置 DPI, 例如默认值为 96 时, 150% 缩放等级对应的 DPI 为 144.</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine notepad</span><br></pre></td></tr></table></figure><h2 id="字体和-locale"><a href="#字体和-locale" class="headerlink" title="字体和 locale"></a>字体和 locale</h2><p>对于 Wine 来说如上的设置已经可以启动很多应用程序了, 但对于日本生产的 Galgame 来说, 默认简体中文或英文的系统环境极有可能造成”乱码”. 因此我们还需要作一些额外的设置.</p><h3 id="日文字体"><a href="#日文字体" class="headerlink" title="日文字体"></a>日文字体</h3><p>一些教程<a href="http://brokendragontranslation.com/shift_jis_linux.html">^1</a>给出的解决方案是从系统语言为日本语的 Windows 系统中复制 <code>C:\Windows\Fonts</code> 文件夹中的字体, 不过 AUR 已经有人整理过日本语字体包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S ttf-ms-win11-auto-japanese</span><br></pre></td></tr></table></figure><p>若出现字体安装失败的情况, 请参照<a href="/techdev/arch/localization-simplified-chinese/#ttf-ms-win11-auto-%E7%9B%B8%E5%85%B3%E5%8C%85%E6%97%A0%E6%95%88">此章节</a>.</p><h3 id="Shift-JIS-locale"><a href="#Shift-JIS-locale" class="headerlink" title="Shift-JIS locale"></a>Shift-JIS locale</h3><p>许多 Galgame 的开发 locale 使用的都是 Shift-JIS, 但其并不在大部分现代 Linux 发行版中内置. 需要另外安装.</p><p>参考<a href="http://brokendragontranslation.com/shift_jis_linux.html">此教程</a>, 下载作者提供的 <a href="https://mega.nz/#!KB413K5Y!anzW3tV-XYMinQZtWaMOlDaBE1cibls15DpAQH4tiHc">mega.nz</a> 或 <a href="https://drive.google.com/open?id=1X3pPqiks5-5Z2iMkDuPOVnAOAi_68rKW">Google Drive</a> 内的文件并按照要求解压后:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo localedef  -i ja_JP  -f SHIFT_JIS ja_JP.sjis --no-warnings=ascii</span><br><span class="line">sudo sed -i <span class="string">&#x27;/ja_JP.UTF-8 UTF-8/a ja_JP.SJIS SHIFT_JIS  &#x27;</span> /etc/locale.gen</span><br><span class="line"><span class="comment"># sudo locale-gen # 可能会失败, 但此时 locale 应已配置成功. 此时需要将上一行命令中新生成的一行数据删除或注释.</span></span><br></pre></td></tr></table></figure><p>此时再在终端中切换目录到 Galgame 目录下, 执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LC_ALL=ja_JP.sjis wine &lt;游戏可执行文件&gt;.exe</span><br></pre></td></tr></table></figure><p>同时可以尝试 ja_JP.utf8. 在 <code>/etc/locale.gen</code> 中找到 <code>#ja_JP.UTF-8 UTF-8</code> 一行, 删除前面的注释符后执行 <code>sudo locale-gen</code>, 再:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LC_ALL=ja_JP.utf8 wine &lt;游戏可执行文件&gt;.exe</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍在 Arch Linux 上通过 Wine 运行 Galgame 的主要步骤. 理论上对其他 Linux 发行版也可作类似操作.&lt;/p&gt;
&lt;p&gt;需要注意的是, 以下教程&lt;strong&gt;很可能&lt;/strong&gt;只对日文原版的 Galgame 有效. 考虑到中国大陆大量汉化 Galgame 存在”壳”, 标准的 Wine 配置可能无法应对, 需要据情况自行分析.&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    <category term="Tutorial" scheme="https://blog.tamako.work/categories/Essay/Tutorial/"/>
    
    
    <category term="Arch Linux" scheme="https://blog.tamako.work/tags/Arch-Linux/"/>
    
    <category term="Wine" scheme="https://blog.tamako.work/tags/Wine/"/>
    
    <category term="Galgame" scheme="https://blog.tamako.work/tags/Galgame/"/>
    
  </entry>
  
  <entry>
    <title>【Arch Linux】编译安装 AUR 上的 Linux 内核</title>
    <link href="https://blog.tamako.work/techdev/arch/kernel-compilation/"/>
    <id>https://blog.tamako.work/techdev/arch/kernel-compilation/</id>
    <published>2022-08-15T11:00:49.000Z</published>
    <updated>2022-08-15T11:00:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Arch Linux 可以使用多种 Linux 内核. 默认的内核由官方 <code>core</code> 仓库的 <code>linux</code> 包提供, 一般另附有 <code>linux-headers</code> 包. 官方仓库中提供的预编译内核还有同为 <code>core</code> 仓库的 <code>linux-lts</code> 和 <code>extra</code> 仓库的 <code>linux-zen</code>. 不过, 在一些场合下, 例如需要更新的或是有 patch 的内核时, 我们可能需要从 AUR 中获取需要的内核并手动编译安装. 本文以 <code>linux-mainline</code> 包为例, 主要借助 <code>yay</code> 更便捷地处理相关操作.</p><span id="more"></span><p>通常情况下, 只需要 <code>yay -S linux-mainline</code> 即可. 以下需要对编译安装过程做一些可选操作.</p><h2 id="获取-PKGBUILD"><a href="#获取-PKGBUILD" class="headerlink" title="获取 PKGBUILD"></a>获取 <code>PKGBUILD</code></h2><p>使用 <code>yay</code> 的 <code>-G</code> 选项仅获得 <code>PKGBUILD</code> 等相关的文件. 添加 <code>--force</code> 以强制保持与上游 AUR 包内容一致. 由于该操作默认目标文件夹为当前文件夹, 所以可以切换到 <code>~/.cache/yay</code> 后再获取.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.cache/yay &amp;&amp; <span class="built_in">cd</span> ~/.cache/yay</span><br><span class="line">yay -G --force linux-mainline</span><br></pre></td></tr></table></figure><h2 id="可选-修改上游仓库-URL"><a href="#可选-修改上游仓库-URL" class="headerlink" title="(可选) 修改上游仓库 URL"></a>(可选) 修改上游仓库 URL</h2><p>进入 <code>linux-mainline</code> 文件夹查看 <code>PKGBUILD</code> 后可以发现其从 &lt;kernel.org&gt; 的 Git 服务器获取上游的 Linux 源码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">source</span>=(</span><br><span class="line">  <span class="string">&quot;<span class="variable">$_srcname</span>::git+https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git#tag=<span class="variable">$_tag</span>&quot;</span></span><br><span class="line">  config         <span class="comment"># the main kernel config file</span></span><br><span class="line">)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是完整的 Linux 仓库体积已经超过 2 GB, 对于中国大陆用户不够友好. 好在 &lt;kernel.org&gt; 在北京已经设置 Git 镜像: <a href="https://kernel.source.codeaurora.cn/">https://kernel.source.codeaurora.cn/</a>. 所以我们可以修改上游仓库的 URL, 以提高下载速度. 在编辑器中打开 <code>PKGBUILD</code>:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">26c26</span><br><span class="line">&lt;   &quot;$_srcname::git+https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git#tag=$_tag&quot;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt;   &quot;$_srcname::git+https://kernel.source.codeaurora.cn/pub/scm/linux/kernel/git/torvalds/linux.git#tag=$_tag&quot;</span><br></pre></td></tr></table></figure><p>或者是执行下面的命令修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/git+https\:\/\/git\.kernel\.org\/pub\/scm\/linux\/kernel\/git\/torvalds\/linux\.git/git+https:\/\/kernel.source.codeaurora.cn\/pub\/scm\/linux\/kernel\/git\/torvalds\/linux.git/&#x27;</span> PKGBUILD</span><br></pre></td></tr></table></figure><p>此外, 还可以通过 <code>yay</code> 的 <code>--editmenu</code> 参数交互式编辑:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S --editmenu linux-mainline</span><br></pre></td></tr></table></figure><h2 id="可选-获取-PGP-密钥"><a href="#可选-获取-PGP-密钥" class="headerlink" title="(可选) 获取 PGP 密钥"></a>(可选) 获取 PGP 密钥</h2><p>查看 <code>PKGBUILD</code> 可以看到用户需要接受三个 PGP 密钥, 分别是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">validpgpkeys=(</span><br><span class="line">  <span class="string">&#x27;ABAF11C65A2970B130ABE3C479BE3E4300411886&#x27;</span>  <span class="comment"># Linus Torvalds</span></span><br><span class="line">  <span class="string">&#x27;647F28654894E3BD457199BE38DBBDC86092693E&#x27;</span>  <span class="comment"># Greg Kroah-Hartman</span></span><br><span class="line">  <span class="string">&#x27;A2FF3A36AAA56654109064AB19802F8B0D70FC30&#x27;</span>  <span class="comment"># Jan Alexander Steffens (heftig)</span></span><br><span class="line">)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是安装过程中可能发现 yay 卡在获取密钥的部分. 对于后两个密钥, 可以通过:<a href="https://github.com/Jguer/yay/issues/1022#issuecomment-538720089">^1</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver hkp://keys.openpgp.org --recv-keys 647F28654894E3BD457199BE38DBBDC86092693E</span><br><span class="line">gpg --keyserver hkp://keys.openpgp.org --recv-keys A2FF3A36AAA56654109064AB19802F8B0D70FC30</span><br></pre></td></tr></table></figure><p>获取.</p><p>这个选项可以持久化:<a href="https://github.com/Jguer/yay/issues/1022#issuecomment-538768636">^2</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Y --gpgflags <span class="string">&quot;--keyserver hkp://keys.openpgp.org&quot;</span> --save</span><br></pre></td></tr></table></figure><p>不过对于第一个密钥, 可能需要其他的方法. 首先保证存在 <code>gpg2</code> (对应包为 <code>core</code> 仓库的 <code>gnupg</code>), 再:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg2 --auto-key-locate cert,pka,dane,wkd,keyserver --locate-keys torvalds@kernel.org</span><br></pre></td></tr></table></figure><h2 id="可选-多线程编译安装"><a href="#可选-多线程编译安装" class="headerlink" title="(可选) 多线程编译安装"></a>(可选) 多线程编译安装</h2><p>需要手动传入 <code>make</code> 命令的编译 flags:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAKEFLAGS=<span class="string">&quot;-j16&quot;</span> yay -S linux-mainline <span class="comment"># 16 线程</span></span><br></pre></td></tr></table></figure><p>多线程编译仍然可能需要较长时间 (笔者测试需要 30 分钟左右, 因机器配置而异). 请不要断电.</p><h2 id="更新-Boot-loader-配置"><a href="#更新-Boot-loader-配置" class="headerlink" title="更新 Boot loader 配置"></a>更新 Boot loader 配置</h2><p>以 GRUB 为例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p>这是非常重要的 - 否则折腾半天系统服务没法加载的时候会很痛苦.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;Arch Linux 可以使用多种 Linux 内核. 默认的内核由官方 &lt;code&gt;core&lt;/code&gt; 仓库的 &lt;code&gt;linux&lt;/code&gt; 包提供, 一般另附有 &lt;code&gt;linux-headers&lt;/code&gt; 包. 官方仓库中提供的预编译内核还有同为 &lt;code&gt;core&lt;/code&gt; 仓库的 &lt;code&gt;linux-lts&lt;/code&gt; 和 &lt;code&gt;extra&lt;/code&gt; 仓库的 &lt;code&gt;linux-zen&lt;/code&gt;. 不过, 在一些场合下, 例如需要更新的或是有 patch 的内核时, 我们可能需要从 AUR 中获取需要的内核并手动编译安装. 本文以 &lt;code&gt;linux-mainline&lt;/code&gt; 包为例, 主要借助 &lt;code&gt;yay&lt;/code&gt; 更便捷地处理相关操作.&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    <category term="Tutorial" scheme="https://blog.tamako.work/categories/Essay/Tutorial/"/>
    
    
    <category term="Arch Linux" scheme="https://blog.tamako.work/tags/Arch-Linux/"/>
    
    <category term="Operating System" scheme="https://blog.tamako.work/tags/Operating-System/"/>
    
    <category term="Kernel" scheme="https://blog.tamako.work/tags/Kernel/"/>
    
    <category term="AUR" scheme="https://blog.tamako.work/tags/AUR/"/>
    
    <category term="Compilation" scheme="https://blog.tamako.work/tags/Compilation/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1399D: Binary String to Subsequences</title>
    <link href="https://blog.tamako.work/acmoi/codeforces/1399d/"/>
    <id>https://blog.tamako.work/acmoi/codeforces/1399d/</id>
    <published>2022-08-01T16:39:59.000Z</published>
    <updated>2022-08-02T00:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/problemset/problem/1399/D">Codeforces 1399D</a> C++ 一解.</p></blockquote><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题本身的思路是很清晰的, 但考虑到一些极端数据, 需要额外添加一些数据结构.</p><p>可以确定的是, 给定的字符串的每个字符都要纳入某一个子序列中. 同时可以注意到, 如果已经存在一些子序列, 对于源串的某个字符, 只要其能接在某个子序列之后, 就不会增加现有子序列的数量; 若这个字符无法接在任何现有子序列之后, 拆开其中一部分子序列使其能够纳入也不会使子序列数量减少. 因此这种策略是最优的.</p><p>本题给定的数据规模 $\sum n\leq2\times10^5$. 若每次尝试添加字符到子序列时都顺序搜索现有子序列, 部分测试点无法通过 (例如:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">200000</span><br><span class="line">111111111111... (200000 个 1)</span><br></pre></td></tr></table></figure><p>). 因此可以设置两个栈结构用于存储现有的 “尾数” 为 0 和 1 的子序列的序号. 因为只需要构造出一种可行的组合子序列的方案即可, 只需要对栈作入栈, 出栈操作, 其时间开销可以接受.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">change_bit</span><span class="params">(<span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == <span class="string">&#x27;1&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change_bit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_bit</span><span class="params">(<span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_and_print</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>(), total = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span>, stack[2]</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="built_in">change_bit</span>(s[i]);</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">get_bit</span>(c), y = <span class="built_in">get_bit</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (stack[x].<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ++total;</span><br><span class="line">            ans[i] = total;</span><br><span class="line">            stack[y].<span class="built_in">push_back</span>(total - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = stack[x].<span class="built_in">back</span>();</span><br><span class="line">            stack[x].<span class="built_in">pop_back</span>();</span><br><span class="line">            stack[y].<span class="built_in">push_back</span>(j);</span><br><span class="line">            ans[i] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t, n;</span><br><span class="line">    string s;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        <span class="built_in">solve_and_print</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1399/D&quot;&gt;Codeforces 1399D&lt;/a&gt; C++ 一解.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Programming" scheme="https://blog.tamako.work/tags/Programming/"/>
    
    <category term="C++" scheme="https://blog.tamako.work/tags/C/"/>
    
    <category term="Codeforces" scheme="https://blog.tamako.work/tags/Codeforces/"/>
    
    <category term="Solution" scheme="https://blog.tamako.work/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1368B: Codeforces Subsequences</title>
    <link href="https://blog.tamako.work/acmoi/codeforces/1368b/"/>
    <id>https://blog.tamako.work/acmoi/codeforces/1368b/</id>
    <published>2022-08-01T10:25:06.000Z</published>
    <updated>2022-08-01T14:08:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/problemset/problem/1368/B">Codeforces 1368B</a> C++ 和 Python 一解.</p></blockquote><span id="more"></span><blockquote><p>终于看到一道比较有趣的 constructive algorithm 的题目了.</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题是 “乘法原理” 的经典应用之一: 每一个内容为 <code>codeforces</code> 子序列都需要在源串中各选择十个字符连续重复的字符串 (指连续的 <code>c</code>, <code>o</code>, <code>d</code> 等十个字符串) 中的一个字符. 若假定源串 $s$ 中 <code>c</code>, <code>o</code>, <code>d</code> 等字符各连续重复 $a_0,a_1,a_2,\cdots,a_9$ 次, 则最终能生成的 <code>codeforces</code> 子序列共有 $l=a_0a_1a_2\cdots a_9$ 个. 而为满足题意, 需要选择合适的 $a_0,a_1,a_2,\cdots,a_9$, 使得 $l\geq k$ 且 $L=a_0+a_1+a_2+\cdots+a_9$ 尽可能小.</p><h3 id="一种贪心的策略"><a href="#一种贪心的策略" class="headerlink" title="一种贪心的策略"></a>一种贪心的策略</h3><p>我们知道, 根据均值不等式, 对于长度为 $n$ 的正有限实数列 ${a_i}$, 有</p><p>$$<br>\sqrt[n]{\prod^{n}<em>{i=1}{a_i}}\leq\sum^{n}</em>{i=1}{a_i},<br>$$</p><p>当且仅当 ${a_i}$ 是常数列时取等号. 对于本题, 可以猜想: 当左式恒定, 即 $l$ 恒定时, 若要使右式 (也即 $L$) 尽可能小, 则需要选择相差不大的 $a_i(i=0,1,\cdots,9)$. 这即是一种贪心策略.</p><p>我们希望 $a_i$ 的极差尽可能小, 一种选择方法是令其中一部分 $a_i$ 比另一部分恰好大 $1$ (当然理想情况是这些 $a_i$ 都相等). 不妨假设 $a_0,a_1,\cdots,a_{m-1}$ ($m=0,1,\cdots,10$, 当 $m=0$ 时规定 $a_i=a$, 当 $m=10$ 时规定 $a_i=a+1$) 都等于 $a+1(a\in\mathbb{N}^{*})$, $a_m,a_{m+1},\cdots,a_9$ 都等于 $a$. 那么</p><p>$$<br>l=(a+1)^{10-m}a^m,\<br>L=(10-m)(a+1)+ma=10a-m+10.<br>$$</p><h3 id="a-和-m-的确定"><a href="#a-和-m-的确定" class="headerlink" title="$a$ 和 $m$ 的确定"></a>$a$ 和 $m$ 的确定</h3><p>首先我们关注 $m=10$ 即 $l=a^{10}$ 的情况. 注意到此时若要使 $l\geq k$, 则 $a\geq\sqrt[10]{k}$.</p><p>而当 $a$ 固定时, 对于不同的 $m$, 有 $\sup l=(a+1)^{10}$, $\inf l=a^{10}$, 且考虑到当 $a_p&gt;a_q$ 时恒有 $\left.L\right|<em>{a=a_p}\geq\left.L\right|</em>{a=a_q}$, 则 $a$ 可以选取 $\lfloor\sqrt[10]{k}\rfloor$.</p><p>对于 $m$, 理论上根据 $l\geq k$ 可以推导得到 $m\leq\dfrac{10\ln(a+1)-\ln k}{\ln(a+1)-\ln a}$, 但在实际编程中考虑到浮点数存在的误差 (直接用此式计算无法通过 Codeforces 测试集), 我们需要利用大整数 (<code>long long unsigned</code> 足够) 从 $m=0$ 或 $m=10$ 开始逐个测试 (理论上也可以使用二分查找, 但本题的数据规模下不必要), 直到找到符合要求的 $m$. 为方便起见, 确定 $a$ 的过程依然使用了对数法, 同时为尽可能保证计算准确, 代码中使用了自定义的下取整函数 <code>better_floor()</code>.</p><p>在 Python 中, 考虑到其原生支持处理超长整数, 对上述推导公式修改为 $k(a+1)^m\leq a^m(a+1)^{10}$, 同样可以达到题意所需要求, 而这式两边即对应下述代码中的 <code>left</code> 和 <code>right</code>.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPS (1e-14)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">base</span><span class="params">(<span class="string">&quot;codeforces&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">better_floor</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">ceil</span>(x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (y - x &lt; EPS ? y : <span class="built_in">floor</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc_m</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> k, <span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        l *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; k &amp;&amp; m-- &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        l = l * (a + <span class="number">1</span>) / a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> k;</span><br><span class="line">    <span class="type">int</span> a, m;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">better_floor</span>(<span class="built_in">pow</span>(k, <span class="number">0.1</span>)));</span><br><span class="line">    m = <span class="built_in">calc_m</span>(k, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> - m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">string</span>(a + <span class="number">1</span>, base[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span> - m; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">string</span>(a, base[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_m3</span>(<span class="params">k, a</span>):</span><br><span class="line">    left, right = k, (a + <span class="number">1</span>) ** <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">12</span>):</span><br><span class="line">        left *= a + <span class="number">1</span></span><br><span class="line">        right *= a</span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">base = <span class="string">&#x27;codeforces&#x27;</span></span><br><span class="line">a = <span class="built_in">int</span>(k ** <span class="number">0.1</span>)</span><br><span class="line">m = calc_m3(k, a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span> - m):</span><br><span class="line">    <span class="built_in">print</span>(base[i] * (a + <span class="number">1</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span> - m, <span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(base[i] * a, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1368/B&quot;&gt;Codeforces 1368B&lt;/a&gt; C++ 和 Python 一解.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Programming" scheme="https://blog.tamako.work/tags/Programming/"/>
    
    <category term="Python" scheme="https://blog.tamako.work/tags/Python/"/>
    
    <category term="C++" scheme="https://blog.tamako.work/tags/C/"/>
    
    <category term="Codeforces" scheme="https://blog.tamako.work/tags/Codeforces/"/>
    
    <category term="Solution" scheme="https://blog.tamako.work/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1430C: Numbers on Whiteboard</title>
    <link href="https://blog.tamako.work/acmoi/codeforces/1430c/"/>
    <id>https://blog.tamako.work/acmoi/codeforces/1430c/</id>
    <published>2022-07-31T02:39:03.000Z</published>
    <updated>2022-07-31T02:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/problemset/problem/1430/C">Codeforces 1430C</a> C++ 一解.</p></blockquote><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>白板上的数字初始状态是固定的 $1,2,\cdots,n$. 每次操作都会 “折损” 当下所有数字之和, 而 “折损” 的量即为选定的两个数之和的一半. 因此为使最后得到的数字最小, 一种贪心的方法是每次选择最大的两个数字做操作.</p><p>操作时对于两数之和为奇数的, 得到的新数字需要向上取整. 虽然有 “凭空” 增大数字总和的可能性, 但经过数学归纳即可得知最后一次操作选定的数字一定是 $1$ 和 $3$ $(n&gt;2)$ 或 $1$ 和 $2$ $(n=2)$, 也即最后得到的数字为 $2$. 显然若要得到小于 $2$ 的数字, 需要在倒数第二次操作时白板上只剩下两个 $1$, 而这在向上取整的规则下是做不到的. 因此这种贪心方法即为最优解.</p><h3 id="空间和时间优化"><a href="#空间和时间优化" class="headerlink" title="空间和时间优化"></a>空间和时间优化</h3><p>因为白板数字的初始状态是规律性的连续自然数列, 选定数字的过程也极为规律, 无需要实际使用栈等数据结构模拟. 官方<a href="https://codeforces.com/blog/entry/83614">题解</a>则提供了使用实际数据结构 <code>vector&lt;int&gt;</code> 的方法.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveAndPrint</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n - i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n - i + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">solveAndPrint</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1430/C&quot;&gt;Codeforces 1430C&lt;/a&gt; C++ 一解.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Programming" scheme="https://blog.tamako.work/tags/Programming/"/>
    
    <category term="C++" scheme="https://blog.tamako.work/tags/C/"/>
    
    <category term="Codeforces" scheme="https://blog.tamako.work/tags/Codeforces/"/>
    
    <category term="Solution" scheme="https://blog.tamako.work/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1419D1: Sage&#39;s Birthday (easy version)</title>
    <link href="https://blog.tamako.work/acmoi/codeforces/1419d1/"/>
    <id>https://blog.tamako.work/acmoi/codeforces/1419d1/</id>
    <published>2022-07-30T16:40:20.000Z</published>
    <updated>2022-07-30T16:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/problemset/problem/1419/D1">Codeforces 1419D1</a> C++ 一解.</p></blockquote><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题是简单版本, 各个冰淇淋球的价格都不相同. 我们只需要构造出数量最多的 “谷” 即可. 与上篇 <a href="https://blog.imakiseki.cf/acmoi/codeforces/1312b/">Codeforces 1312B: Bogosort</a> 类似, 这次相当于对一个排序后的数组同时从两边取数输出, 例如对输入数据 $[7,6,5,4,3,2,1]$, 两边取数得到 $[7,1,6,2,5,3,4]$, 这样得到的新数列的 “谷” 数量最多, 且为 $\left[\dfrac{n-1}{2}\right]$.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (n - <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="keyword">while</span> (p++ &lt; n / <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[n - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[p - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[p - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1419/D1&quot;&gt;Codeforces 1419D1&lt;/a&gt; C++ 一解.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Programming" scheme="https://blog.tamako.work/tags/Programming/"/>
    
    <category term="C++" scheme="https://blog.tamako.work/tags/C/"/>
    
    <category term="Codeforces" scheme="https://blog.tamako.work/tags/Codeforces/"/>
    
    <category term="Solution" scheme="https://blog.tamako.work/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1312B: Bogosort</title>
    <link href="https://blog.tamako.work/acmoi/codeforces/1312b/"/>
    <id>https://blog.tamako.work/acmoi/codeforces/1312b/</id>
    <published>2022-07-30T15:21:16.000Z</published>
    <updated>2022-07-30T15:53:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/problemset/problem/1312/B">Codeforces 1312B</a> C++ 一解.</p></blockquote><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>此题相当于排序数组后使两个有限数列 (一个是数列 ${1,2,\cdots,n}$, 一个是排序后的数组 $a_\mathrm{sorted}$) 的差各不相同. 一个很容易想到的构造方法是对一个单调 (不一定严格) 递减数列与严格单调递增数列求差, 这样得到的差数列的各元素一定各不相同 (且是单调递减的).</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n, a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n); <span class="comment">// 先递增排列</span></span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; a[n] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 再倒序输出, 相当于 &quot;构造&quot; 出了递减数列</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1312/B&quot;&gt;Codeforces 1312B&lt;/a&gt; C++ 一解.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Programming" scheme="https://blog.tamako.work/tags/Programming/"/>
    
    <category term="C++" scheme="https://blog.tamako.work/tags/C/"/>
    
    <category term="Codeforces" scheme="https://blog.tamako.work/tags/Codeforces/"/>
    
    <category term="Solution" scheme="https://blog.tamako.work/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1474B: Different Divisors</title>
    <link href="https://blog.tamako.work/acmoi/codeforces/1474b/"/>
    <id>https://blog.tamako.work/acmoi/codeforces/1474b/</id>
    <published>2022-07-30T03:14:01.000Z</published>
    <updated>2022-07-30T03:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/problemset/problem/1474/B">Codeforces 1474B</a> C++ 一解.</p></blockquote><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>$a$ 至少要有 $4$ 个因子 (自然包括 $1$ 和 $a$ 本身), 且任意两因子的差不小于 $d$. 为使 $a$ 尽可能小, 我们只希望 $a$ 有且仅有 $4$ 个因子, 也就是再确定两个不同的质因子 $p,q$ ($a=pq$, 且不妨设 $p&lt;q$).</p><p>一个很显然的事实是: 对于充分大的 $d$, 我们越能保证 $a-q\geq d$ (不会证明故从略), 因此我们只需要在质数表中找到不小于 $1+d$ ($1$ 即是因子升序排列的第一个因子) 的 $p$ (第二个因子) 和不小于 $p+d$ 的 $q$ (第三个因子), 再确保 $a$ (第四个因子) 与 $q$ 的差不小于 $d$ 即可. 经过验证, 对于 $d=1$ 依然有 $a-q\geq d$.</p><h3 id="生成质数表"><a href="#生成质数表" class="headerlink" title="生成质数表"></a>生成质数表</h3><p>生成质数表的方式有很多. 以下代码中尝试利用 STL 的 <code>vector&lt;int&gt;</code> 动态生成/更新指定范围内的质数表. 当然考虑到 $d\leq 10,000$, 可以直接生成完整长度 (所需的最大质数为 $20,011$, 根据质数定理估计质数表长度为 $2020$) 的质数表.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PRIME (20011) <span class="comment">// 10007 and 20011 are primes.</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="built_in">int</span>(<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(x))); i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">updatePrimes</span><span class="params">(<span class="type">int</span> maxn, vector&lt;<span class="type">int</span>&gt; primes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lastPrime = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (primes.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        lastPrime = primes.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        primes.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = lastPrime + (lastPrime == <span class="number">2</span> ? <span class="number">1</span> : <span class="number">2</span>); i &lt;= maxn; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> primes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">updatePrimes</span><span class="params">(<span class="type">int</span> maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">updatePrimes</span>(maxn, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> d, vector&lt;<span class="type">int</span>&gt; primes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator index1 = <span class="built_in">lower_bound</span>(primes.<span class="built_in">begin</span>(), primes.<span class="built_in">end</span>(), <span class="number">1</span> + d);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator index2 = <span class="built_in">lower_bound</span>(primes.<span class="built_in">begin</span>(), primes.<span class="built_in">end</span>(), *index1 + d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *index1 * *index2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, d;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; primes = <span class="built_in">updatePrimes</span>(MAX_PRIME);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; d;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>(d, primes) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1474/B&quot;&gt;Codeforces 1474B&lt;/a&gt; C++ 一解.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Programming" scheme="https://blog.tamako.work/tags/Programming/"/>
    
    <category term="C++" scheme="https://blog.tamako.work/tags/C/"/>
    
    <category term="Codeforces" scheme="https://blog.tamako.work/tags/Codeforces/"/>
    
    <category term="Solution" scheme="https://blog.tamako.work/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 766A: Mahmoud and Longest Uncommon Subsequence</title>
    <link href="https://blog.tamako.work/acmoi/codeforces/766a/"/>
    <id>https://blog.tamako.work/acmoi/codeforces/766a/</id>
    <published>2022-07-30T00:52:37.000Z</published>
    <updated>2022-07-30T01:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/problemset/problem/766/A">Codeforces 766A</a> C++ 一解.</p></blockquote><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>两个字符串的最长不公共子序列被定义为最长的仅为其中一个字符串的子序列的字符串.</p><p>对于两个长度不相同的字符串 (不妨设 $a,b$ 且 $a$ 的长度较长), 一个非常直观的想法是: 因为一个字符串的子序列的长度必须不大于该串的长度, 只要选取 $a$ 本身作为所求的子序列, 其肯定是 $a$ 的子序列, 而不是 $b$ 的子序列.</p><p>而对于长度相同的情况, 我们同样可以使用类似的思路: 若两个串不相同, 我们总能选择其中一个串本身作为所求的子序列, 这样其一定不会是另一个串的子序列; 若两个串完全相同, 此时我们就无法找到一个串 (根据题意, 包括空串) 作为所求的子序列, 只能输出 $-1$.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(a.<span class="built_in">length</span>(), b.<span class="built_in">length</span>()) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/766/A&quot;&gt;Codeforces 766A&lt;/a&gt; C++ 一解.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces 1520C: Not Adjacent Matrix</title>
    <link href="https://blog.tamako.work/acmoi/codeforces/1520c/"/>
    <id>https://blog.tamako.work/acmoi/codeforces/1520c/</id>
    <published>2022-07-28T11:23:45.000Z</published>
    <updated>2022-07-28T11:39:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/problemset/problem/1520/C">Codeforces 1520C</a> C++ 一解.</p></blockquote><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>只要求对 $n$ 阶方阵依次填充 $1,2,\cdots,n^2$, 一种常见的思考模式是依次将这个自然数序列填充到正确的位置. 显然对于本题一个较好的方案是间隔填充: 先从元素 $(0,0)$ (假定方阵左上角元素坐标为此, 其他类推) 开始每次间隔一格填充直至一行填充完毕, 再跳转到下一行间隔填充直至右下角元素 $(n-1,n-1)$, 接着顺序填充剩下的元素. 这样就能满足题意.</p><p>Codeforces 上<a href="https://codeforces.com/blog/entry/90342">编辑者博客</a>中, <a href="https://codeforces.com/profile/MikeMirzayanov">MikeMirzayazov</a> 用黑白棋盘举例, 先填充白格再填充黑格, 判定颜色依据为横纵坐标之和的奇偶性. 而以下的代码则直接将方阵拉长为长度为 $n$ 的一维数组, 直接根据下标的奇偶性填充数字, 效果类似. 当然以下的代码推出了每个坐标对应的数值的解析式, 并未利用到数组空间.</p><p>同时, 利用这样的填充方案, 显然可以得知当且仅当 $n=2$ 时找不到满足题意的方阵; 为方便编程, 这里将 $n=1$ 也做了特殊处理.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveAndPrint</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nn = n * n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nn; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (nn + i) / <span class="number">2</span> + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i / <span class="number">2</span> + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nn; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (nn + i + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i / <span class="number">2</span> + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">solveAndPrint</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1520/C&quot;&gt;Codeforces 1520C&lt;/a&gt; C++ 一解.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Programming" scheme="https://blog.tamako.work/tags/Programming/"/>
    
    <category term="C++" scheme="https://blog.tamako.work/tags/C/"/>
    
    <category term="Codeforces" scheme="https://blog.tamako.work/tags/Codeforces/"/>
    
    <category term="Solution" scheme="https://blog.tamako.work/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 266B: Queue at the School</title>
    <link href="https://blog.tamako.work/acmoi/codeforces/266b/"/>
    <id>https://blog.tamako.work/acmoi/codeforces/266b/</id>
    <published>2022-07-26T14:57:22.000Z</published>
    <updated>2022-08-15T14:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/problemset/problem/266/B">Codeforces 266B</a> C++ 一解。</p></blockquote><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>简单的模拟。把 B 想象成箱子，要不断往右侧推。</p><p>需要注意的是，没有正确理解题意的话容易理解成每次让箱子统一右移一格。但实际上，遇到 <code>BBG</code> 的情况，下一秒应该是 <code>BGB</code> 而不是 <code>GBB</code>，因为某一时刻某两个相邻位置的 B 和 G 互换后，就只能考虑其后的位置了。再拿箱子举例，应该想象成连续的箱子无法推动，只能推动箱子“队列”的最末一个。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// brute force</span></span><br><span class="line"><span class="function">string <span class="title">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> t, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; l - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; s[j + <span class="number">1</span>] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[j] = <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line">                s[j + <span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                j += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    string s, a;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    a = <span class="built_in">solve</span>(n, t, s);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/266/B&quot;&gt;Codeforces 266B&lt;/a&gt; C++ 一解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Programming" scheme="https://blog.tamako.work/tags/Programming/"/>
    
    <category term="C++" scheme="https://blog.tamako.work/tags/C/"/>
    
    <category term="Codeforces" scheme="https://blog.tamako.work/tags/Codeforces/"/>
    
    <category term="Solution" scheme="https://blog.tamako.work/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>【Arch Linux】本地化：简体中文</title>
    <link href="https://blog.tamako.work/techdev/arch/localization-simplified-chinese/"/>
    <id>https://blog.tamako.work/techdev/arch/localization-simplified-chinese/</id>
    <published>2022-07-13T14:26:58.000Z</published>
    <updated>2022-07-13T18:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍 Arch Linux 本地化为简体中文的操作。</p><p>本文的测试环境是 KDE Plasma + SDDM + Wayland。考虑到 Xorg 教程较多，且大部分操作通用，本文会存在 Xorg 和 Wayland 混合描述的情况。</p><span id="more"></span><h2 id="必要配置"><a href="#必要配置" class="headerlink" title="必要配置"></a>必要配置</h2><p>不建议用户日常使用 root 帐户，则此时用户的当前帐户建议拥有 sudo 权限。安装 <code>sudo</code> 包。</p><p>同时部分本地化安装包在 AUR 源中，建议用户安装 AUR helper。本文以 <code>yay</code> 为例。</p><h2 id="生成语言环境-1"><a href="#生成语言环境-1" class="headerlink" title="生成语言环境^1"></a>生成语言环境<a href="https://wiki.archlinux.org/title/Localization/Simplified_Chinese#locale_settings">^1</a></h2><p>编辑 <code>/etc/locale.gen</code>，找到 <code>#en_US.UTF-8 UTF-8</code> 和 <code>#zh_CN.UTF-8 UTF-8</code>，删除前面的注释符号“#”。</p><p>再生成语言环境文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo locale-gen</span><br></pre></td></tr></table></figure><p>为保证大部分程序和终端环境显示正常，在 <code>/etc/locale.conf</code> 中设置 <code>LANG</code> 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><h3 id="（可选）为-Xorg-图形界面设置中文语言环境"><a href="#（可选）为-Xorg-图形界面设置中文语言环境" class="headerlink" title="（可选）为 Xorg 图形界面设置中文语言环境"></a>（可选）为 Xorg 图形界面设置中文语言环境</h3><p>编辑 <code>~/.xinitrc</code> 或 <code>~/.xprofile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANGUAGE=zh_CN:en_US</span><br></pre></td></tr></table></figure><h2 id="显示简体中文字体"><a href="#显示简体中文字体" class="headerlink" title="显示简体中文字体"></a>显示简体中文字体</h2><p>此时图形界面的中文显示一般是异常的。这可以通过安装相关字体解决。</p><h3 id="安装字体-2"><a href="#安装字体-2" class="headerlink" title="安装字体^2"></a>安装字体<a href="https://wiki.archlinux.org/title/Localization/Simplified_Chinese#Install_fonts">^2</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S wqy-microhei wqy-microhei-lite wqy-bitmapfont wqy-zenhei ttf-arphic-ukai ttf-arphic-uming adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts noto-fonts-cjk</span><br></pre></td></tr></table></figure><p>可选 AUR 源中 <code>ttf-ms-win11-auto-*</code> 相关的包（存在已知问题，见<a href="#ttf-ms-win11-auto--%E7%9B%B8%E5%85%B3%E5%8C%85%E6%97%A0%E6%95%88">下文</a>）。</p><p>一般此时字体缓存已刷新。若无：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-cache -fv</span><br></pre></td></tr></table></figure><p>可以通过类似下述命令验证字体缓存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-match -s | grep <span class="string">&#x27;Noto Sans CJK&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="ttf-ms-win11-auto-相关包无效"><a href="#ttf-ms-win11-auto-相关包无效" class="headerlink" title="ttf-ms-win11-auto-* 相关包无效"></a><code>ttf-ms-win11-auto-*</code> 相关包无效</h4><p>参见 <code>ttf-ms-win11-auto</code> AUR 包<a href="https://aur.archlinux.org/packages/ttf-ms-win11-auto">详情页面</a>下的<a href="https://aur.archlinux.org/packages/ttf-ms-win11-auto#comment-873004">评论</a>：</p><blockquote><p>It still throws <code>ln: failed to create symbolic link &#39;/home/&lt;User&gt;/.cache/yay/ttf-ms-win11-auto/src/&#39; -&gt; &#39;&#39;: No such file or directory</code> warnings when I install the package via yay. Manually copy/move the font files from <code>~/.cache/yay/ttf-ms-win11-auto/src</code> to <code>/usr/share/fonts</code> and <code>fc-cache -fv</code> can solve the problem.</p></blockquote><p>因此，读者只需查看 AUR 包的缓存（如 <code>~/.cache/yay/ttf-ms-win11-auto</code>），找到其中的字体文件，或是解压其中的压缩包（如 <code>ttf-ms-win11-auto-zh_cn-10.0.22000.318-2-any.pkg.tar.zst</code>）得到字体文件，将其复制到 <code>/usr/share/fonts</code> 并重新生成字体缓存即可。</p><h3 id="修复简体中文字符显示为日文的问题-3"><a href="#修复简体中文字符显示为日文的问题-3" class="headerlink" title="修复简体中文字符显示为日文的问题^3"></a>修复简体中文字符显示为日文的问题<a href="https://wiki.archlinux.org/title/Localization/Simplified_Chinese#Fixed_Simplified_Chinese_display_as_a_variant_(Japanese)_glyph">^3</a></h3><p>新建文件 <code>/etc/fonts/conf.avail/64-language-selector-prefer.conf</code>：</p><p>若安装 <a href="https://archlinux.org/packages/?name=noto-fonts-cjk">noto-fonts-cjk</a> 包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;fonts.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若安装 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-otc-fonts">adobe-source-han-sans-otc-fonts</a> 包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;fonts.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Serif SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Serif TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Serif HW<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Serif K<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Sans SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Sans TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Sans HW<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Sans K<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Sans SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Sans TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Sans HW<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Source Han Sans K<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后新建软链接应用配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /etc/fonts/conf.avail/64-language-selector-prefer.conf /etc/fonts/conf.d/64-language-selector-prefer.conf</span><br></pre></td></tr></table></figure><p>随后刷新字体缓存生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-cache -fv</span><br></pre></td></tr></table></figure><h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>本文使用 Fcitx 5 框架配套 Rime 输入法引擎和 Clover Pinyin（四叶草拼音）输入方案。</p><h3 id="Fcitx-5"><a href="#Fcitx-5" class="headerlink" title="Fcitx 5"></a>Fcitx 5</h3><h4 id="安装-4"><a href="#安装-4" class="headerlink" title="安装^4"></a>安装<a href="https://wiki.archlinux.org/title/Fcitx5#Installation">^4</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5 fcitx5-qt fcitx5-gtk fcitx5-configtool</span><br></pre></td></tr></table></figure><p>在 Xorg 环境下，编辑 <code>~/.xprofile</code>：<a href="https://wiki.archlinux.org/title/Fcitx5#Integration">^5</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx5</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx5</span><br><span class="line"><span class="built_in">export</span> XMODIFIERS=<span class="string">&quot;@im=fcitx5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LANG=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_CTYPE=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br></pre></td></tr></table></figure><p>在 Wayland 环境下，编辑 <code>/etc/environment</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=<span class="string">&quot;@im=fcitx&quot;</span></span><br></pre></td></tr></table></figure><p>注销会话或重启。</p><h4 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h4><p>本文使用 <a href="https://github.com/hosxy/Fcitx5-Material-Color">Material Color</a> 皮肤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-material-color</span><br></pre></td></tr></table></figure><p>再编辑 Fcitx 5 的配置文件 <code>~/.config/fcitx5/conf/classicui.conf</code>：<a href="https://github.com/hosxy/Fcitx5-Material-Color/blob/master/README.md#%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85">^6</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 垂直候选列表</span></span><br><span class="line">Vertical Candidate List=False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按屏幕 DPI 使用</span></span><br><span class="line">PerScreenDPI=True</span><br><span class="line"></span><br><span class="line"><span class="comment"># Font (设置成你喜欢的字体)</span></span><br><span class="line">Font=<span class="string">&quot;思源黑体 CN Medium 13&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题</span></span><br><span class="line">Theme=Material-Color-Pink</span><br></pre></td></tr></table></figure><h4 id="诊断工具"><a href="#诊断工具" class="headerlink" title="诊断工具"></a>诊断工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcitx5-diagnose</span><br></pre></td></tr></table></figure><h3 id="Rime"><a href="#Rime" class="headerlink" title="Rime"></a><a href="https://rime.im/">Rime</a></h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-rime</span><br></pre></td></tr></table></figure><p>重启 Fcitx 5。依次 System Settings -&gt; Regional Settings -&gt; Input Method -&gt; Add Input Method… -&gt; Only Show Current Language [Uncheck] -&gt; Rime（中州韻）来激活输入法。</p><p><strong>注意</strong>：Rime 系统目录位于 <code>/usr/share/rime-data</code>。本地目录 <code>~/.local/share/fcitx5/rime</code> 可以覆盖前者的配置。</p><h4 id="单行模式"><a href="#单行模式" class="headerlink" title="单行模式"></a>单行模式</h4><p>单行模式类似于 Windows 10 中微软拼音的默认行为：输入的拼音序列能同时键入到文本中，待选定候选词后才将其替换为对应的词。</p><p>编辑 <code>~/.config/fcitx5/conf/rime.conf</code>：<a href="https://github.com/hosxy/Fcitx5-Material-Color/blob/master/README.md#%E5%8D%95%E8%A1%8C%E6%A8%A1%E5%BC%8F-inline-preedit">^7</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可用时在应用程序中显示预编辑文本（开启单行模式）</span></span><br><span class="line">PreeditInApplication=True</span><br></pre></td></tr></table></figure><h3 id="Clover-Pinyin"><a href="#Clover-Pinyin" class="headerlink" title="Clover Pinyin"></a>Clover Pinyin</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S rime-cloverpinyin</span><br></pre></td></tr></table></figure><p>编辑 <code>~/.local/share/fcitx5/rime/default.custom.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="comment"># 每页候选词个数</span></span><br><span class="line">  <span class="attr">&quot;menu/page_size&quot;:</span> <span class="number">9</span></span><br><span class="line">  <span class="attr">schema_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">schema:</span> <span class="string">clover</span></span><br></pre></td></tr></table></figure><p>重启 Fcitx 5。</p><p><strong>注意</strong>：Clover Pinyin 有关快捷键等配置位于 <code>~/.local/share/fcitx5/rime/build/clover.schema.yaml</code>。</p><h4 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S noto-fonts-emoji</span><br><span class="line">yay -S noto-color-emoji-fontconfig</span><br></pre></td></tr></table></figure><p>注销会话或重启。</p><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><p>指输入特殊符号拼音出现候选词（如“pingfang”出现“²”），或输入“/xx”（“xx”表示一些英文字母的组合）出现一类候选词（如“/sx”出现数学相关特殊符号）。</p><p>对于前者，目前尚无较好的解决方案。</p><p>对于后者，参考该<a href="https://github.com/fkxxyz/rime-cloverpinyin/issues/71#issuecomment-820448262">回复</a>。</p><p><strong>注意</strong>：特殊符号支持存在已知问题，可能导致内存溢出，可以通过如下命令简单修复：<a href="https://github.com/fkxxyz/rime-cloverpinyin/issues/99">^8</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://github.com/fkxxyz/rime-symbols/raw/master/rime-symbols-gen)</span>&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.local/share/fcitx5/rime/opencc</span><br><span class="line"><span class="built_in">mv</span> symbol.json symbol_category.txt symbol_word.txt ~/.local/share/fcitx5/rime/opencc</span><br></pre></td></tr></table></figure><p>重新部署 Rime。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍 Arch Linux 本地化为简体中文的操作。&lt;/p&gt;
&lt;p&gt;本文的测试环境是 KDE Plasma + SDDM + Wayland。考虑到 Xorg 教程较多，且大部分操作通用，本文会存在 Xorg 和 Wayland 混合描述的情况。&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    <category term="Tutorial" scheme="https://blog.tamako.work/categories/Essay/Tutorial/"/>
    
    
    <category term="Simplified Chinese" scheme="https://blog.tamako.work/tags/Simplified-Chinese/"/>
    
    <category term="Arch Linux" scheme="https://blog.tamako.work/tags/Arch-Linux/"/>
    
    <category term="Operating System" scheme="https://blog.tamako.work/tags/Operating-System/"/>
    
    <category term="Desktop" scheme="https://blog.tamako.work/tags/Desktop/"/>
    
    <category term="Localization" scheme="https://blog.tamako.work/tags/Localization/"/>
    
  </entry>
  
  <entry>
    <title>【Arch Linux】maddy 邮件服务器搭建</title>
    <link href="https://blog.tamako.work/techdev/arch/maddy/"/>
    <id>https://blog.tamako.work/techdev/arch/maddy/</id>
    <published>2022-05-15T17:09:52.000Z</published>
    <updated>2022-07-13T12:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/foxcpp/maddy">maddy</a> 是一个开源的轻量级“可组合”（composable）多合一邮件服务器，支持通过 IMAP/SMTP 等协议和 DKIM、SPF、DMARC、DANE、MTA-STS 等安全模式收发邮件。本文将以<a href="https://maddy.email/tutorials/setting-up/">官方文档</a>为主线，整理 maddy 服务器配置流程。</p></blockquote><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为保证 maddy 的正常运行，请先明确一些建议满足的前提条件：</p><ul><li>具有公网地址（本文以 IPv4 为例）并开放 25、143、465（TLS）、587、993（TLS）等端口（一些 VPS 提供商如谷歌云不支持）的服务器；</li><li>拥有一个域名（最好是付费二级域名，避免一些 DNS 服务商如 Cloudflare 封禁对其的 API 操作），并接入 DNS 服务商（本文以 <a href="https://www.cloudflare.com/">Cloudflare</a> 为例）；</li><li>TLS 证书（本文以 <a href="https://letsencrypt.org/">Let’s Encrypt</a> 和一款证书获取软件 <a href="https://certbot.eff.org/">certbot</a> 为例）。</li></ul><p>为叙述方便，本文假设邮件服务器的主域名为 example.org，<a href="https://zh.wikipedia.org/zh-cn/MX%E8%AE%B0%E5%BD%95">邮件交换</a>（<a href="https://en.wikipedia.org/wiki/MX_record">MX</a>）域名为 mx1.example.org，公网 IPv4 地址为 10.2.3.4，邮件账户为 <a href="mailto:&#112;&#x6f;&#x73;&#116;&#109;&#x61;&#x73;&#x74;&#101;&#x72;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#111;&#114;&#103;">&#112;&#x6f;&#x73;&#116;&#109;&#x61;&#x73;&#x74;&#101;&#x72;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#111;&#114;&#103;</a>。</p><p>同时需要在服务器上至少安装如下的软件包：</p><ul><li>maddy</li><li>certbot<ul><li>certbot-dns-cloudflare</li></ul></li><li>nginx（或其他 Web 服务端）</li></ul><p>除 maddy 外，其他的软件包都可以使用 <code>pacman</code> 直接安装。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以在 GitHub 的 <a href="https://github.com/foxcpp/maddy/releases">Releases</a> 页面获取 maddy 最新版本的源码和预编译程序。也可以参照<a href="https://maddy.email/tutorials/setting-up/#installing-maddy">官方文档</a>的说明，从源码构建、AUR 处获取或 Docker 镜像部署。</p><p><strong>注意</strong>：从 AUR 处获取需要下载体积很大的 golang 编译器。为节约下载并安装编译器的时间，读者可以直接使用 GitHub 的预编译程序。本文也以此为例。</p><p>在服务器终端中执行如下命令，以下载 maddy 的预编译程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 zstd 包，以解压 *.zst 类型的文件</span></span><br><span class="line">sudo pacman -S zstd --needed</span><br><span class="line"><span class="comment"># 下载地址，可以任意选择</span></span><br><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br><span class="line">wget https://github.com/foxcpp/maddy/releases/download/v0.5.4/maddy-0.5.4-x86_64-linux-musl.tar.zst</span><br><span class="line"><span class="comment"># 参考 zsh 的 extract 插件</span></span><br><span class="line">tar --zstd -xvf maddy-0.5.4-x86_64-linux-musl.tar.zst || zstdcat maddy-0.5.4-x86_64-linux-musl.tar.zst | tar xvf -</span><br><span class="line"><span class="built_in">cd</span> maddy-0.5.4-x86_64-linux-musl</span><br><span class="line"><span class="comment"># 复制服务</span></span><br><span class="line">sudo <span class="built_in">cp</span> systemd/*.service /etc/systemd/system</span><br><span class="line"><span class="comment"># 复制可执行文件</span></span><br><span class="line">sudo <span class="built_in">cp</span> maddy maddyctl /usr/local/bin</span><br><span class="line"><span class="comment"># 复制配置文件</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/maddy</span><br><span class="line">sudo <span class="built_in">cp</span> maddy.conf /etc/maddy</span><br><span class="line"><span class="comment"># 复制 man 文件</span></span><br><span class="line">sudo <span class="built_in">cp</span> man/*.1 /usr/share/man/man1</span><br><span class="line">sudo <span class="built_in">cp</span> man/*.5 /usr/share/man/man5</span><br></pre></td></tr></table></figure><p>启动服务前，先加载所有新增服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>若要开机自启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> maddy</span><br></pre></td></tr></table></figure><p>因为 maddy 运行在非 root 用户上，还需要创建一个用户用以运行 maddy 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -mrU -s /sbin/nologin -d /var/lib/maddy -c <span class="string">&quot;maddy mail server&quot;</span> maddy</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>使用任何编辑器打开 <code>/etc/maddy/maddy.conf</code>，修改 <code>$(hostname)</code> 和 <code>$(primary_domain)</code> 变量的值为 <code>mx1.example.org</code> 和 <code>example.org</code>。</p><h3 id="TLS-证书"><a href="#TLS-证书" class="headerlink" title="TLS 证书"></a>TLS 证书</h3><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>Let’s Enccrypt 签发的 TLS 证书可以通过 certbot 获取。根据 <a href="https://eff-certbot.readthedocs.io/en/stable">certbot</a> 和 <a href="https://certbot-dns-cloudflare.readthedocs.io/en/stable/">certbot-dns-cloudflare</a> 的官方文档，首先需要在 Cloudflare 的 API Token <a href="https://dash.cloudflare.com/profile/api-tokens">配置页面</a>新建一个 Token，选择“Edit zone DNS”的模板，在“Zone Resources”选择目标二级域名（本文则是“example.org”）即可。</p><p><strong>注意</strong>：Token 只会显示一次，在配置好证书前，请务必牢记。</p><p>随后，可以在服务器上存储 Token 以方便后续使用。在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.secrets/certbot</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&lt;TOKEN&gt;&#x27;</span> &gt; ~/.secrets/certbot/cloudflare.ini  <span class="comment"># 替换为获取到的 Token</span></span><br></pre></td></tr></table></figure><p>并设置权限提高安全性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 ~/.secrets/certbot/cloudflare.ini</span><br></pre></td></tr></table></figure><p>再使用 certbot 获取证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot certonly --dns-cloudflare --dns-cloudflare-credentials ~/.secrets/certbot/cloudflare.ini -d <span class="string">&#x27;*.example.org&#x27;</span> -d <span class="string">&#x27;example.org&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：可以选择不为含通配符域名，而是根据后文实际需要指定必要的三级域名签发证书。</p><p>首次获取证书需要填写邮箱等个人信息。签发完毕后则可以通过 <code>sudo certbot certificates</code> 获取证书的详细信息和存储位置。一般存储位置在 <code>/etc/letsencrypt/live/example.org</code>，其中证书文件名为 <code>fullchain.pem</code>，私钥路径为 <code>privkey.pem</code>。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>编辑 <code>/etc/maddy/maddy.conf</code>，修改 <code>tls file</code> 一行为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tls file /etc/letsencrypt/live/$(primary_domain)/fullchain.pem /etc/letsencrypt/live/$(primary_domain)/privkey.pem</span><br></pre></td></tr></table></figure><p><code>/etc/letsencrypt/live</code> 文件夹默认权限为 750，maddy 无法访问，故需要使用 ACL 进行权限控制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo setfacl -R -m u:maddy:rX /etc/letsencrypt/&#123;live,archive&#125;</span><br></pre></td></tr></table></figure><p>此时可以启动 maddy 服务来测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start maddy</span><br></pre></td></tr></table></figure><p>若服务未报错，则可以继续进行配置。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>进入 Cloudflare 的 DNS 配置页，作出如下所示的配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">example.org.   A     10.2.3.4</span><br><span class="line">example.org.   MX    10 mx1.example.org.</span><br><span class="line">mx1.example.org.   A     10.2.3.4</span><br><span class="line">example.org.     TXT   &quot;v=spf1 mx ~all&quot;</span><br><span class="line">mx1.example.org. TXT   &quot;v=spf1 mx ~all&quot;</span><br><span class="line">_dmarc.example.org.   TXT    &quot;v=DMARC1; p=quarantine; ruf=mailto:postmaster@example.org&quot;</span><br><span class="line">_mta-sts.example.org.   TXT    &quot;v=STSv1; id=1&quot;</span><br><span class="line">_smtp._tls.example.org. TXT    &quot;v=TLSRPTv1;rua=mailto:postmaster@example.org&quot;</span><br><span class="line">default._domainkey.example.org.    TXT   &quot;v=DKIM1; k=ed25519; p=nAcUUozPlhc4VPhp7hZl+owES7j7OlEv0laaDEDBAqg=&quot;</span><br></pre></td></tr></table></figure><p>其中最后一条记录的值需要用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /var/lib/maddy/dkim_keys/example.org_default.dns</span><br></pre></td></tr></table></figure><p>的输出替换。若显示文件不存在，请确认 maddy 服务是否曾成功运行过至少一次。</p><h3 id="MTA-STS"><a href="#MTA-STS" class="headerlink" title="MTA-STS"></a>MTA-STS</h3><p>MTA-STS 要求访问 <a href="https://mta-sts.example.org/.well-known/mta-sts.txt">https://mta-sts.example.org/.well-known/mta-sts.txt</a> 时能输出类似如下的文本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: STSv1</span><br><span class="line">mode: enforce</span><br><span class="line">max_age: 604800</span><br><span class="line">mx: mx1.example.org</span><br></pre></td></tr></table></figure><p>对于已经安装 HTTP Echo 模块的 Nginx，直接在 <code>/etc/nginx/nginx.conf</code> 中添加如下条目：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>          <span class="number">443</span> ssl http2;</span><br><span class="line">    <span class="attribute">server_name</span>     mta-sts.example.org;</span><br><span class="line">    <span class="attribute">error_log</span>       /var/log/nginx/log.log;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/example.org/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/example.org/privkey.pem;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="section">location</span> /.well-known/mta-sts.txt &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">&#x27;version: STSv1&#x27;</span>;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">&#x27;mode: enforce&#x27;</span>;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">&#x27;max_age: 604800&#x27;</span>;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">&#x27;mx: mx1.example.org&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于未安装该模块的 Nginx，先添加如下条目：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>          <span class="number">443</span> ssl http2;</span><br><span class="line">    <span class="attribute">server_name</span>     mta-sts.example.org;</span><br><span class="line">    <span class="attribute">error_log</span>       /var/log/nginx/log.log;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/example.org/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/example.org/privkey.pem;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="section">location</span> /.well-known/mta-sts.txt &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/mta-sts;  <span class="comment"># /usr/share/nginx 是 Nginx 的静态资源默认位置</span></span><br><span class="line">        <span class="attribute">index</span> /mta-sts.txt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再新建 <code>/usr/share/nginx/mta-sts</code> 文件夹，将指定文本写入 <code>mta-sts.txt</code> 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">version: STSv1</span></span><br><span class="line"><span class="string">mode: enforce</span></span><br><span class="line"><span class="string">max_age: 604800</span></span><br><span class="line"><span class="string">mx: mx1.example.org</span></span><br><span class="line"><span class="string">EOF</span> &gt; /usr/share/nginx/mta-sts/mta-sts.txt</span><br></pre></td></tr></table></figure><p>重启 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>检查上述网络路径是否能够正常访问。</p><h3 id="DANE"><a href="#DANE" class="headerlink" title="DANE"></a>DANE</h3><p>设置 TLSA（DANE）需要在 <a href="https://www.huque.com/bin/gen_tlsa">https://www.huque.com/bin/gen_tlsa</a> 生成对应的 DNS 记录。</p><p>进入页面后，在“Enter/paste PEM format X.509 certificate here:”下的文本框中输入<a href="#tls-%E8%AF%81%E4%B9%A6">上文</a>中获取的证书的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /etc/letsencrypt/live/example.org/fullchain.pem</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：该证书很长，务必复制完全。</p><p>下方的“Port Number:”填写 <code>25</code>，<code>Transport Protocol:</code> 填写 <code>tcp</code>，<code>Domain Name:</code> 填写 <code>mx1.example.org</code>。再点击“Generate”生成记录。将 DNS 记录写入 Cloudflare 中。</p><h3 id="创建邮件账户"><a href="#创建邮件账户" class="headerlink" title="创建邮件账户"></a>创建邮件账户</h3><p>在服务器终端中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maddyctl creds create postmaster@example.org</span><br><span class="line">maddyctl imap-acct create postmaster@example.org</span><br></pre></td></tr></table></figure><p>此时，邮件账户的用户名为“<a href="mailto:&#x70;&#x6f;&#x73;&#x74;&#109;&#97;&#115;&#x74;&#x65;&#114;&#x40;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#111;&#114;&#x67;">&#x70;&#x6f;&#x73;&#x74;&#109;&#97;&#115;&#x74;&#x65;&#114;&#x40;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#111;&#114;&#x67;</a>”，密码则在创建账户时要求设置。该账户已经可以在邮件客户端（如 Thunderbird 和 Outlook）中配置并使用。</p><h3 id="（可选）开启-DNSSEC-认证"><a href="#（可选）开启-DNSSEC-认证" class="headerlink" title="（可选）开启 DNSSEC 认证"></a>（可选）开启 DNSSEC 认证</h3><p><a href="https://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions">DNSSEC</a>（Domain Name System Security Extensions），即<a href="https://zh.wikipedia.org/zh-cn/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%89%A9%E5%B1%95">域名系统安全扩展</a>，对DNS提供给DNS客户端（解析器）的DNS数据来源进行认证，并验证不存在性和校验数据完整性验证。</p><p><a href="https://wiki.archlinux.org/title/DNSSEC">Arch Wiki</a> 中给出了一些验证方法。安装 <code>ldns</code> 包后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ drill -DT example.org  <span class="comment"># 替换为二级域名</span></span><br><span class="line"><span class="comment"># 省略多行</span></span><br><span class="line">[T] example.org. 60      IN      A       10.2.3.4</span><br><span class="line">;;[S] self sig OK; [B] bogus; [T] trusted</span><br></pre></td></tr></table></figure><p>如果命令执行结果如上所示（域名前的 flag 值为“T”），则说明 DNSSEC 认证已开启；反之，请参考 <a href="https://wiki.archlinux.org/title/DNSSEC#Install_a_DNSSEC-validating_resolver">Install a DNSSEC-validating resolver</a> 章节，或参考 DNS 服务商的文档。</p><p>以下简单介绍 Cloudflare 为域名开启 DNSSEC 的方法：进入 Cloudflare <a href="https://dash.cloudflare.com/">控制台</a>后，进入目标域名的详情页面，点击左侧的“DNS”选项卡，在页面尾部的“DNSSEC”部分点击“Enable DNSSEC”。随后 Cloudflare 将给出域名的 DS Record。再进入<strong>域名注册商</strong>的域名管理页面设置 DS Record。具体设置方法参照 Cloudflare 的<a href="https://developers.cloudflare.com/dns/additional-options/dnssec#step-2--add-ds-record-to-your-registrar">官方文档</a>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/foxcpp/maddy&quot;&gt;maddy&lt;/a&gt; 是一个开源的轻量级“可组合”（composable）多合一邮件服务器，支持通过 IMAP/SMTP 等协议和 DKIM、SPF、DMARC、DANE、MTA-STS 等安全模式收发邮件。本文将以&lt;a href=&quot;https://maddy.email/tutorials/setting-up/&quot;&gt;官方文档&lt;/a&gt;为主线，整理 maddy 服务器配置流程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Arch Linux" scheme="https://blog.tamako.work/tags/Arch-Linux/"/>
    
    <category term="maddy" scheme="https://blog.tamako.work/tags/maddy/"/>
    
    <category term="Email" scheme="https://blog.tamako.work/tags/Email/"/>
    
  </entry>
  
  <entry>
    <title>【Arch Linux】misskey 手动部署和配置</title>
    <link href="https://blog.tamako.work/techdev/arch/misskey/"/>
    <id>https://blog.tamako.work/techdev/arch/misskey/</id>
    <published>2022-04-29T12:45:20.000Z</published>
    <updated>2022-07-13T12:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://misskey-hub.net/en/">misskey</a> 是一款开源的“跨星际”（interplanetary）社交平台，以微博为主要形式，界面美观，内含元素丰富。本文即针对该平台在 Arch Linux 的手动安装方式作说明。</p><span id="more"></span><blockquote><p>笔者：为什么不用 docker 安装（这是官方认定 recommended 的安装方式）？只是不怎么想用 docker（</p></blockquote><blockquote><p><strong>注意</strong>：基于 Arch Linux 发行版的特殊性（非开箱即用），笔者会<strong>尽可能多</strong>地补充安装过程，<strong>尽可能</strong>让读者能从头到尾依照本文操作。但若存在疏漏，敬请谅解。</p></blockquote><h2 id="检查系统配置"><a href="#检查系统配置" class="headerlink" title="检查系统配置"></a>检查系统配置</h2><p>misskey 对服务端的性能配置要求较高，建议配置至少 2 核 CPU 和 4GB RAM。笔者使用的服务器部分配置如下（多人共有，但对 misskey 来说也已足够）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ neofetch</span><br><span class="line"><span class="comment"># 省略部分输出</span></span><br><span class="line">OS: Arch Linux x86_64</span><br><span class="line">Kernel: 5.15.34-1-lts</span><br><span class="line">CPU: AMD EPYC 7282 (4) @ 2.794GHz</span><br><span class="line">Memory: 1590MiB / 7950MiB</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><p>安装所有依赖（这里假设读者已经安装了 <code>sudo</code> 并配置好相关权限）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu  <span class="comment"># 更新系统</span></span><br><span class="line">sudo pacman -S sudo visudo nano base-devel python --needed</span><br><span class="line">sudo python -m ensurepip --upgrade  <span class="comment"># 安装/升级 pip</span></span><br><span class="line">sudo <span class="built_in">ln</span> -sf /usr/bin/&#123;nano,vi&#125;</span><br><span class="line">sudo visudo</span><br></pre></td></tr></table></figure><p>在打开的编辑器 <code>nano</code> 中去除 <code>#%wheel ALL=(ALL:ALL) ALL</code> 一行前的注释，依次按 <code>Ctrl+X</code>、<code>y</code>、<code>Enter</code> 保存。</p><p>同时考虑到 pip 用户配置下 <code>$PATH</code> 环境变量问题，使用编辑器打开当前终端配置（例如 <code>~/.bashrc</code>），添加如下行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=~/.local/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h4 id="misskey"><a href="#misskey" class="headerlink" title="misskey"></a>misskey</h4><p>官方文档中给出的 misskey 需要的依赖有：</p><ul><li>Node.JS（16.x）</li><li>PostgreSQL（建议 12.x 或 13.x）</li><li>Redis</li><li>yarn（可选，若不安装，后续安装过程中 <code>yarn</code> 应替换为 <code>npx yarn</code>）</li><li>FFmpeg</li></ul><p>考虑到大部分软件的向后兼容性，可以直接安装所有依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nodejs npm postgresql redis yarn ffmpeg --needed</span><br></pre></td></tr></table></figure><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>因笔者服务器环境中存在多用户、多管理情况，此处的操作与官方文档不同——创建了一个有 <code>sudo</code> 权限、可登录、有家目录的用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G wheel -s /bin/bash misskey</span><br></pre></td></tr></table></figure><p>并使用 <code>sudo passwd misskey</code> 设置登录密码。</p><p>若依照官方文档，仅需：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -r -s /usr/bin/nologin misskey</span><br></pre></td></tr></table></figure><p>之后切换入该用户继续操作：<code>su - misskey</code>。</p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>根据上文中用户创建方式，目录的路径可能不能完全如文中所述。请读者根据自身情况合理选择安装路径。</p><p>在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .opt</span><br><span class="line"><span class="built_in">cd</span> .opt</span><br><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/misskey-dev/misskey.git</span><br><span class="line"><span class="built_in">cd</span> misskey</span><br><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：截至本文编写时，misskey 源码库克隆大小 88.22MB，子库（misskey-assets）克隆大小 69.76MB。请自行选择是否“科学上网”或使用镜像站。</p><h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><p>在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：请自行选择是否“科学上网”或使用镜像站。</p><p><strong>注意</strong>：该过程耗时较长。若无人值守，建议使用 <code>tmux</code> 或 <code>screen</code> 防止 ssh 连接中断导致安装过程中断。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=production yarn build</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：该过程耗时较长。若无人值守，建议使用 <code>tmux</code> 或 <code>screen</code> 防止 ssh 连接中断导致安装过程中断。</p><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><h4 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h4><p>在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo -iu postgres  <span class="comment"># 切换到 postgres 用户</span></span><br><span class="line">initdb -D /var/lib/postgres/data</span><br><span class="line"><span class="comment"># （可选）修改 locale 和编码：</span></span><br><span class="line"><span class="comment"># initdb --locale=en_US.UTF-8 --encoding=UTF8 -D /var/lib/postgres/data</span></span><br><span class="line"><span class="built_in">exit</span>  <span class="comment"># 返回 misskey 用户</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> postgresql --now</span><br><span class="line">sudo systemctl status postgresql  <span class="comment"># 查看服务状态</span></span><br><span class="line"><span class="comment"># （可选）添加 SQL 操作历史文件</span></span><br><span class="line">sudo <span class="built_in">touch</span> /var/lib/postgres/.psql_history</span><br><span class="line">sudo <span class="built_in">chown</span> postgres:postgres /var/lib/postgres/.psql_history</span><br><span class="line">sudo -u postgres psql</span><br></pre></td></tr></table></figure><p>进入 Postgresql 操作界面，执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database misskey;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> misskey <span class="keyword">with</span> encrypted password <span class="string">&#x27;&#123;YOUR_PASSWORD&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> database misskey <span class="keyword">to</span> misskey;</span><br><span class="line">\q</span><br></pre></td></tr></table></figure><p>其中上面的 <code>&#39;&#123;YOUR_PASSWORD&#125;&#39;</code> 可以任意配置，但需要和后面的 misskey 配置文件保持一致。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> redis --now</span><br><span class="line">sudo systemctl status redis  <span class="comment"># 查看服务状态</span></span><br></pre></td></tr></table></figure><h3 id="前置配置"><a href="#前置配置" class="headerlink" title="前置配置"></a>前置配置</h3><p>从 <code>.config</code> 文件夹中复制 <code>example.yml</code> 到 <code>default.yml</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> .config/&#123;example,default&#125;.yml</span><br></pre></td></tr></table></figure><p>然后使用编辑器编辑后者，例如 <code>nano .config/default.yml</code>。其中最重要的配置（不修改就会直接导致 misskey 跑不通）是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   ┌──────────────────────────┐</span></span><br><span class="line"><span class="comment">#───┘ PostgreSQL configuration └────────────────────────────────</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5432</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Database name</span></span><br><span class="line">  <span class="attr">db:</span> <span class="string">misskey</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Auth</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">example-misskey-user</span></span><br><span class="line">  <span class="attr">pass:</span> <span class="string">example-misskey-pass</span></span><br></pre></td></tr></table></figure><p>将其中的 <code>user</code> 配置项改为 <code>user: misskey</code>，<code>pass</code> 配置项根据上面的配置保持一致。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn run init</span><br><span class="line">NODE_ENV=production npm start</span><br></pre></td></tr></table></figure><p>若在终端中看到类似如下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INFO *  [core boot]     Welcome to Misskey!</span><br><span class="line">INFO *  [core boot]     Misskey v12.110.1</span><br><span class="line">INFO *  [core boot env] NODE_ENV: production</span><br><span class="line">INFO *  [core boot env] You do not have root privileges</span><br><span class="line">INFO *  [core boot nodejs]      Version v17.9.0 detected.</span><br><span class="line">DONE *  [core boot config]      Loaded</span><br><span class="line">INFO *  [core boot db]  Connecting...</span><br><span class="line">DONE *  [core boot db]  Connected: v14.2</span><br><span class="line">DONE *  [core boot]     Misskey initialized</span><br><span class="line">INFO *  [core boot]     Starting 1 worker...</span><br><span class="line">(node:324552) ExperimentalWarning: Importing JSON modules is an experimental feature. This feature could change at any time</span><br><span class="line">(Use `node --trace-warnings ...` to show where the warning was created)</span><br><span class="line">DONE *  [core boot]     All workers started</span><br><span class="line">DONE *  [core boot]     Now listening on port 3000 on https://example.tld</span><br></pre></td></tr></table></figure><p>则表示 misskey 部署成功。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="systemd-服务"><a href="#systemd-服务" class="headerlink" title="systemd 服务"></a>systemd 服务</h3><p>可以配置 systemd 服务让其管理 misskey 的运行。新建 <code>/etc/systemd/system/misskey.service</code>，在编辑器中打开并填入如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Misskey daemon</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">User</span>=misskey</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/npm start</span><br><span class="line"><span class="attr">WorkingDirectory</span>=/home/misskey/.opt/misskey</span><br><span class="line"><span class="attr">Environment</span>=<span class="string">&quot;NODE_ENV=production&quot;</span></span><br><span class="line"><span class="attr">TimeoutSec</span>=<span class="number">60</span></span><br><span class="line"><span class="attr">StandardOutput</span>=syslog</span><br><span class="line"><span class="attr">StandardError</span>=syslog</span><br><span class="line"><span class="attr">SyslogIdentifier</span>=misskey</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>然后分别通过 <code>sudo systemctl start misskey</code> 和 <code>sudo systemctl enable misskey</code> 启动 misskey 并添加开机自启。</p><h3 id="端口转发（反向代理）和-TLS"><a href="#端口转发（反向代理）和-TLS" class="headerlink" title="端口转发（反向代理）和 TLS"></a>端口转发（反向代理）和 TLS</h3><p>misskey 支持 HTTPS/SSL/TLS 。这需要配置相关证书，并设置端口转发（反向代理）。笔者使用的软件包是 nginx，并已在 Cloudflare 添加一个域名。</p><p><strong>注意</strong>：部分免费二级域名（如 .cf、.tk）无法使用后文中提及的 Cloudflare API 自动更新 DNS 记录。请读者自行选用其他域名，或使用其他 DNS 服务。</p><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>首先安装自动签发 Let’s Encrypt 证书的软件包 certbot：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install certbot certbot-cloudflare-dns</span><br></pre></td></tr></table></figure><p>为防止证书信息泄露（certbot 默认工作和日志目录均在 <code>/etc</code>、<code>/var</code> 等文件夹中），先创建相关文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工作目录、日志目录、配置目录（存放证书）</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.var/letsencrypt ~/.logs/letsencrypt ~/.etc/letsencrypt</span><br></pre></td></tr></table></figure><p>再写入 Cloudflare API 的相关配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.secrets/certbot</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;dns_cloudflare_api_token = &#123;API_TOKEN&#125;&#x27;</span> &gt; ~/.secrets/certbot/cloudflare.ini</span><br></pre></td></tr></table></figure><p>其中 <code>&#123;API_TOKEN&#125;</code> 表示 Cloudflare 账户的 API token。请参见 Cloudflare 和 Certbot 相关文档配置。</p><p>为保证安全性，建议为其重新配置权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 700 ~/.secrets</span><br><span class="line"><span class="built_in">chmod</span> -R 600 ~/.secrets/certbot/cloudflare.ini</span><br></pre></td></tr></table></figure><p>最后，在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处使用 Cloudflare API 更新 DNS</span></span><br><span class="line">certbot certonly --dns-cloudflare --dns-cloudflare-credentials ~/.secrets/certbot/cloudflare.ini -d <span class="string">&#x27;&#123;domain&#125;&#x27;</span> --config-dir ~/.etc/letsencrypt --work-dir ~/.var/letsencrypt --logs-dir ~/.logs/letsencrypt</span><br></pre></td></tr></table></figure><p>其中 <code>&#39;&#123;domain&#125;&#39;</code> 是为 misskey 分配的域名。certbot 运行过程中需要同意相关服务条款并输入邮箱注册。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>在 DNS 服务商（如 Cloudflare）中添加一条 A/AAAA 记录，从域名指向服务器的 IP 地址。</p><h4 id="端口转发（反向代理）"><a href="#端口转发（反向代理）" class="headerlink" title="端口转发（反向代理）"></a>端口转发（反向代理）</h4><p>在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nginx-mainline --needed</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx --now</span><br></pre></td></tr></table></figure><p>再打开 <code>/etc/nginx/nginx.conf</code>，添加如下类似的配置项：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl http2;</span><br><span class="line">    <span class="attribute">server_name</span>  <span class="string">&#x27;&#123;domain&#125;&#x27;</span>;</span><br><span class="line">    <span class="attribute">error_log</span>    /var/log/nginx/log.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /home/misskey/.etc/letsencrypt/live/<span class="string">&#x27;&#123;domain&#125;&#x27;</span>/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /home/misskey/.etc/letsencrypt/live/<span class="string">&#x27;&#123;domain&#125;&#x27;</span>/privkey.pem;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:3000;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Referer http://<span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>&#39;&#123;domain&#125;&#39;</code> 表示分配的域名。证书路径以实际情况为准。</p><p>最后重启 nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><h4 id="misskey-1"><a href="#misskey-1" class="headerlink" title="misskey"></a>misskey</h4><p>打开 misskey 配置文件 <code>~/.opt/misskey/.config/default.yml</code>，修改如下配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   ┌─────┐</span></span><br><span class="line"><span class="comment">#───┘ URL └─────────────────────────────────────────────────────</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Final accessible URL seen by a user.</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">&#x27;&#123;domain&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>设置为先前分配的域名。</p><p>最后重启 misskey 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart misskey</span><br></pre></td></tr></table></figure><h2 id="特别致谢"><a href="#特别致谢" class="headerlink" title="特别致谢"></a>特别致谢</h2><p>感谢一位朋友“梦可味”在撰写本文前提供的在 Ubuntu 发行版中安装 misskey 的教程，其上有对多处踩坑的详细记录，让笔者能更快速地完成安装。之后会发布 misskey 在 Ubuntu 下的安装及配置教程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://misskey-hub.net/en/docs/install/manual.html">misskey 官方文档</a></li><li><a href="https://www.garron.me/en/bits/build-essential-arch-linux.html">build-essential in Arch Linux</a></li><li><a href="https://wiki.archlinux.org/title/Users_and_groups">Users and groups - ArchWiki</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://misskey-hub.net/en/&quot;&gt;misskey&lt;/a&gt; 是一款开源的“跨星际”（interplanetary）社交平台，以微博为主要形式，界面美观，内含元素丰富。本文即针对该平台在 Arch Linux 的手动安装方式作说明。&lt;/p&gt;</summary>
    
    
    
    <category term="Essay" scheme="https://blog.tamako.work/categories/Essay/"/>
    
    
    <category term="Arch Linux" scheme="https://blog.tamako.work/tags/Arch-Linux/"/>
    
    <category term="misskey" scheme="https://blog.tamako.work/tags/misskey/"/>
    
  </entry>
  
</feed>
