{"pages":[],"posts":[{"title":"【ACG音乐分享】Ceui《今、歩き出す君へ》","text":"《今、歩き出す君へ》是日本公司 fairys 制作的恋爱 AVG 《いますぐお兄ちゃんに妹だっていいたい！》的插曲，由 Ceui 演唱。 《今、歩き出す君へ》（此刻，致迈步向前的你）是日本公司 fairys 制作的恋爱 AVG 《いますぐお兄ちゃんに妹だっていいたい！》（现在就想告诉哥哥，我是妹妹！）的插曲，由 Ceui 演唱，被收录于专辑《PCゲーム『いますぐお兄ちゃんに妹だっていいたい！』ボーカルアルバム》。 图源为亚马逊商城。 歌词歌词原作者为网易云音乐用户虚伪的祈愿。 日文歌词123456789101112131415161718192021222324252627282930313233343536心の中で描いた地図は行き止まりばかり 迷路みたいできっと誰もが傷つきながら心に鍵かけて泣いているんだろういつも強がって 自分を奮い立たせ溢れる人ごみの中 遠い空、見上げてた過去の言葉より 未来のノートを開こうつまづいた分だけ 少しずつ 強くなれるよ世界でひとつの君という奇跡がモノクロの世界を色鮮やかに変えてゆく生きていく意味を見出すことが出来たなら描く未来は 君から始まる勇気上手く行かずに 臆病になって自分らしささえ 見失っても握り締めてる 熱い想いをずっと忘れずに 歩き続けたい夢を追いかけた 少年の日の輝き誰もが抱きしめながら 同じ今を生きてる寂しい夜だって 誰かと繋がってる気持ち心のどこかで いつも信じていたいんだ世界でひとつの明日という未来が小さな涙の種を大きな花へ変える生きていく意味を見出すことが出来たなら昨日までの自分を越えられるはず理想や憧れが大きすぎてつらくなったらありのままの心で君に語りかけよう回り道のどこかで 道なき道のどこかで出会えるかもしれない その時は笑顔で…世界でひとつの君という奇跡が消えない希望を僕に教えてくれたんだ生きていく意味は いつでもその胸にあるよ描く未来は もうすぐその先に世界でひとつの君という光が小さなこの地球のなか 広がる闇を照らす繋がる空の下 さあ自分らしく進もう始まりの詩贈るよ 歩き出す君へ 日文歌词 LRC 格式 1234567891011121314151617181920212223242526272829303132333435363738[00:00.000] 作词 : Ceui[00:01.000] 作曲 : 小高光太郎[00:21.930]心の中で描いた地図は[00:27.670]行き止まりばかり 迷路みたいで[00:33.040]きっと誰もが傷つきながら[00:38.430]心に鍵かけて泣いているんだろう[00:44.100]いつも強がって 自分を奮い立たせ[00:49.430]溢れる人ごみの中 遠い空、見上げてた[00:54.960]過去の言葉より 未来のノートを開こう[01:00.650]つまづいた分だけ 少しずつ 強くなれるよ[01:08.870]世界でひとつの君という奇跡が[01:14.150]モノクロの世界を色鮮やかに変えてゆく[01:19.780]生きていく意味を見出すことが出来たなら[01:26.200]描く未来は 君から始まる勇気[01:41.530]上手く行かずに 臆病になって[01:47.260]自分らしささえ 見失っても[01:52.500]握り締めてる 熱い想いを[01:58.120]ずっと忘れずに 歩き続けたい[02:03.740]夢を追いかけた 少年の日の輝き[02:09.020]誰もが抱きしめながら 同じ今を生きてる[02:14.600]寂しい夜だって 誰かと繋がってる気持ち[02:20.130]心のどこかで いつも信じていたいんだ[02:28.450]世界でひとつの明日という未来が[02:33.680]小さな涙の種を大きな花へ変える[02:39.410]生きていく意味を見出すことが出来たなら[02:45.830]昨日までの自分を越えられるはず[02:52.900]理想や憧れが大きすぎてつらくなったら[02:58.530]ありのままの心で君に語りかけよう[03:04.160]回り道のどこかで 道なき道のどこかで[03:09.480]出会えるかもしれない その時は笑顔で…[03:28.600]世界でひとつの君という奇跡が消えない希望を[03:36.480]僕に教えてくれたんだ[03:39.960]生きていく意味は いつでもその胸にあるよ[03:45.830]描く未来は もうすぐその先に[03:50.760]世界でひとつの君という光が[03:56.180]小さなこの地球のなか 広がる闇を照らす[04:01.560]繋がる空の下 さあ自分らしく進もう[04:08.280]始まりの詩贈るよ 歩き出す君へ 中文歌词123456789101112131415161718192021222324252627282930313233343536曾近绘于心的地图如同迷路了一般 总是处处碰壁谁都一样 都是在受伤时闭上自己的心扉哭泣着吧一直故作坚强 让自己奋起直追在这比肩接踵的人群中 仰望那遥远的天空抛弃过去的只言片语 打开那未来的一页吧在失足倒地后 慢慢坚强起来在这世间 有一个被称为「你」的奇迹让这黑白两色的世界变得五彩斑斓若能找到活下去的意义从中描绘出的未来 便是源自于你的勇气无法好好前进 变得胆怯懦弱就算心中的真实逐渐迷失也绝不会放手 绝不会忘怀那份热切的思念 坚持一步步前行追逐着梦想的少年 每一天都闪耀着光辉谁都会拥抱着 那不变的当下生活下去寂寞的夜晚里 也会感到和某人心心相印在心中的某处 一直这样坚信不疑在这世间 有一种被称为「明天」的未来将小小的泪珠变化为大大的花儿若能说出活下去的意义就一定会超越昨日的自己理想与憧憬太过宏大 变得举步维艰之时就用那毫无掩饰的心向你细细诉说吧在刻意绕远的道路某处 在没有尽头的道路某处也许会再次 和那时的笑颜相遇吧····在这世间 有一个被称为「你」的奇迹带给了我永不消逝的希望那活下去的意义 一直都在这心中哦描绘的未来 就在不远的前方在这世间 有一道被称为「你」的光芒在这小小的地球上不断扩大 照亮了黑暗彼此相连的青空之下 来吧 用自己独有的方式前进将这起始的诗篇 赠与迈出步伐的你 中文歌词 LRC 格式 12345678910111213141516171819202122232425262728293031323334353637[by:请不要在意我的昵称][00:21.930]曾近绘于心的地图[00:27.670]如同迷路了一般 总是处处碰壁[00:33.040]谁都一样 都是在受伤时[00:38.430]闭上自己的心扉哭泣着吧[00:44.100]一直故作坚强 让自己奋起直追[00:49.430]在这比肩接踵的人群中 仰望那遥远的天空[00:54.960]抛弃过去的只言片语 打开那未来的一页吧[01:00.650]在失足倒地后 慢慢坚强起来[01:08.870]在这世间 有一个被称为「你」的奇迹[01:14.150]让这黑白两色的世界变得五彩斑斓[01:19.780]若能找到活下去的意义[01:26.200]从中描绘出的未来 便是源自于你的勇气[01:41.530]无法好好前进 变得胆怯懦弱[01:47.260]就算心中的真实逐渐迷失[01:52.500]也绝不会放手 绝不会忘怀[01:58.120]那份热切的思念 坚持一步步前行[02:03.740]追逐着梦想的少年 每一天都闪耀着光辉[02:09.020]谁都会拥抱着 那不变的当下生活下去[02:14.600]寂寞的夜晚里 也会感到和某人心心相印[02:20.130]在心中的某处 一直这样坚信不疑[02:28.450]在这世间 有一种被称为「明天」的未来[02:33.680]将小小的泪珠变化为大大的花儿[02:39.410]若能说出活下去的意义[02:45.830]就一定会超越昨日的自己[02:52.900]理想与憧憬太过宏大 变得举步维艰之时[02:58.530]就用那毫无掩饰的心向你细细诉说吧[03:04.160]在刻意绕远的道路某处 在没有尽头的道路某处[03:09.480]也许会再次 和那时的笑颜相遇吧····[03:28.600]在这世间 有一个被称为「你」的奇迹[03:36.480]带给了我永不消逝的希望[03:39.960]那活下去的意义 一直都在这心中哦[03:45.830]描绘的未来 就在不远的前方[03:50.760]在这世间 有一道被称为「你」的光芒[03:56.180]在这小小的地球上不断扩大 照亮了黑暗[04:01.560]彼此相连的青空之下 来吧 用自己独有的方式前进[04:08.280]将这起始的诗篇 赠与迈出步伐的你 相关链接 网易云音乐： https://music.163.com/#/song?id=26209670 萌娘百科同名词条： https://zh.moegirl.org.cn/此刻，致迈步向前的你 萌娘百科“Ceui”词条： https://zh.moegirl.org.cn/Ceui 萌娘百科“现在就想告诉哥哥,我是妹妹!”词条： https://zh.moegirl.org.cn/现在就想告诉哥哥,我是妹妹!","link":"/acg/ima-aruki-dasu-kimi-e/"},{"title":"Linux 时间操作及其同步","text":"本文将以 Arch Linux 为例，讨论 Linux 的时间操作和同步方法。 本文围绕 Linux 的时间将 ArchWiki 上 System time 页面的部分内容做简化，并整理其他文章作为补充，简化理论性，增强可操作性。 概述操作系统的时间 (clock) 由三或四部分决定： 时间值； 是否为 UTC 时间； 时区； （如果有）夏令时。 而操作系统的时间一般有两种：硬件时间和系统时间。 硬件时间硬件时间 (也即真实时间 (Real Time Clock, RTC) 或 CMOS 时钟) 一般只存储时间值，直至 2016 年后 UEFI 硬件支持对时区和夏令时的存储。 系统时间系统时间 (也即软件时间) 可以追踪时间值、时区以及可能存在的夏令时。系统时间由 Linux 内核计算，时间值为 UTC+0 下自 1970 年 1 月 1 日午夜至今的秒数——可以在 time.is 网站查询得到。 尤其需要注意的是：操作系统完全启动后，系统时间与硬件时间是独立的。 读取状态Linux 的时间状态可由 timedatectl 或 timedatectl status 命令获取。输出类似于： 1234567 Local time: Sun 2022-02-27 12:52:24 UTC Universal time: Sun 2022-02-27 12:52:24 UTC RTC time: n/a Time zone: UTC (UTC, +0000)System clock synchronized: yes NTP service: active RTC in local TZ: no 我们可以得知： 本地时间值和 UTC 时间值均为 Sun 2022-02-27 12:52:24 UTC； 硬件时间不存在； 时区为 UTC (UTC+0)； 已经开启系统时间同步。 硬件时间上方的示例中硬件时间 (RTC time) 显示为“n/a”，也就是不存在。在一部存在硬件时间的 Linux 设备上，可以执行 hwclock --show 查看硬件时间： 12$ hwclock --show2022-02-27 21:14:16.129670+08:00 比 timedatectl 更进一步的是，hwclock 可以显示有关硬件时间的更详细信息： 12345678910111213$ hwclock --verbosehwclock from util-linux 2.34System Time: 1645967662.035542Trying to open: /dev/rtc0Using the rtc interface to the clock.Assuming hardware clock is kept in UTC time.Waiting for clock tick......got clock tickTime read from Hardware Clock: 2022/02/27 13:14:24Hw clock time : 2022/02/27 13:14:24 = 1645967664 seconds since 1969Time since last adjustment is 1645967664 secondsCalculated Hardware Clock drift is 0.000000 seconds2022-02-27 21:14:23.020178+08:00 对此输出不再作进一步介绍。 设置硬件时间（与系统时间一致）我们一般很少手动设置硬件时间。若要设置，可以使其与系统时间保持一致： 1sudo hwclock --systohc 这会新建或更新 /etc/adjtime 的内容，示例如下： 1234$ cat /etc/adjtime0.000000 1645969156 0.0000001645969156LOCAL 系统时间1sudo timedatectl set-time &quot;yyyy-MM-dd hh:mm:ss&quot; 例如： 1sudo timedatectl set-time &quot;2014-05-26 11:13:54&quot; 时区设置时区前，先需要知道可用的时区： 1timedatectl list-timezones 其中有“Asia/Shanghai”，可将时区设置为此： 1sudo timedatectl set-timezone Asia/Shanghai 同步此处提到的同步指的是系统时间与其他服务器提供的时间同步。以下提供两种方式。 systemd-timesyncd 服务配置首先启用该服务，执行 systemctl start systemd-timesyncd。可以选择加入自启动项。 打开 /etc/systemd/timesyncd.conf 文件，其中的内容可能如下： 1234567[Time]#NTP=#FallbackNTP=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.org#RootDistanceMaxSec=5#PollIntervalMinSec=32#PollIntervalMaxSec=2048#SaveIntervalSec=60 删去前两行的注释记号，并作如下修改： 12NTP=0.cn.pool.ntp.org 1.cn.pool.ntp.org 2.cn.pool.ntp.org 3.cn.pool.ntp.orgFallbackNTP=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.org 若要验证配置，执行 timedatectl show-timesync --all。一般输出类似于： 1234567891011LinkNTPServers=SystemNTPServers=FallbackNTPServers=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.orgServerName=0.arch.pool.ntp.orgServerAddress=103.47.76.177RootDistanceMaxUSec=5sPollIntervalMinUSec=32sPollIntervalMaxUSec=34min 8sPollIntervalUSec=1min 4sNTPMessage={ Leap=0, Version=4, Mode=4, Stratum=2, Precision=-21, RootDelay=177.398ms, RootDispersion=142.196ms, Reference=C342F10A, OriginateTimestamp=Mon 2018-07-16 13:53:43 +08, ReceiveTimestamp=Mon 2018-07-16 13:53:43 +08, TransmitTimestamp=Mon 2018-07-16 13:53:43 +08, DestinationTimestamp=Mon 2018-07-16 13:53:43 +08, Ignored=no PacketCount=1, Jitter=0 }Frequency=22520548 但若出现类似如下的输出： 12345678910LinkNTPServers=SystemNTPServers=0.cn.pool.ntp.org 1.cn.pool.ntp.org 2.cn.pool.ntp.org 3.cn.pool.ntp.orgFallbackNTPServers=0.pool.ntp.org 1.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.orgServerName=ServerAddress=RootDistanceMaxUSec=5sPollIntervalMinUSec=32sPollIntervalMaxUSec=34min 8sPollIntervalUSec=0Frequency=0 请跳过本小节，跳转至 chrony。 生效若要使配置生效，执行 timedatectl set-ntp true。 同步过程需要持续一段时间。若要检查同步状态，执行 timedatectl status。输出类似于： 1234567 Local time: Thu 2015-07-09 18:21:33 CEST Universal time: Thu 2015-07-09 16:21:33 UTC RTC time: Thu 2015-07-09 16:21:33 Time zone: Europe/Amsterdam (CEST, +0200)System clock synchronized: yes NTP service: active RTC in local TZ: no 若要查看详细信息，执行 timedatectl timesync-status。输出类似于： 12345678910111213 Server: 103.47.76.177 (0.arch.pool.ntp.org)Poll interval: 2min 8s (min: 32s; max 34min 8s) Leap: normal Version: 4 Stratum: 2 Reference: C342F10A Precision: 1us (-21)Root distance: 231.856ms (max: 5s) Offset: -19.428ms Delay: 36.717ms Jitter: 7.343ms Packet count: 2 Frequency: +267.747ppm chronychrony 是一个漫游友好型、且专为非所有时间在线的系统设计的程序，可以用以同步系统时间。 安装大部分软件管理器中均有该软件包。执行： 1sudo pacman -S chrony 这将在 /usr/bin 下放置 chrony 的两个可执行文件 chronyc 和 chronyd，分别作为客户端和服务端（保护进程）。 也可以在官网中查阅其他安装方式。 配置配置文件一般为 /etc/chrony.conf 或 /etc/chrony/chrony.conf。 打开配置文件，做如下更改： 定位到 pool 配置项，修改其后的服务器地址为 0.cn.pool.ntp.org； 定位到 makestep 配置项，根据需求修改； 第一个数字：进行“时间跳跃”的阈值——同步时若系统时间与服务器返回结果相差在阈值内，则程序会逐渐调整当前系统时间；反之则会直接将系统时间设为正确时间（注意：“时间跳跃”可能会对其他程序造成负面影响，不宜将此值调至过小）； 第二个数字：可进行时间调整的范围——设置为 n 表示仅前 n 次时间更新过程可发生这种调整。 定位到 logdir 配置项，删去配置记号； 定位到 rtcsync 配置项，删去注释记号。 生效启用该服务，执行 systemctl start chronyd。可以选择加入自启动项。重启，读取系统时间检查： 1234567 Local time: Sun 2022-02-27 23:16:28 CST Universal time: Sun 2022-02-27 15:16:28 UTC RTC time: n/a Time zone: Asia/Shanghai (CST, +0800)System clock synchronized: yes NTP service: active RTC in local TZ: no 观察到“System clock synchronized”栏的输出是“yes”。 若要立刻更改系统时间，执行 chronyc makestep。 参考 https://wiki.archlinux.org/title/System_time https://wiki.archlinux.org/title/Systemd-timesyncd https://www.tecmint.com/install-chrony-in-centos-ubuntu-linux/","link":"/techdev/linux-time-operations-and-sync/"},{"title":"【翻译】如何编写 Git 提交消息","text":"《【翻译】如何编写 Git 提交消息》[^1]的简体中文翻译版本对应原文为 How to Write a Git Commit Message ，原作者为 Chris Beams 。 《【翻译】如何编写 Git 提交消息》[^1]的简体中文翻译版本对应原文为 How to Write a Git Commit Message ，原作者为 Chris Beams 。请注意： 正文格式尽可能与原网页保持一致； 译者注将以脚注 (footnote) 的形式呈现，且其内容应以”译者注：“起始； 原文中若有文内跳转超链接，如无必要，将直接去除，且不在译文中作进一步说明； 原文中若有翻译后难以传达作者写作意图的词句 (通常是命令，或由源语言的特殊性质等原因导致) ，此时将不再翻译，且不在译文中作进一步说明。 翻译文本将从随后的分隔线开始展示。 如何编写 Git 提交信息 原作者： Chris Beams原文创作日期： 2014 年 8 月 31 日 提交消息很重要。这里将展示如何写好它们。 引子：为什么好的提交消息很重要如果你曾随意地浏览过一些 Git 仓库，你很可能会发现它们的提交消息或多或少有些杂乱。例如，你可以看看我早期提交给 Spring 的一些 Gem[^2] 的日志： 1234567$ git log --oneline -5 --author cbeams --before &quot;Fri Mar 26 2009&quot;e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removal in r814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culprits in the recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The test method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTests until further investigation determines why it causes downstream tests to fail (such as the seemingly unrelated ClassPathXmlApplicationContextTests)147709f Tweaks to package-info.java files22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils7f96f57 polishing 呀！再比较一下同一个仓库近期的一些提交的日志： 1234567$ git log --oneline -5 --author pwebb --before &quot;Sat Aug 30 2014&quot;5ba3db6 Fix failing CompositePropertySourceTests84564a0 Rework @PropertySource early parsing logice142fd1 Add tests for ImportSelector meta-data887815f Update docbook dependency and generate epubac8326d Polish mockito usage 你更想去阅读哪一种呢？ 前者的提交消息在长度和形式上各不相同，而后者更加精准和一致；前者是自然而然的结果，而后者绝不会是碰巧写成的。 当许多提交日志类似于前者的仓库随处可见时，也有一些例外存在。 Linux 内核和 Git 自身的源码正是良好的范例。或是看看 Spring Boot 或由 Tim Pope 管理的仓库。 这些仓库的贡献者们知道，一个经过精心打磨的 Git 提交消息是将一个更改与其他开发者 (以及未来的自己) 交流其来龙去脉的最好方式[^3]。一个 diff 的输出结果将告诉你什么改变了，而只有提交消息能恰当地告诉你为什么改变了。 Peter Hutterer 将这个观点表达得很好： 重新确定一段代码的上下文是浪费的。我们不能完全避免它，因此我们应当努力去[竭尽]所能减少这种情况的发生。提交消息能准确地做到这一点，所以一条提交消息能够展示出一位开发者是不是好的协作者。[^4] 如果你还没有很多思路来编写良好的 Git 提交消息，这或许说明你没有花费很多时间使用 git log 命令和相关的工具。这里有一个残酷的循环：因为提交历史是缺少结构和一致性的，某个人不会花费很多时间使用或关心它。并且因为它不被使用或关心，它将始终缺少结构和一致性。 然而，被维护得很好的日志是一种优美和实用的东西，这会让 git blame 、revert 、rebase 、log 、shortlog 和其他子命令充满活力，会给回顾其他人的提交和 pull requests 带来一些价值——并且它们突然能被独立地完成。理解几个月或几年前一些事情为什么发生将不但变得可能，还将变得高效。 一个项目能否取得长远的成功 (相较于其他因素) 不但取决于其可维护性如何，还在于一个维护者是否没有多少比日志更加有力的工具了。我们值得花费一些时间来学习如何适切地维护项目的日志。起初维护日志时可能的困境不久就会转变为习惯，并最终成为所有参与者自豪感和生产力的源泉。 在这篇文章中，我将会告诉你保持一份健康的提交历史的最基础的要素：如何编写一条独立的提交消息。还有其他我在这里不会提及的重要习惯，比如说统整提交[^5]，或许我会在后续的投稿中谈到它们。 大多数编程语言都有着已经成形的惯例，它们构建了符合语言习惯的风格，就像命名、格式等等[^6]。当然，这些惯例有诸多变种，但大部分开发者都认同专注于其中一种的情形远优于每个人各自选用一种造成的混乱局面。 一个团队对待提交日志的方式应当没有丝毫不同。为了创建一份实用的修订历史，团队应该首先在至少符合以下三点的提交消息惯例上达成共识： 风格。标记语言的句法[^7]，折行的间隔，语法[^8]，大小写，标点符号。将这些都明确给出，去除猜测，并且让一切都尽可能简单。最终的结果将会是一份格外一致的日志——不仅阅读起来很愉悦，而且实际上的确能被定期阅读[^9]。 内容。提交消息的主体 (如果有的话) 应该包含什么信息？什么是不能包含的？ 元数据。诸如 issue 的追踪编号[^10]、 pull request 的编号应当如何被提及？ 万幸的是，已经有一些成形的惯例来创建一条符合语言习惯的 Git 提交消息。的确，这些都假定在特定的 Git 命令运作的方式下。这里没有你需要重新发明的地方，只要遵循下方的七条规则，你就推开了像专家一样提交的大门。 编写好的 Git 提交消息的七条规则 请谨记：这些都已被提出过了。 用一个空行分隔标题和主体； 标题控制在 50 个字符以内； 标题的首字母大写； 标题的末尾不要写句号； 标题使用祈使语气； 主体每 72 个字符折行； 用主体解释做了什么和为什么，而不是如何做到。 例如： 123456789101112131415161718192021222324252627Summarize changes in around 50 characters or lessMore detailed explanatory text, if necessary. Wrap it to about 72characters or so. In some contexts, the first line is treated as thesubject of the commit and the rest of the text as the body. Theblank line separating the summary from the body is critical (unlessyou omit the body entirely); various tools like `log`, `shortlog`and `rebase` can get confused if you run the two together.Explain the problem that this commit is solving. Focus on why youare making this change as opposed to how (the code explains that).Are there side effects or other unintuitive consequences of thischange? Here's the place to explain them.Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded by a single space, with blank lines in between, but conventions vary hereIf you use an issue tracker, put references to them at the bottom,like this:Resolves: #123See also: #456, #789 1. 用一个空行分隔标题和主体根据 git commit 命令的帮助页面： 尽管不是必须的，一个好主意是，提交消息以一行简短的 (少于 50 个字符) 概括这个更改的文字为开始，紧接着是一个空行，随后是一段更详细的描述。整段文本的首行将被认作为提交的标题，那个标题将贯穿整个 Git[^11] 。例如， Git-format-patch(1) 将提交转变为邮件，它将提交的标题作为邮件的主题，将剩余的提交内容作为邮件的主体。 首先，不是每一次提交都需要标题和主体。有时一行也很好，尤其是当更改很简单以至于进一步的阐释都不必要的时候。例如： 1Fix typo in introduction to user guide 没有什么是需要解释的了。如果读者想知道这个拼写错误是什么，直接看这个更改本身即可，换句话说使用 git show 、 git diff 或 git log -p 。 如果你想用命令提交，给 git commit 命令添加 -m 选项是很容易的： 1$ git commit -m&quot;Fix typo in introduction to user guide&quot; 然而，当一个提交需要一点解释和上下文时，你需要编写它的主体。例如： 12345Derezz the master control programMCP turned out to be evil and had become intent on world domination.This commit throws Tron's disc into MCP (causing its deresolution)and turns it back into a chess game. 用 -m 选项来写提交消息的主体不是很容易，你最好在一个合适的文本编辑器中编写它。如果你还没有一个编辑器，使用 Git 命令行来设置，参阅 Pro Git 的这一节。 在任何情形下，标题和主体之间的间隔都能在浏览日志时得到回报。这里是完整的日志： 12345678910$ git logcommit 42e769bdf4894310333942ffc5a15151222a87beAuthor: Kevin Flynn &lt;kevin@flynnsarcade.com&gt;Date: Fri Jan 01 00:00:00 1982 -0200 Derezz the master control program MCP turned out to be evil and had become intent on world domination. This commit throws Tron's disc into MCP (causing its deresolution) and turns it back into a chess game. 现在执行 git log --oneline ，这会仅输出标题行： 12$ git log --oneline42e769 Derezz the master control program 或者是执行 git shortlog ，这会按照用户给提交分组，为了简洁，同样会仅输出标题行： 1234567891011121314$ git shortlogKevin Flynn (1): Derezz the master control programAlan Bradley (1): Introduce security program &quot;Tron&quot;Ed Dillinger (3): Rename chess program to &quot;MCP&quot; Modify chess program Upgrade chess programWalter Gibbs (1): Introduce protoype chess program 也有一些 Git 中的其他上下文，它们的标题行和主体的区别被打破了——但它们都无法在二者之间不空行时做得合适[^12]。 2. 标题控制在 50 个字符以内50 个字符不是硬性限制，只是一个经验法则。将标题行控制在这个长度能保证它们是可读的，并且能强迫作者花一些时间思考如何最简洁地解释将要发生什么。 提示：如果你难以概括你提交的内容，或许是因为你一次提交了太多的更改。努力做到原子级提交[^13] (另一篇投稿的话题) 吧。 GitHub 的用户界面全面地意识到了这些惯例。例如，它会在你的标题行超过 50 个字符时警告你： 并且会截断超过 72 个字符的标题行，后续用省略号代替： 因此，争取限制在 50 个字符以内，并把 72 个字符当作是硬性限制。 3. 标题的首字母大写这就跟听起来一样简单。所有的标题行的首字母都需要大写。 例如，用： Accelerate to 88 miles per hour 来替代： accelerate to 88 miles per hour 4. 标题的末尾不要写句号句末标点在标题中时无关紧要的。另外，当你想要控制 50 个字符时，空格是很珍贵的。 例如，用： Open the pod bay doors 来替代： Open the pod bay doors. 5. 标题使用祈使语气祈使语气意思就是“说出或写出类似命令或指示的东西”。以下是一些例子： 清理你的房间 关上这扇门 拿走垃圾 你正在阅读的七条规则的每一条都是用祈使语气写成的 (“主体每 72 个字符折行”以及其他的) 。 祈使语气听起来有一些失礼，这就是为什么我们不常使用，但是这对于 Git 提交的标题来说很完美，其中一个原因是 Git 自身以你的名义创建提交时都是使用祈使语气。 例如，使用 git merge 后的默认提交消息即是： 1Merge branch 'myfeature' 还有使用 git revert 后： 123Revert &quot;Add the thing with the stuff&quot;This reverts commit cc87791524aedd593cff5a74532befe7ab69ce9d. 或者是在 GitHub 的Pull Request 界面点击 “Merge” 按钮时： 1Merge pull request #123 from someuser/somebranch 因此，当你用祈使语气编写提交消息时，你就是在遵守 Git 内置的惯例。例如： Refactor subsystem X for readability Update getting started documentation Remove deprecated methods Release version 1.0.0 起初这样写可能显得有些蠢。我们更常用陈述语气说话，这种语气都是用于描述事实，这就是为什么提交消息很多都像这样结束了： Fixed bug with Y Changing behavior of X 并且有时提交消息写起来就像是它们的内容的描述： More fixes for broken stuff Sweet new API methods 为了去除任何困惑，这里是一条简单的规则来让你每次都能做对： 一个合适的 Git 提交的标题应当总是能完成如下的句子： 如果被应用了，这个提交将会这是你的标题 例如： If applied, this commit will refactor subsystem X for readability If applied, this commit will update getting started documentation If applied, this commit will remove deprecated methods If applied, this commit will release version 1.0.0 If applied, this commit will merge pull request #123 from user/branch 注意到对于非祈使语气，这是不能成功的： If applied, this commit will fixed bug with Y If applied, this commit will changing behavior of X If applied, this commit will more fixes for broken stuff If applied, this commit will sweet new API methods 记住：祈使语气的使用仅对标题很重要。在写主体时，你可以放松这条规定。 6. 主体每 72 个字符折行Git 从来不会自动折行。当你编写一个提交的主体时，你需要注意到它的右边界，并手动折行。 折行的推荐值是 72 个字符，因此 Git 在大体上将对 80 个字符以内的内容保持原样，有足够的空间用于缩进排版。 一个好的文本编辑器能帮到你。 Vim 的配置很容易，例如在编写 Git 提交消息时在 72 个字符处折行。然而，在传统意义上， IDE 对于智能地支持提交消息的折行很糟糕 (尽管 IntelliJ IDEA 在最近的版本中终于做得比以前好了) 。 7. 用主体解释做了什么和为什么，而不是如何做到这里的一条来自 Bitcoin Core 的提交 是解释更改了什么和为什么的最佳范例： 123456789101112131415161718192021commit eb0b56b19017ab5c16c745e6da39c53126924ed6Author: Pieter Wuille &lt;pieter.wuille@gmail.com&gt;Date: Fri Aug 1 22:57:55 2014 +0200 Simplify serialize.h's exception handling Remove the 'state' and 'exceptmask' from serialize.h's stream implementations, as well as related methods. As exceptmask always included 'failbit', and setstate was always called with bits = failbit, all it did was immediately raise an exception. Get rid of those variables, and replace the setstate with direct exception throwing (which also removes some dead code). As a result, good() is never reached after a failure (there are only 2 calls, one of which is in tests), and can just be replaced by !eof(). fail(), clear(n) and exceptions() are just never called. Delete them. 看一看它的完整的 diff 信息，思考这位作者在此时此地花费时间提供代码的上下文节约了其他和未来的提交者多少时间。如果他没有做到，这次提交将很可能会永远被遗忘。 在大多数情况下，你可以省去这个更改如何被做出的细节。在这点上，代码通常能自我解释 (如果这段代码如此复杂以至于它需要用枯燥的语言来解释，那就是源代码注释应该做的事情了) 。只是专注于首先明确更改的原因——你在更改之前所做的事 (以及出现了什么错误) ，它们现在如何工作的，以及为什么你决定用你的方式解决这个问题[^14]。 未来感谢你的维护者可能就是你自己！ 提示学着热爱命令行。把 IDE 抛在脑后。处于诸多原因，比如说 Git 子命令的存在，拥抱命令行是一种明智之举。 Git 有着令人疯狂的力量， IDE 亦然，但这两者体现在不同的方面上。我每天都使用一款 IDE (IntelliJ IDEA) ，也广泛地使用其他的 (Eclipse) ，但我还从没有见过哪款 IDE 的 Git 集成能比得上简单有力的命令行 (一旦你意识到了这点) 。 某些 Git 相关的 IDE 功能是无价的[^15]，就像当你删除文件时执行 git rm ，在你重命名文件的时候用 git 执行正确的命令。而当你开始试着用 IDE 提交、合并、 rebase 或分析高深莫测的历史记录时，一切都会崩溃。 当支配 Git 的全部法力之日到来之时，一切都只剩下命令行。 记住不论你是使用 Bash 、 zsh 还是 PowerShell ，都有 Tab 自动补全脚本来减轻不少记忆子命令和开关的痛苦。 阅读 Pro GitPro Git 在网上可以免费阅读，并且它很美妙。好好利用它吧！ 题图提供者： xkcd 【完】 脚注[^1]: 译者注：”提交消息“原文为 ”commit message“ ，下同。[^2]: 译者注： Spring 库的插件名为 “Gem” 。[^3]: 译者注：原文为 ”The contributors to these repositories know that a well-crafted Git commit message is the best way to communicate context about a change to fellow developers (and indeed to their future selves)“ 。[^4]: 译者注：原文为 ”Re-establishing the context of a piece of code is wasteful. We can’t avoid it completely, so our efforts should go to reducing it [as much] as possible. Commit messages can do exactly that and as a result, a commit message shows whether a developer is a good collaborator“ 。[^5]: 译者注：原文为 “commit squashing” 。[^6]: 译者注：原文为 “Most programming languages have well-established conventions as to what constitutes idiomatic style, i.e. naming, formatting and so on” 。[^7]: 译者注：原文为 “syntax” 。[^8]: 译者注：原文为 “grammar” 。[^9]: 译者注：原文为 “The end result will be a remarkably consistent log that’s not only a pleasure to read but that actually does get read on a regular basis” 。[^10]: 译者注：原文为 “issue tracking IDs” 。[^11]: 译者注：原文为 “ The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git” 。[^12]: 译者注：原文为 “There are a number of other contexts in Git where the distinction between subject line and body kicks in—but none of them work properly without the blank line in between” 。[^13]: 译者注：原文为 “atomic commits” 。[^14]: 译者注：原文为 “Just focus on making clear the reasons why you made the change in the first place—the way things worked before the change (and what was wrong with that), the way they work now, and why you decided to solve it the way you did” 。[^15]: 译者注：原文为 “Certain Git-related IDE functions are invaluable” 。","link":"/techdev/how-to-write-a-git-commit-message-chs/"},{"title":"蓝桥杯真题：纯质数","text":"蓝桥杯 2021 年国赛真题《纯质数》的 Python 解法。 蓝桥杯 2021 年国赛真题：纯质数。 题目链接：https://www.lanqiao.cn/problems/1561/learning/（需要登录）。 题目大意输出 1 到 20210605 之间（包括两端）的“纯质数”（指十进制各数位皆为质数的质数，1 不视作质数）。 分析Python本题是填空题，原则上无需时间复杂度较低的程序也可被接受。当然，这里将给出非填空题的解法。 Python 在大数据规模的循环上耗时较大，而本题显然绕不开判断质数这一话题——乍看本题给出的数据规模达到了千万级，判断其是否为质数最坏情况下需要千级别的循环，而我们要判断 20210605 个数字是否为质数，这个耗时显然是不可接受的（预测在 C/C++ 下也难以接受）。 因此我们可以考虑能否降低需要判断是否为质数的数字的数量。注意到本题中所提到的“纯质数”不仅要求其本身是质数，还要求十进制各数位也为质数——这下我们可以先借此排除掉一定不是纯质数的数字，继而大大简化运算量。 经过分析，我们得知如果一个数要满足“十进制各数位为质数”这一条件，必须满足各个数位只可取 2、3、5、7 中的一个。粗略来看，我们省下了约五分之三的运算量。而更进一步，对于不小于 10 的数字，个位数若为 2 或 5，则一定是合数，故也可提前去除。 为了更好地实现上面的需求，我们最好是自行生成纯质数的“候选”，而不是生成一个长度为 20210605 的列表再删除不符合条件的。每一个数位有可以选择的数字，而这些选择都是互不干扰的，因此我们可以利用标准库 itertools 里的 product() 生成器生成笛卡尔积，以便于快速生成符合条件的数字。实现这一需求的主要代码如下： 1234567891011121314151617181920from itertools import product# （不小于 10 的数字）非个位可取的数字集合、个位可取的数字集合_a, _b = (2, 3, 5, 7), (3, 7)# 生成“候选”数字的生成器def candidate_gen(): # 1 位数 for i in _a: yield i # 2~8 位数 for i in range(2, 9): # star expression，表示生成 (i-1) 个 `_a`，一个 `_b` for j in product(*([_a] * (i-1)), _b): # `j` 是一个由各个数位组成的元组，需要先将其拼成一个整数 x = packtup(j) # 超出范围，终止生成 if x &gt; 20210605: return yield x 判断质数的代码较为简单，在此不作详述，注意设置循环时除数的上限略高于目标数字的算术平方根即可。 完整代码Python123456789101112131415161718192021222324252627282930from itertools import product_a, _b = (2, 3, 5, 7), (3, 7)def packtup(t): return sum(map(lambda i: t[::-1][i] * 10 ** i, range(len(t))))def candidate_gen(): for i in _a: yield i for i in range(2, 9): for j in product(*([_a] * (i-1)), _b): x = packtup(j) if x &gt; 20210605: return yield xdef isprime(x): if x == 1: return False if x == 2: return True if x % 2 == 0: return False for i in range(3, int(x ** 0.5) + 1): if x % i == 0: return False return Trueprint(len(list(filter(isprime, candidate_gen()))))","link":"/acmoi/lanqiao/chun-zhi-shu/"},{"title":"【实测】Python 和 C++ 下字符串查找的速度对比","text":"最近在备战一场算法竞赛，语言误选了 Python ，无奈只能着手对常见场景进行语言迁移。而字符串查找的场景在算法竞赛中时有出现。本文即对此场景在 Python 和竞赛常用语言 C++ 下的速度进行对比，并提供相关参数和运行结果供他人参考。 背景最近在备战一场算法竞赛，语言误选了 Python ，无奈只能着手对常见场景进行语言迁移。而字符串查找的场景在算法竞赛中时有出现。本文即对此场景在 Python 和竞赛常用语言 C++ 下的速度进行对比，并提供相关参数和运行结果供他人参考。 参数硬件和操作系统12345678910111213141516171819 -` root@&lt;hostname&gt; .o+` ------------ `ooo/ OS: Arch Linux ARM aarch64 `+oooo: Host: Raspberry Pi 4 Model B `+oooooo: Kernel: 5.16.12-1-aarch64-ARCH -+oooooo+: Uptime: 3 hours, 32 mins `/:-:++oooo+: Packages: 378 (pacman) `/++++/+++++++: Shell: zsh 5.8.1 `/++++++++++++++: Terminal: /dev/pts/0 `/+++ooooooooooooo/` CPU: (4) @ 1.500GHz ./ooosssso++osssssso+` Memory: 102MiB / 7797MiB .oossssso-````/ossssss+` -osssssso. :ssssssso. :osssssss/ osssso+++. /ossssssss/ +ssssooo/- `/ossssso+/:- -:/+osssso+- `+sso+:-` `.-/+oso:`++:. `-/+/.` `/ 编译环境和解释环境 Python 解释器：Python 3.10.2 (main, Jan 23 2022, 21:20:14) [GCC 10.2.0] on linux 交互环境：IPython 8.0.1 C++ 编译器：g++ (GCC) 11.2.0 编译命令：g++ test.cpp -Wall -O2 -g -std=c++11 -o test 场景本次实测设置两个场景：场景 1 的源串字符分布使用伪随机数生成器生成，表示字符串查找的平均情况；场景 2 的源串可连续分割成 20,000 个长度为 50 的字符片段，其中第 15,001 个即为模式串，形如“ab…b”（1 个“a”，49 个 “b”），其余的字符片段形如“ab…c”（1 个“a”，48 个“b”，1 个“c”）。 项目 场景 1：平均情况 场景 2：较坏情况 字符集 小写字母 abc 字符分布 random.choice 有较强规律性 源串长度 1,000,000 1,000,000 模式串长度 1,000 50 模式串出现位置 250,000、500,000、750,000 750,000 模式串出现次数 1 1 测试方法本次实测中，Python 语言使用内置类型 str 的 .find() 成员函数，C++ 语言分别使用 string 类的 .find() 成员函数、strstr 标准库函数和用户实现的 KMP 算法。 测试对象 核心代码 Python src.find(pat) C++ - test.cpp src.find(pat) C++ - test_strstr.cpp strstr(src, pat) C++ - test_kmp.cpp KMP(src, pat) 源代码生成源串和模式串123456789101112131415161718192021import random# 场景 1：# 源串s = &quot;&quot;.join(chr(random.choice(range(ord(&quot;a&quot;), ord(&quot;z&quot;) + 1))) for _ in range(1000000))# 模式串列表，三个元素各对应一个模式串p = [s[250000:251000], s[500000:501000], s[750000:751000]]# 场景 2：# 模式串p = 'a' + 'b' * 49# 其他字符片段_s = &quot;a&quot; + &quot;b&quot; * 48 + &quot;c&quot;# 源串s = _s * 15000 + p + _s * 4999# 存储到文件，便于 C++ 程序获取with open('source.in', 'w') as f: f.write(s)with open('pattern.in', 'w') as f: f.write(p[0]) 测试代码Python1In []: %timeit s.find(p[0]) C++ - test.cpp12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#define LOOP_COUNT (1000)using namespace std;using std::chrono::high_resolution_clock;using std::chrono::duration_cast;using std::chrono::duration;using std::chrono::milliseconds;double test(string s, string p, size_t* pos_ptr) { auto t1 = high_resolution_clock::now(); *pos_ptr = s.find(p); auto t2 = high_resolution_clock::now(); duration&lt;double, milli&gt; ms_double = t2 - t1; return ms_double.count();}int main() { string s, p; size_t pos; ifstream srcfile(&quot;source.in&quot;); ifstream patfile(&quot;pattern.in&quot;); srcfile &gt;&gt; s; patfile &gt;&gt; p; double tot_time = 0; for (int i = 0; i &lt; LOOP_COUNT; ++i) { tot_time += test(s, p, &amp;pos); } cout &lt;&lt; &quot;Loop count: &quot; &lt;&lt; LOOP_COUNT &lt;&lt; endl; cout &lt;&lt; &quot;Source string length: &quot; &lt;&lt; s.length() &lt;&lt; endl; cout &lt;&lt; &quot;Pattern string length: &quot; &lt;&lt; p.length() &lt;&lt; endl; cout &lt;&lt; &quot;Search result: &quot; &lt;&lt; pos &lt;&lt; endl; cout &lt;&lt; &quot;Time: &quot; &lt;&lt; tot_time / LOOP_COUNT &lt;&lt; &quot; ms&quot; &lt;&lt; endl; return 0;} C++ - test_strstr.cpp123456789101112131415161718192021222324252627282930313233343536373839#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#define LOOP_COUNT (1000)using namespace std;using std::chrono::high_resolution_clock;using std::chrono::duration_cast;using std::chrono::duration;using std::chrono::milliseconds;char s[1000005], p[1005], *pos=NULL;double test(char* s, char* p, char** pos_ptr) { auto t1 = high_resolution_clock::now(); *pos_ptr = strstr(s, p); auto t2 = high_resolution_clock::now(); duration&lt;double, milli&gt; ms_double = t2 - t1; return ms_double.count();}int main() { ifstream srcfile(&quot;source.in&quot;); ifstream patfile(&quot;pattern.in&quot;); srcfile &gt;&gt; s; patfile &gt;&gt; p; double tot_time = 0; for (int i = 0; i &lt; LOOP_COUNT; ++i) { tot_time += test(s, p, &amp;pos); } cout &lt;&lt; &quot;Loop count: &quot; &lt;&lt; LOOP_COUNT &lt;&lt; endl; cout &lt;&lt; &quot;Source string length: &quot; &lt;&lt; strlen(s) &lt;&lt; endl; cout &lt;&lt; &quot;Pattern string length: &quot; &lt;&lt; strlen(p) &lt;&lt; endl; cout &lt;&lt; &quot;Search result: &quot; &lt;&lt; pos - s &lt;&lt; endl; cout &lt;&lt; &quot;Time: &quot; &lt;&lt; tot_time / LOOP_COUNT &lt;&lt; &quot; ms&quot; &lt;&lt; endl; return 0;} C++ - test_kmp.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#define LOOP_COUNT (1000)using namespace std;using std::chrono::high_resolution_clock;using std::chrono::duration_cast;using std::chrono::duration;using std::chrono::milliseconds;int dp[1005];int KMP(string s, string p) { int m = s.length(), n = p.length(); if (n == 0) return 0; if (m &lt; n) return -1; memset(dp, 0, sizeof(int) * (n+1)); for (int i = 1; i &lt; n; ++i) { int j = dp[i+1]; while (j &gt; 0 &amp;&amp; p[j] != p[i]) j = dp[j]; if (j &gt; 0 || p[j] == p[i]) dp[i+1] = j + 1; } for (int i = 0, j = 0; i &lt; m; ++i) if (s[i] == p[j]) { if (++j == n) return i - j + 1; } else if (j &gt; 0) { j = dp[j]; --i; } return -1;}double test(string s, string p, int* pos_ptr) { auto t1 = high_resolution_clock::now(); *pos_ptr = KMP(s, p); auto t2 = high_resolution_clock::now(); duration&lt;double, milli&gt; ms_double = t2 - t1; return ms_double.count();}int main() { string s, p; int pos; ifstream srcfile(&quot;source.in&quot;); ifstream patfile(&quot;pattern.in&quot;); srcfile &gt;&gt; s; patfile &gt;&gt; p; double tot_time = 0; for (int i = 0; i &lt; LOOP_COUNT; ++i) { tot_time += test(s, p, &amp;pos); } cout &lt;&lt; &quot;Loop count: &quot; &lt;&lt; LOOP_COUNT &lt;&lt; endl; cout &lt;&lt; &quot;Source string length: &quot; &lt;&lt; s.length() &lt;&lt; endl; cout &lt;&lt; &quot;Pattern string length: &quot; &lt;&lt; p.length() &lt;&lt; endl; cout &lt;&lt; &quot;Search result: &quot; &lt;&lt; pos &lt;&lt; endl; cout &lt;&lt; &quot;Time: &quot; &lt;&lt; tot_time / LOOP_COUNT &lt;&lt; &quot; ms&quot; &lt;&lt; endl; return 0;} 结果IPython 的 %timeit 魔法命令可以输出代码多次执行的平均时间和标准差，在此取平均时间。C++ 的代码对每个模式串固定运行 1,000 次后取平均时间。 以下时间若无特别说明，均以微秒为单位，保留到整数位。 场景 模式串出现位置 Python C++ - test.cpp C++ - test_strstr.cpp C++ - test_kmp.cpp 场景 1 250,000 105 523 155 2564 场景 1 500,000 183 1053 274 3711 场景 1 750,000 291 1589 447 4900 场景 2 750,000 2630* 618 353 3565 * 原输出为“2.63 ms”。IPython 的 %timeit 输出的均值保留 3 位有效数字，由于此时间已超过 1 毫秒，微秒位被舍弃。此处仍以微秒作单位，数值记为“2630”。 局限性本次实测时使用的设备硬件上劣于算法竞赛中的标准配置机器，实测结果中的“绝对数值”参考性较低。 总结根据上表中的结果，在给定环境和相关参数条件下，场景 1 中 Python 的运行时间大约为 C++ 中 string::find 的五分之一，与 std:strstr 接近；而在场景 2 中 Python 的运行时间明显增长，但 C++ 的前两种测试方法的运行时间与先前接近甚至更短。四次测试中，C++ 的用户实现的 KMP 算法运行时间均较长，长于同条件下 Python 的情况。 Python 中的内置类型 str 的快速查找（.find()）和计数（.count()）算法基于 Boyer-Moore 算法和 Horspool 算法的混合，其中后者是前者的简化，而前者与 Knuth-Morris-Pratt 算法有关。 有关 C++ 的 string::find 比 std::strstr 运行时间长的相关情况，参见 Bug 66414 - string::find ten times slower than strstr。 值得关注的是：C++ 中自行实现的 KMP 算法的运行时间竟然远长于 C++ 标准库甚至 Python 中的算法。这也类似于常说的“自己设计汇编代码运行效率低于编译器”的情况。Stack Overflow 的一个问题 strstr faster than algorithms? 下有人回答如下： Why do you think strstr should be slower than all the others? Do you know what algorithm strstr uses? I think it’s quite likely that strstr uses a fine-tuned, processor-specific, assembly-coded algorithm of the KMP type or better. In which case you don’t stand a chance of out-performing it in C for such small benchmarks. KMP 算法并非是所有线性复杂度算法中最快的。在不同的环境（软硬件、测试数据等）下，KMP 与其变种乃至其他线性复杂度算法，孰优孰劣都无法判断。编译器在设计时考虑到诸多可能的因素，尽可能使不同环境下都能有相对较优的策略来得到结果。因而，在保证结果正确的情况下，与其根据算法原理自行编写，不如直接使用标准库中提供的函数。 同时本次实测也在运行时间角度再次印证 Python 并不适合在算法竞赛中取得高成绩的说法。 参考 https://stackoverflow.com/questions/22387586/measuring-execution-time-of-a-function-in-c https://www.cplusplus.com/reference/string/string/find/ https://stackoverflow.com/questions/681649/how-is-string-find-implemented-in-cpython https://github.com/python/cpython/blob/main/Objects/stringlib/fastsearch.h#L5 https://stackoverflow.com/questions/8869605/c-stringfind-complexity https://stackoverflow.com/questions/19506571/can-it-be-faster-to-find-the-minimum-periodic-string-inside-another-string-in-te https://gcc.gnu.org/onlinedocs/gcc-9.4.0/libstdc++/api/a17342_source.html https://opensource.apple.com/source/tcl/tcl-10/tcl/compat/strstr.c.auto.html https://gist.github.com/hsinewu/44a1ce38a1baf47893922e3f54807713 https://stackoverflow.com/questions/11799956/performance-comparison-strstr-vs-stdstringfind https://stackoverflow.com/questions/7586990/strstr-faster-than-algorithms https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66414 http://0x80.pl/notesen/2016-10-08-slow-std-string-find.html","link":"/techdev/python-cpp-string-find-perf-test/"},{"title":"【Python|RPG】Continuous Infinity制作实录 - EP.1 框架","text":"我们这次将开始利用Python制作一款简易的TRPG，名字在很久以前已经想好——《Continuous Infinity》，这个名字出自刚立项时的想法——最终实现自动生成无限多的关卡。 我们这次将开始利用Python制作一款简易的TRPG，名字在很久以前已经想好——《Continuous Infinity》，这个名字出自刚立项时的想法——最终实现自动生成无限多的关卡。 为了使本文简洁明了，这个系列就不废话了 (希望如此) 。 Part I. 规划从总体上看整个游戏流程，应该可以分成以下几步： 主页：进行游戏配置，选择进入或退出游戏； 主体：游戏主体部分，项目的核心； 接受玩家操作，产生效果； 检查是否达到退出条件； 程序作出操作，产生效果； 检查是否达到退出条件； 退出游戏或回到1.。 游戏的主要形式即是玩家操纵角色与其他角色 (程序控制的敌人) 进行对战，互相攻击对方，直至一方血量归零，触发事件，执行后续操作——玩家死亡结算、敌方给出新角色、进入下一关等。由此可以归纳出游戏时需要定义的“具体事物”有角色 (mob) 、物品 (item) (包括装备、道具) 、技能 (skill) 等，稍抽象一点的是关卡 (level) (需要定义每个关卡的敌方角色的各种信息) 。 Part II. 源码结构继而我们可以给出如下的源码结构作为参考： 1234567891011121314151617181920212223.│ run.py│├─game│ │ system.py│ ││ ├─data│ │ ├─items│ │ ├─levels│ │ ├─mobs│ │ └─skills│ ├─generator│ │ levels.py│ ││ ├─loader│ │ items.py│ │ levels.py│ │ mobs.py│ │ skills.py│ ││ └─locales└─test .keep 其中run.py是游戏启动的脚本；test文件夹存放单元测试的相关内容；game文件夹存放本游戏的主体内容，包括游戏的绝大多数逻辑、上文所说的具体事物的定义和设计等；game/data文件夹存放的即是所谓的“设计”；game/generator文件夹存放游戏的生成器，用以自定义一系列具体事物以及其自动生成算法；game/loader文件夹存放游戏的加载器，用以读取game/data定义的内容；game/locales文件夹存放游戏的多语言文件 (锦上添花而已，不重要) 。 Part III. 具体事物的信息存储和对战系统逻辑前文提到了对战系统的主要形式是回合制，而较为精细的逻辑则需要涉及到一些具体事物的“使用——生效”机制。当开始某个角色 (不论是玩家还是敌方角色) 的回合时，这个角色可以选择出招 (skill) ，也可以选择使用道具 (item) 增益己方或损害对方，亦可以临时装备一些物品 (item)，或是执行系统级操作——逃跑 (假设未来某天加入游戏中) 、投降 (同上) 、退出当前对局等。不过其中需要伤点脑子的是如何有效地存储一些具体事物的各种信息，以及如何让具体事物在对战时产生效果。 在早期的设计过程中，笔者写出了如下的代码来存储角色的信息： 123456789101112131415161718192021class Mob(object): # Player and enemy def __init__(self, type, name, lvl, exp, hp, pp, hpm, ppm, atk, dfd, spd, pack, coin, skill, weapon, helmet, chestplate, leggings, boots): self.type = type # 类型（职业） self.name = name # 名字 self.lvl = lvl # 等级 self.exp = exp # 经验值 self.hp = hp # 血量 self.pp = pp # 技能点 self.hpm = hpm # 血量上限 self.ppm = ppm # 技能点上限 self.atk = atk # 攻击力 self.dfd = dfd # 防御力 self.spd = spd # 迅捷度 self.pack = pack # 背包列表 self.coin = coin # 金钱 self.skill = skill # 技能列表 self.weapon = weapon # 武器 self.helmet = helmet # 头盔 self.chestplate = chestplate # 胸甲 self.leggings = leggings # 腿甲 self.boots = boots # 靴子 原来的代码中其实连中文注释都没有。但即便按照PEP 8进行格式化，加上了详细的注释，又添上了“docstring”，这段代码依然冗长，而且在定义一个角色的时候需要在参数中加上大量的None，十分不便。这是笔者联想到requests模块的get函数，get函数支持添加许多参数，但模块作者采用了一个较为聪明的方法： 1234567891011In [2]: requests.get?Signature: requests.get(url, params=None, **kwargs)Docstring:Sends a GET request.:param url: URL for the new :class:`Request` object.:param params: (optional) Dictionary, list of tuples or bytes to send in the body of the :class:`Request`.:param \\*\\*kwargs: Optional arguments that ``request`` takes.:return: :class:`Response &lt;Response&gt;` object:rtype: requests.Response 因而我们也可以让定义者显式地传入一个角色的个性化参数，如果没有给出就保持默认值，这样可以极好地便利游戏数据设计者。同时这样的设计可以在形式上将一个角色的所有信息平权，作为“字典型”参数传入时，没有明显的次序之分，总体上是优雅和谐的。 而对于产生效果的方法，一个问题是如何选择目标角色。一项技能和一个物品发挥作用，其目标可以是使用者自身，也可以是己方或对方所有角色，甚至是让使用者自选角色乃至随机角色。为了适应多种需求，我们可以借鉴游戏《Minecraft》上“目标选择器”的机制——利用简单的语法形成的字符串来选择目标。而第二个问题是施加效果，如果便利游戏数据设计者，可以封死自定义复杂函数的通道，只提供一个简单的列表保证一些必要数据 (譬如血量、技能点、装备、物品数量) 的增减；而如果提供充分的自由度，我们可以允许游戏数据设计者向loader提供一个含有指定接口的函数，loader只需利用提供的接口执行更复杂的操作即可。如果为了“双赢”，可以同时实现这两种方式，当然这样的话最累的就是游戏设计者 (其实就是笔者) 。 【完】","link":"/techdev/continuous-infinity/ep-1/"},{"title":"【Python|RPG】Continuous Infinity制作实录 - EP.2 游戏大厅界面","text":"这一期我们准备建设比较粗犷的部分——游戏大厅界面，这部分的代码对应源代码中 run.py 的部分。 这一期我们准备建设比较粗犷的部分——游戏大厅界面，这部分的代码对应源代码中 run.py 的部分。为了不让以前的代 (shi) 码 (shan) 影响我们的思路，现在笔者将旧的代码全部删去。 照例先起个头，装作“万事开头难”的“开头”已经结束了 (自欺欺人+1) ： src/run.py12345678910# -*- coding: utf-8 -*-&quot;&quot;&quot; Project: Continuous Infinity File: src/run.py Author: Little_Ye233 Created: 2021-07-05 Description: Main run shell.&quot;&quot;&quot; Part I. 欢迎界面除去初始化的等待界面，玩家游玩游戏见到的第一个界面多半就是游戏大厅界面了，这也很大程度上决定了玩家的第一印象。不过我们这里只是简单的制作一个可以称得上 TRPG 的东西，所以也没必要搞那么多花里胡哨的，直接上一个简朴的界面： src/game/system/scenes/lobby.py12345678910111213141516171819# -*- coding: utf-8 -*-&quot;&quot;&quot; Project: Continuous Infinity File: src/game/system/scenes/lobby.py Author: Little_Ye233 Created: 2021-07-05 Description: Game algorithms of lobby scene.&quot;&quot;&quot;from ..constants import *class Lobby(object): @staticmethod def show(): print(SYSTEM_SCENES_LOBBY_WELCOME) src/game/system/constants.py123456789101112131415161718192021# -*- coding: utf-8 -*-&quot;&quot;&quot; Project: Continuous Infinity File: src/game/system/constants.py Author: Little_Ye233 Created: 2021-07-05 Description: Definitions of game constants.&quot;&quot;&quot;# Systemversion = '0.1.0' # Literal stringsSYSTEM_SCENES_LOBBY_WELCOME = f'''\\-*-*- Continuous Infinity -*-*--*- Ver {version} -*--*- Author: Little_Ye233 -*-''' 嗯嗯嗯？！为什么多了个 lobby.py 和 constants.py ？还有原来的 system.py 为什么变成了一个同名的文件夹？ 其实这个是笔者先前开发项目时的常有情况——每每做出了一定的规划，最后总会在某个地方需要修改原先的架构。这里也是模仿当时的情况做出的——在实际情况下考虑到单个文件 system.py 放置所有的逻辑可能会导致文件过于冗杂，故分离出多个子文件 (夹) 。其实这里我还埋伏了一手，就是 constants.py 。我们看到这里定义常量的时候我的命名方式是“源文件名 (下划线作文件路径分隔符) +其他标识符”，这也是一种冗长的写法，但笔者先暂时这么写，如果后期发现其他方式命名起来更容易，就尝试进一步修改。 先看这里的 src/game/system/constants.py 定义的内容。第一段 System 下定义的是版本号，变量名定义采用了许多著名模块中的 version (这里注意到变量名称是全部小写) 模块级变量定义方式，其中的字符串遵循“Semantic Versioning” (语义化版本) 中的规定。第二段下定义了一个游戏大厅的欢迎界面，注意到这里利用了 Python 3.6 下引入的字符串格式化输出方式“f-string”。 Part II. 选项有了欢迎界面自然也要有选择的部分。选项的设计可以有简单的两种：第一种是给出所有可选项并标号，玩家自行输入标号；第二种是给出所有可选项，玩家通过方向键控制高亮选项。当然这两种也可以继续细分，实现选项的方式也不止这两种，甚至可以几种方式结合。我们这里为了简便，就采用第一种方式——不过看起来可能比较复杂就是了： src/game/system/scenes/lobby.py1234567891011121314from ..widgets import Optionsclass Lobby: @staticmethod def show(): print(LOBBY_WELCOME) cmd = Options(0, [ START_GAME, SELECT_LEVEL, SETTINGS, CREDITS, EXIT_GAME ]).show() 这是 src/game/system/scenes/lobby.py 的一部分定义。明显发现原来很长的常量名变成了直接表义的名字 LOBBY_WELCOME ，一方面是因为实在太长打起来很累 (终于悔改了) ，另一方面是因为使用只表义但不包含文件路径信息的记法便于在不同位置使用相同的字符串 (比如可能很多地方都会用到“开始游戏”之内的字符串) 。而这里我们又引入了一个新的概念 (坑) ——组件 (Widget) ，以将游戏设计中出现的各种小程序片段统一化。这里我们构造出了第一种组件——选项 (Options) ，来为玩家提供一个简单的选择系统。对于实现的细节我们先按下不表，只需能大致了解它实现出的效果即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374In [1]: from src.game.system.widgets import OptionsIn [2]: cmd = Options('0', ['Option 1', 'Option 2', 'Option 3']).show()---------------------------------------------------------------------------ValueError Traceback (most recent call last)&lt;ipython-input-2-6f1c48425fd6&gt; in &lt;module&gt;----&gt; 1 cmd = Options('0', ['Option 1', 'Option 2', 'Option 3']).show()~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/main.py in __init__(self, style, *params) 38 # CAUTIONS: now `style` can be 0 only 39 if style not in self._avail_style:---&gt; 40 raise ValueError(f'style ID {style} is unavailable') 41 42 self.style = styleValueError: style ID 0 is unavailableIn [3]: cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()Choices:(1) Option 1(2) Option 2(3) Option 3Please choose: a---------------------------------------------------------------------------ValueError Traceback (most recent call last)&lt;ipython-input-3-c0fc1f068dc0&gt; in &lt;module&gt;----&gt; 1 cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/main.py in show(self) 51 'src.game.system.widgets.options.styles' 52 )---&gt; 53 return style.Style.show(*self.params)~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/styles/style0.py in show(*params) 22 s = input('Please choose: ') 23 if not s.isdigit() or int(s) == 0 or int(s) &gt; len(choices):---&gt; 24 raise ValueError(f'invalid input value: {s}') 25 return int(s)ValueError: invalid input value: aIn [4]: cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()Choices:(1) Option 1(2) Option 2(3) Option 3Please choose: 0---------------------------------------------------------------------------ValueError Traceback (most recent call last)&lt;ipython-input-4-c0fc1f068dc0&gt; in &lt;module&gt;----&gt; 1 cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/main.py in show(self) 51 'src.game.system.widgets.options.styles' 52 )---&gt; 53 return style.Style.show(*self.params)~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/styles/style0.py in show(*params) 22 s = input('Please choose: ') 23 if not s.isdigit() or int(s) == 0 or int(s) &gt; len(choices):---&gt; 24 raise ValueError(f'invalid input value: {s}') 25 return int(s)ValueError: invalid input value: 0In [5]: cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()Choices:(1) Option 1(2) Option 2(3) Option 3Please choose: 1In [6]: cmdOut[6]: 1 这里我们可以看到， Options 类能够根据给定参数产生一个实例，而这个实例的 show 方法则能在默认输出设备——也就是终端 (terminal) ——其实这里我预感没有加上 IO 设备的参数后期会出麻烦，但现在暂时先这么写着。然后如果交互过程没有异常的话，这个方法会将玩家选择的选项的编号 (在当前的 style 中，必定为一个正整数) 作为返回值。依此我们可以编写出如下的游戏大厅页面场景 (scene) 代码： src/game/system/scenes/lobby.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546from ..constants import *from ..widgets import Optionsdef start_game(): print('start_game: Not implemented yet!')def select_level(): print('select_level: Not implemented yet!')def settings(): print('settings: Not implemented yet!')def show_credits(): print(CREDITS_MSG)def exit_game(): print(LOBBY_EXIT) exit(0)actions = [None, start_game, select_level, settings, show_credits, exit_game]class Lobby: @staticmethod def show(): print(LOBBY_WELCOME) while True: try: cmd = Options(0, [ START_GAME, SELECT_LEVEL, SETTINGS, CREDITS, EXIT_GAME ]).show() except ValueError: # wrong `cmd` print() print(WRONG_CMD) else: print() actions[cmd]() print() 一些常量的定义暂时忽略。最终能得到如下的测试结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ python src/run.py-*-*- Continuous Infinity -*-*--*- Ver 0.1.0 -*--*- Author: Little_Ye233 -*-Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 0Got a wrong choice. Please try again.Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 1start_game: Not implemented yet!Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 2select_level: Not implemented yet!Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 3settings: Not implemented yet!Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 4-*-*- Credits -*-*-Author: Little_Ye233Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 5Goodbye! 【完】","link":"/techdev/continuous-infinity/ep-2/"},{"title":"【文件格式探究】EP.1 对ePub文件格式的初探","text":"这是“文件格式探究”专题的第 1 期——初探 “ePub” 文件格式。 这是“文件格式探究”专题的第 1 期——初探 “ePub” 文件格式。这个专题将会给各位读者呈现笔者探索各种文件格式的过程，具体则是文件的内容是如何呈现出来的。原则上我们假定仅对于这些文件格式的用途有所了解，但具体实现的细节并不清楚 (如果提前掌握了部分内容，笔者全当其不存在) 。探究过程中我们会尝试使用各种方法来逐渐初步掌握其概貌。 文件格式简介根据维基百科大陆简体版本的相关描述： EPub 是一个自由的开放标准，属于一种可以“自动重新排版”的内容；也就是文字内容可以根据阅读设备的特性，以最适于阅读的方式显示。 之所以后面不截是因为再截就剧透了。简单来说，ePub 就是类似于 PDF 那样的“文档型”文件格式，常用于分发电子读物等。 探究过程环境现在笔者手头上有一份用于测试的 ePub 文件，文件路径为 ~/Downloads/咖啡馆推理事件簿系列（全四本）.epub (趁机夹带私货，反正很合我胃口就是了) ，后续所有的探究活动均建立于此文件上。笔者目前的操作系统环境为 Manjaro 21.1.0 on amd64，终端环境为 GNU bash 5.1.8(1)-release 。为了方便，我们先把文件改个名字 (那你还把原来的名字给出来干嘛？！) ： 12345[littleye233@lymjrolt Downloads]$ cd ~[littleye233@lymjrolt ~]$ cd Downloads[littleye233@lymjrolt Downloads]$ mv 咖啡馆推理事件簿系列（全四本）.epub test.epub[littleye233@lymjrolt Downloads]$ ll test.epub-rw-r--r-- 1 littleye233 littleye233 1253964 Aug 22 23:24 test.epub Round I. 文件类型首先我们先尝试用 Linux 系统的内置命令 file 试试水，看看会输出什么东西。键入 file test.epub后执行： 12[littleye233@lymjrolt Downloads]$ file test.epubtest.epub: EPUB document EPUB document 哎呀，真可惜！ file 命令几乎什么有效信息都没给我们。 file 命令的 man 页面明确给出此命令可以判断文件格式，但其实它能做到的有很多，例如如果对一个图片文件使用 file ，可能会出现类似下面的结果： 12[littleye233@lymjrolt Downloads]$ file ~/.local/share/osu/screenshots/osu_2021-08-21_23-40-03.png/home/littleye233/.local/share/osu/screenshots/osu_2021-08-21_23-40-03.png: PNG image data, 1920 x 961, 8-bit/color RGBA, non-interlaced 这样我们可以通过 file 中提供的相关信息顺藤摸瓜，尝试在文件的二进制编码内容中寻找其蛛丝马迹，进而推测对应“位点”所表达的含义 (因为一些文件格式要求在特定的位置表达某些含义) ，如果能提供类似注释的信息就再好不过了。 Round II. 文件结构现在我们回到这个 ePub 文件上来。现在我们尝试能否直接获取其内容，目的是通过文件头部的部分可见字符猜测其文件结构。输入 nano test.epub 直接预览，或使用 head --bytes=120 test.epub 查看前面 120 个字节的内容： 123[littleye233@lymjrolt Downloads]$ head --bytes=120 test.epubPK!oa�mimetypeapplication/epub+zipPU�N�;�ʯ�META-INF/container.xml]�A�0E�= 果不其然，我们看到了一些有趣的字眼： “mimetypeapplication/epub+zip” ，凭经验猜测，这应该是 ePub 文件格式的文件头，而其中的 “zip” 也说明—— ePub 文件可能本质上就是一个压缩档。 其实很多文件格式 (例如 Word 文档 “*.docx”) 其本质都是在一个压缩档中加入各种资源文件和配置文件，只要有对应的软件进行读取并重新加工，用户即能看到效果。 Round III. 目录树结构现在我们可以使用解压缩程序解出 ePub 文件中的内容了。在终端中执行 unzip -l test.epub ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778[littleye233@lymjrolt Downloads]$ unzip -l test.epubArchive: test.epub Length Date Time Name--------- ---------- ----- ---- 20 1980-01-01 00:00 mimetype 251 2019-06-27 10:40 META-INF/container.xml 12307 2019-06-27 10:40 OEBPS/content.opf 112368 2019-06-27 10:40 OEBPS/Images/cover00464.jpeg 128680 2019-06-27 10:40 OEBPS/Images/image00456.jpeg 120936 2019-06-27 10:40 OEBPS/Images/image00457.jpeg 1392 2019-06-27 10:40 OEBPS/Images/image00458.jpeg 101948 2019-06-27 10:40 OEBPS/Images/image00459.jpeg 119124 2019-06-27 10:40 OEBPS/Images/image00460.jpeg 1268 2019-06-27 10:40 OEBPS/Images/image00461.jpeg 42944 2019-06-27 10:40 OEBPS/Images/image00462.jpeg 121284 2019-06-27 10:40 OEBPS/Images/image00463.jpeg 2251 2019-06-27 10:40 OEBPS/Styles/style0001.css 9816 2019-06-27 10:40 OEBPS/Styles/style0002.css 2251 2019-06-27 10:40 OEBPS/Styles/style0003.css 9789 2019-06-27 10:40 OEBPS/Styles/style0004.css 2251 2019-06-27 10:40 OEBPS/Styles/style0005.css 29245 2019-06-27 10:40 OEBPS/Styles/style0006.css 2235 2019-06-27 10:40 OEBPS/Styles/style0007.css 29914 2019-06-27 10:40 OEBPS/Styles/style0008.css 2251 2019-06-27 10:40 OEBPS/Styles/style0009.css 624 2019-06-27 10:40 OEBPS/Text/cover_page.xhtml 851 2019-06-27 10:40 OEBPS/Text/part0000.xhtml 561 2019-06-27 10:40 OEBPS/Text/part0001.xhtml 428 2019-06-27 10:40 OEBPS/Text/part0002.xhtml 1518 2019-06-27 10:40 OEBPS/Text/part0003.xhtml 661 2019-06-27 10:40 OEBPS/Text/part0004.xhtml 2311 2019-06-27 10:40 OEBPS/Text/part0005.xhtml 55157 2019-06-27 10:40 OEBPS/Text/part0006.xhtml 58266 2019-06-27 10:40 OEBPS/Text/part0007.xhtml 59953 2019-06-27 10:40 OEBPS/Text/part0008.xhtml 49789 2019-06-27 10:40 OEBPS/Text/part0009.xhtml 66870 2019-06-27 10:40 OEBPS/Text/part0010.xhtml 57342 2019-06-27 10:40 OEBPS/Text/part0011.xhtml 67449 2019-06-27 10:40 OEBPS/Text/part0012.xhtml 16183 2019-06-27 10:40 OEBPS/Text/part0013.xhtml 561 2019-06-27 10:40 OEBPS/Text/part0014.xhtml 428 2019-06-27 10:40 OEBPS/Text/part0015.xhtml 1575 2019-06-27 10:40 OEBPS/Text/part0016.xhtml 496 2019-06-27 10:40 OEBPS/Text/part0017.xhtml 1446 2019-06-27 10:40 OEBPS/Text/part0018.xhtml 52358 2019-06-27 10:40 OEBPS/Text/part0019.xhtml 75746 2019-06-27 10:40 OEBPS/Text/part0020.xhtml 63420 2019-06-27 10:40 OEBPS/Text/part0021.xhtml 57399 2019-06-27 10:40 OEBPS/Text/part0022.xhtml 58590 2019-06-27 10:40 OEBPS/Text/part0023.xhtml 40263 2019-06-27 10:40 OEBPS/Text/part0024.xhtml 66099 2019-06-27 10:40 OEBPS/Text/part0025.xhtml 15143 2019-06-27 10:40 OEBPS/Text/part0026.xhtml 561 2019-06-27 10:40 OEBPS/Text/part0027.xhtml 612 2019-06-27 10:40 OEBPS/Text/part0028.xhtml 1344 2019-06-27 10:40 OEBPS/Text/part0029.xhtml 640 2019-06-27 10:40 OEBPS/Text/part0030.xhtml 6144 2019-06-27 10:40 OEBPS/Text/part0031.xhtml 25197 2019-06-27 10:40 OEBPS/Text/part0032.xhtml 54594 2019-06-27 10:40 OEBPS/Text/part0033.xhtml 87394 2019-06-27 10:40 OEBPS/Text/part0034.xhtml 97557 2019-06-27 10:40 OEBPS/Text/part0035.xhtml 109901 2019-06-27 10:40 OEBPS/Text/part0036.xhtml 17181 2019-06-27 10:40 OEBPS/Text/part0037.xhtml 5238 2019-06-27 10:40 OEBPS/Text/part0038.xhtml 561 2019-06-27 10:40 OEBPS/Text/part0039.xhtml 644 2019-06-27 10:40 OEBPS/Text/part0040.xhtml 1163 2019-06-27 10:40 OEBPS/Text/part0041.xhtml 1473 2019-06-27 10:40 OEBPS/Text/part0042.xhtml 38427 2019-06-27 10:40 OEBPS/Text/part0043.xhtml 90589 2019-06-27 10:40 OEBPS/Text/part0044.xhtml 51278 2019-06-27 10:40 OEBPS/Text/part0045.xhtml 58321 2019-06-27 10:40 OEBPS/Text/part0046.xhtml 29670 2019-06-27 10:40 OEBPS/Text/part0047.xhtml 12903 2019-06-27 10:40 OEBPS/Text/part0048.xhtml 7364 2019-06-27 10:40 OEBPS/toc.ncx--------- ------- 2422768 72 files 同时可以直接解压： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374[littleye233@lymjrolt Downloads]$ unzip test.epub -d test_epubArchive: test.epub extracting: test_epub/mimetype inflating: test_epub/META-INF/container.xml inflating: test_epub/OEBPS/content.opf inflating: test_epub/OEBPS/Images/cover00464.jpeg inflating: test_epub/OEBPS/Images/image00456.jpeg inflating: test_epub/OEBPS/Images/image00457.jpeg inflating: test_epub/OEBPS/Images/image00458.jpeg inflating: test_epub/OEBPS/Images/image00459.jpeg inflating: test_epub/OEBPS/Images/image00460.jpeg inflating: test_epub/OEBPS/Images/image00461.jpeg inflating: test_epub/OEBPS/Images/image00462.jpeg inflating: test_epub/OEBPS/Images/image00463.jpeg inflating: test_epub/OEBPS/Styles/style0001.css inflating: test_epub/OEBPS/Styles/style0002.css inflating: test_epub/OEBPS/Styles/style0003.css inflating: test_epub/OEBPS/Styles/style0004.css inflating: test_epub/OEBPS/Styles/style0005.css inflating: test_epub/OEBPS/Styles/style0006.css inflating: test_epub/OEBPS/Styles/style0007.css inflating: test_epub/OEBPS/Styles/style0008.css inflating: test_epub/OEBPS/Styles/style0009.css inflating: test_epub/OEBPS/Text/cover_page.xhtml inflating: test_epub/OEBPS/Text/part0000.xhtml inflating: test_epub/OEBPS/Text/part0001.xhtml inflating: test_epub/OEBPS/Text/part0002.xhtml inflating: test_epub/OEBPS/Text/part0003.xhtml inflating: test_epub/OEBPS/Text/part0004.xhtml inflating: test_epub/OEBPS/Text/part0005.xhtml inflating: test_epub/OEBPS/Text/part0006.xhtml inflating: test_epub/OEBPS/Text/part0007.xhtml inflating: test_epub/OEBPS/Text/part0008.xhtml inflating: test_epub/OEBPS/Text/part0009.xhtml inflating: test_epub/OEBPS/Text/part0010.xhtml inflating: test_epub/OEBPS/Text/part0011.xhtml inflating: test_epub/OEBPS/Text/part0012.xhtml inflating: test_epub/OEBPS/Text/part0013.xhtml inflating: test_epub/OEBPS/Text/part0014.xhtml inflating: test_epub/OEBPS/Text/part0015.xhtml inflating: test_epub/OEBPS/Text/part0016.xhtml inflating: test_epub/OEBPS/Text/part0017.xhtml inflating: test_epub/OEBPS/Text/part0018.xhtml inflating: test_epub/OEBPS/Text/part0019.xhtml inflating: test_epub/OEBPS/Text/part0020.xhtml inflating: test_epub/OEBPS/Text/part0021.xhtml inflating: test_epub/OEBPS/Text/part0022.xhtml inflating: test_epub/OEBPS/Text/part0023.xhtml inflating: test_epub/OEBPS/Text/part0024.xhtml inflating: test_epub/OEBPS/Text/part0025.xhtml inflating: test_epub/OEBPS/Text/part0026.xhtml inflating: test_epub/OEBPS/Text/part0027.xhtml inflating: test_epub/OEBPS/Text/part0028.xhtml inflating: test_epub/OEBPS/Text/part0029.xhtml inflating: test_epub/OEBPS/Text/part0030.xhtml inflating: test_epub/OEBPS/Text/part0031.xhtml inflating: test_epub/OEBPS/Text/part0032.xhtml inflating: test_epub/OEBPS/Text/part0033.xhtml inflating: test_epub/OEBPS/Text/part0034.xhtml inflating: test_epub/OEBPS/Text/part0035.xhtml inflating: test_epub/OEBPS/Text/part0036.xhtml inflating: test_epub/OEBPS/Text/part0037.xhtml inflating: test_epub/OEBPS/Text/part0038.xhtml inflating: test_epub/OEBPS/Text/part0039.xhtml inflating: test_epub/OEBPS/Text/part0040.xhtml inflating: test_epub/OEBPS/Text/part0041.xhtml inflating: test_epub/OEBPS/Text/part0042.xhtml inflating: test_epub/OEBPS/Text/part0043.xhtml inflating: test_epub/OEBPS/Text/part0044.xhtml inflating: test_epub/OEBPS/Text/part0045.xhtml inflating: test_epub/OEBPS/Text/part0046.xhtml inflating: test_epub/OEBPS/Text/part0047.xhtml inflating: test_epub/OEBPS/Text/part0048.xhtml inflating: test_epub/OEBPS/toc.ncx 为了更清楚地显示文件树结构，我们也可以使用 tree 命令 (这个命令在 Windows 中是内置的，在 Linux 中需要安装 tree 这个包，使用软件包管理器或编译安装均可) ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081[littleye233@lymjrolt test_epub]$ tree.├── META-INF│ └── container.xml├── mimetype└── OEBPS ├── content.opf ├── Images │ ├── cover00464.jpeg │ ├── image00456.jpeg │ ├── image00457.jpeg │ ├── image00458.jpeg │ ├── image00459.jpeg │ ├── image00460.jpeg │ ├── image00461.jpeg │ ├── image00462.jpeg │ └── image00463.jpeg ├── Styles │ ├── style0001.css │ ├── style0002.css │ ├── style0003.css │ ├── style0004.css │ ├── style0005.css │ ├── style0006.css │ ├── style0007.css │ ├── style0008.css │ └── style0009.css ├── Text │ ├── cover_page.xhtml │ ├── part0000.xhtml │ ├── part0001.xhtml │ ├── part0002.xhtml │ ├── part0003.xhtml │ ├── part0004.xhtml │ ├── part0005.xhtml │ ├── part0006.xhtml │ ├── part0007.xhtml │ ├── part0008.xhtml │ ├── part0009.xhtml │ ├── part0010.xhtml │ ├── part0011.xhtml │ ├── part0012.xhtml │ ├── part0013.xhtml │ ├── part0014.xhtml │ ├── part0015.xhtml │ ├── part0016.xhtml │ ├── part0017.xhtml │ ├── part0018.xhtml │ ├── part0019.xhtml │ ├── part0020.xhtml │ ├── part0021.xhtml │ ├── part0022.xhtml │ ├── part0023.xhtml │ ├── part0024.xhtml │ ├── part0025.xhtml │ ├── part0026.xhtml │ ├── part0027.xhtml │ ├── part0028.xhtml │ ├── part0029.xhtml │ ├── part0030.xhtml │ ├── part0031.xhtml │ ├── part0032.xhtml │ ├── part0033.xhtml │ ├── part0034.xhtml │ ├── part0035.xhtml │ ├── part0036.xhtml │ ├── part0037.xhtml │ ├── part0038.xhtml │ ├── part0039.xhtml │ ├── part0040.xhtml │ ├── part0041.xhtml │ ├── part0042.xhtml │ ├── part0043.xhtml │ ├── part0044.xhtml │ ├── part0045.xhtml │ ├── part0046.xhtml │ ├── part0047.xhtml │ └── part0048.xhtml └── toc.ncx5 directories, 72 files Round IV. 内部文件到这里我们大概就能猜出来： META-INF 文件夹：里面存放的应该是“容器” (也就是这个 ePub 文件) 的相关配置文件； mimetype 文件：里面定义了这个文件的类型为 “ePub” (其中 “MIME” 是 “Multipurpose Internet Mail Extensions” 的缩写，从字面上也能看出其具有指示 “Extension” 的机能) ； OEBPS 文件夹：虽暂不知其确切含义，但应存放 ePub 的文字、图片以及其他的界面数据； content.opf 文件：里面存放的应该是目录信息——或是定义各种文件的“次序”； Images Styles 和 Text 文件夹：明显分别存放图片、层叠样式表和文字数据； toc.ncx 文件：可能是真正的目录 (“toc” 是 “table of contents” 的缩写)。 接下来我们将挨个分析。 Round IV.I. 容器先看 META-INF/container.xml ： 12[littleye233@lymjrolt test_epub]$ file META-INF/container.xmlMETA-INF/container.xml: XML 1.0 document, ASCII text 输出其内容： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&gt; &lt;rootfiles&gt;&lt;rootfile full-path=&quot;OEBPS/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&gt; &lt;/rootfiles&gt;&lt;/container&gt; 显然是一个标准的 XML 文件，其中我们可以注意到 /container/rootfiles/rootfile[@class='full-path'][^1] 中定义了一个我们之前认定的目录文件，但此处可以规范化，故这个文件在大多数 ePub 档中应该是相同的。 Round IV.II. 文件类型定性接下来看 mimetype 文件： 12[littleye233@lymjrolt test_epub]$ cat mimetypeapplication/epub+zip 这也是相当显然的，也不再赘述。 Round IV.III. 目录？再看 OEBPS/content.opf ： 12[littleye233@lymjrolt test_epub]$ file OEBPS/content.opfOEBPS/content.opf: XML 1.0 document, Unicode text, UTF-8 text, with very long lines (504) 这也是一个 XML 文件，令人惊讶的是 file 命令竟能看出这个文件中最长的行有 504 个字符，属实让人害怕。 点此查看 `OEBPS/content.opf` 的全部内容 (已经过格式化) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;package xmlns=&quot;http://www.idpf.org/2007/opf&quot; version=&quot;2.0&quot; unique-identifier=&quot;uid&quot;&gt; &lt;metadata xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:opf=&quot;http://www.idpf.org/2007/opf&quot;&gt; &lt;dc:title opf:file-as=&quot;kafeiguantuilishijianbuxilie（quansiben）&quot;&gt;咖啡馆推理事件簿系列（全四本）&lt;/dc:title&gt; &lt;dc:language&gt;zh&lt;/dc:language&gt; &lt;dc:identifier id=&quot;uid&quot;&gt;3899198450&lt;/dc:identifier&gt; &lt;dc:creator opf:file-as=&quot;（ri）gangqizuomo&quot;&gt;（日）冈崎琢磨&lt;/dc:creator&gt; &lt;dc:date opf:event=&quot;publication&quot;&gt;2018-03-15&lt;/dc:date&gt; &lt;!-- Extra MetaData from RESC&lt;dc:coverage/&gt;--&gt; &lt;meta name=&quot;cover&quot; content=&quot;x_cover-image&quot;/&gt; &lt;meta name=&quot;output encoding&quot; content=&quot;utf-8&quot;/&gt; &lt;meta name=&quot;primary-writing-mode&quot; content=&quot;horizontal-lr&quot;/&gt; &lt;!-- BEGIN INFORMATION ONLY&lt;meta name=&quot;Cover ThumbNail Image&quot; content=&quot;Images/image00466.jpeg&quot; /&gt;&lt;meta name=&quot;Drm Ebookbase Book Id&quot; content=&quot;0006008690412&quot; /&gt;&lt;meta name=&quot;ASIN&quot; content=&quot;B07BFTVX98&quot; /&gt;&lt;meta name=&quot;Creator-Software&quot; content=&quot;201&quot; /&gt;&lt;meta name=&quot;Author-Pronunciation&quot; content=&quot;（ri）gangqizuomo&quot; /&gt;&lt;meta name=&quot;Embedded-Record-Count&quot; content=&quot;11&quot; /&gt;&lt;meta name=&quot;Unknown_(403)_(hex)&quot; content=&quot;00&quot; /&gt;&lt;meta name=&quot;HasFakeCover&quot; content=&quot;0&quot; /&gt;&lt;meta name=&quot;Creator-Major-Version&quot; content=&quot;2&quot; /&gt;&lt;meta name=&quot;cdeType&quot; content=&quot;EBOK&quot; /&gt;&lt;meta name=&quot;override-kindle-fonts&quot; content=&quot;false&quot; /&gt;&lt;meta name=&quot;CDEContentKey&quot; content=&quot;B07BFTVX98&quot; /&gt;&lt;meta name=&quot;Compression-Upgraded&quot; content=&quot;Source-Target:c1-c2 KT_Version:2.9 Build:0805-4a0c57c&quot; /&gt;&lt;meta name=&quot;HD-Media-Containers-Info&quot; content=&quot;2400x3840:0-11|&quot; /&gt;&lt;meta name=&quot;548 (hex)&quot; content=&quot;496e4d656d6f7279&quot; /&gt;&lt;meta name=&quot;Unknown_(407)_(hex)&quot; content=&quot;0000000000000000&quot; /&gt;&lt;meta name=&quot;Amazon_Creator_Info&quot; content=&quot;kjw&quot; /&gt;&lt;meta name=&quot;Clipping-Limit&quot; content=&quot;100&quot; /&gt;&lt;meta name=&quot;Tamper-Proof-Keys_(hex)&quot; content=&quot;01000000d000000001940000000191000000019500000001960000000197&quot; /&gt;&lt;meta name=&quot;Title-Pronunciation&quot; content=&quot;kafeiguantuilishijianbuxilie（quansiben）&quot; /&gt;&lt;meta name=&quot;Creator-Minor-Version&quot; content=&quot;9&quot; /&gt;&lt;meta name=&quot;MetadataResourceURI&quot; content=&quot;kindle:embed:000A&quot; /&gt;&lt;meta name=&quot;Updated_Title&quot; content=&quot;咖啡馆推理事件簿系列（全四本）&quot; /&gt;&lt;meta name=&quot;Ownership-Type_(hex)&quot; content=&quot;00&quot; /&gt;&lt;meta name=&quot;547 (hex)&quot; content=&quot;496e4d656d6f7279&quot; /&gt;&lt;meta name=&quot;Content-Language-Tag&quot; content=&quot;zh&quot; /&gt;&lt;meta name=&quot;sample&quot; content=&quot;0&quot; /&gt;&lt;meta name=&quot;Metadata-Record-Offset&quot; content=&quot;4294967295&quot; /&gt;&lt;meta name=&quot;Creator-Build-Tag&quot; content=&quot;0721-dedaf5&quot; /&gt;&lt;meta name=&quot;Publisher-Pronunciation&quot; content=&quot;xiandaichubanshe&quot; /&gt;&lt;meta name=&quot;StartOffset&quot; content=&quot;4294967295&quot; /&gt;&lt;meta name=&quot;Watermark_(hex)&quot; content=&quot;6174763a6b696e3a323a49396e41307a4239625565766a514961583462736b66476a394535335a51616a696368585638364447746b65544379504d504c4d75445a35524f39676b584d35515a6433694f424b5531546643766f5a62507763705a6b49486f6f366a6639785944327a4158494263536c495879676b6a38616b566e4763327a2b2b50434c454c464b2b4e30495a4556437a6331516f656f4451546b3865374a6f61696251526d6f682b7574586b3661466a554477704a3165636c68665367414a35664745413a68614f61636b496839662b61786c457733397665774b32554a57453d&quot; /&gt;&lt;meta name=&quot;Text-to-Speech-Disabled&quot; content=&quot;0&quot; /&gt;&lt;meta name=&quot;Font-Signature_(hex)&quot; content=&quot;0300000000480f08100000000000008000200000000000000000000000000000bef4edec01b701d7409440984099409c409d40a64a804c9c608160826080608b60e8618b60cd60c661aa61f361d661e9629c73df0213c9021fd90173cd01429f037e9a037e8c037e81037e9f&quot; /&gt;&lt;meta name=&quot;Rental-Expiration-Time&quot; content=&quot;0000000000000000&quot; /&gt;&lt;meta name=&quot;Container_Id&quot; content=&quot;ZkM0&quot; /&gt;&lt;meta name=&quot;Mobi8-Boundary-Section&quot; content=&quot;420&quot; /&gt;&lt;meta name=&quot;Creator-Build-Number&quot; content=&quot;0&quot; /&gt;END INFORMATION ONLY --&gt; &lt;/metadata&gt; &lt;manifest&gt; &lt;item id=&quot;x_cover&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/cover_page.xhtml&quot;/&gt; &lt;item id=&quot;x_TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0000.xhtml&quot;/&gt; &lt;item id=&quot;x_a1cover.html&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0001.xhtml&quot;/&gt; &lt;item id=&quot;x_a1bookname&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0002.xhtml&quot;/&gt; &lt;item id=&quot;x_a1TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0003.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter001&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0004.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter002&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0005.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter003&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0006.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter004&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0007.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter005&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0008.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter006&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0009.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter007&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0010.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter008&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0011.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter009&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0012.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter010&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0013.xhtml&quot;/&gt; &lt;item id=&quot;x_a2cover.html&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0014.xhtml&quot;/&gt; &lt;item id=&quot;x_a2bookname&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0015.xhtml&quot;/&gt; &lt;item id=&quot;x_a2TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0016.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter001&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0017.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter002&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0018.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter003&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0019.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter004&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0020.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter005&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0021.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter006&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0022.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter007&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0023.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter008&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0024.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter009&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0025.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter010&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0026.xhtml&quot;/&gt; &lt;item id=&quot;x_a3cover.html&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0027.xhtml&quot;/&gt; &lt;item id=&quot;x_a3bookname&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0028.xhtml&quot;/&gt; &lt;item id=&quot;x_a3TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0029.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter001&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0030.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter002&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0031.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter003&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0032.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter004&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0033.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter005&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0034.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter006&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0035.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter007&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0036.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter008&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0037.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter009&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0038.xhtml&quot;/&gt; &lt;item id=&quot;x_a4cover.html&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0039.xhtml&quot;/&gt; &lt;item id=&quot;x_a4bookname&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0040.xhtml&quot;/&gt; &lt;item id=&quot;x_a4TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0041.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter001&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0042.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter002&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0043.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter003&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0044.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter004&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0045.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter005&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0046.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter006&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0047.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter007&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0048.xhtml&quot;/&gt; &lt;item id=&quot;item50&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0001.css&quot;/&gt; &lt;item id=&quot;item51&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0002.css&quot;/&gt; &lt;item id=&quot;item52&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0003.css&quot;/&gt; &lt;item id=&quot;item53&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0004.css&quot;/&gt; &lt;item id=&quot;item54&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0005.css&quot;/&gt; &lt;item id=&quot;item55&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0006.css&quot;/&gt; &lt;item id=&quot;item56&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0007.css&quot;/&gt; &lt;item id=&quot;item57&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0008.css&quot;/&gt; &lt;item id=&quot;item58&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0009.css&quot;/&gt; &lt;item id=&quot;item59&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00456.jpeg&quot;/&gt; &lt;item id=&quot;item60&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00457.jpeg&quot;/&gt; &lt;item id=&quot;item61&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00458.jpeg&quot;/&gt; &lt;item id=&quot;item62&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00459.jpeg&quot;/&gt; &lt;item id=&quot;item63&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00460.jpeg&quot;/&gt; &lt;item id=&quot;item64&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00461.jpeg&quot;/&gt; &lt;item id=&quot;item65&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00462.jpeg&quot;/&gt; &lt;item id=&quot;item66&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00463.jpeg&quot;/&gt; &lt;item id=&quot;x_cover-image&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/cover00464.jpeg&quot;/&gt; &lt;item id=&quot;ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot; href=&quot;toc.ncx&quot;/&gt; &lt;/manifest&gt; &lt;spine toc=&quot;ncx&quot;&gt; &lt;itemref idref=&quot;x_cover&quot; linear=&quot;no&quot;/&gt; &lt;itemref idref=&quot;x_TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1cover.html&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1bookname&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter001&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter002&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter003&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter004&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter005&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter006&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter007&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter008&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter009&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter010&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2cover.html&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2bookname&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter001&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter002&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter003&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter004&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter005&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter006&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter007&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter008&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter009&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter010&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3cover.html&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3bookname&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter001&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter002&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter003&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter004&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter005&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter006&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter007&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter008&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter009&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4cover.html&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4bookname&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter001&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter002&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter003&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter004&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter005&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter006&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter007&quot; linear=&quot;yes&quot;/&gt; &lt;/spine&gt; &lt;tours&gt;&lt;/tours&gt; &lt;guide&gt; &lt;reference type=&quot;text&quot; title=&quot;Start&quot; href=&quot;Text/part0004.xhtml&quot;/&gt; &lt;reference type=&quot;toc&quot; title=&quot;Table of Contents&quot; href=&quot;Text/part0000.xhtml&quot;/&gt; &lt;reference type=&quot;cover&quot; title=&quot;Cover&quot; href=&quot;Text/cover_page.xhtml&quot;/&gt; &lt;/guide&gt;&lt;/package&gt; 说明我之前并没有猜错，这个文件存放的是超越“目录”的东西，而是“次序”——更进一步说。是“索引”。这个文件类似于其他文件格式或目录树中的 index.* ，将 ePub 中的各种数据编上号码，同时这里也定义了标题、语言、作者、出版 (发布) 日期等元信息。至于之前看到的超长行，似乎是一种十六进制的水印 (watermark) ，或许是为了防侵权等。 其中的 /package/manifest/item 定义了所有的索引，以及文件对应的类型； /package/spine/itemref 暂不知进一步的作用，但从中可看出能定义是否“线性” (linear) ； /package/guide/reference 定义了 ePub 的封面等索引，可供文件管理器和 ePub 阅读器使用 (显示预览页) 。 Round IV.IV. 目录！再看 OEBPS/toc.ncx ： 12[littleye233@lymjrolt test_epub]$ file OEBPS/toc.ncxOEBPS/toc.ncx: XML 1.0 document, Unicode text, UTF-8 text 感觉再讨论文件类型已经无关紧要了。再次查看内容： 点此查看 `OEBPS/toc.ncx` 的全部内容 (已经过格式化) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ncx xmlns=&quot;http://www.daisy.org/z3986/2005/ncx/&quot; version=&quot;2005-1&quot; xml:lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta content=&quot;3899198450&quot; name=&quot;dtb:uid&quot;/&gt; &lt;meta content=&quot;2&quot; name=&quot;dtb:depth&quot;/&gt; &lt;meta content=&quot;mobiunpack.py&quot; name=&quot;dtb:generator&quot;/&gt; &lt;meta content=&quot;0&quot; name=&quot;dtb:totalPageCount&quot;/&gt; &lt;meta content=&quot;0&quot; name=&quot;dtb:maxPageNumber&quot;/&gt; &lt;/head&gt; &lt;docTitle&gt; &lt;text&gt;咖啡馆推理事件簿系列（全四本）&lt;/text&gt; &lt;/docTitle&gt; &lt;navMap&gt; &lt;navPoint id=&quot;np_1&quot; playOrder=&quot;1&quot;&gt; &lt;navLabel&gt; &lt;text&gt;总目录&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0000.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_2&quot; playOrder=&quot;2&quot;&gt; &lt;navLabel&gt; &lt;text&gt;咖啡馆推理事件簿：下次见面时，请让我品尝你煮的咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0001.xhtml&quot;/&gt; &lt;navPoint id=&quot;np_3&quot; playOrder=&quot;3&quot;&gt; &lt;navLabel&gt; &lt;text&gt;序章&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0005.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_4&quot; playOrder=&quot;4&quot;&gt; &lt;navLabel&gt; &lt;text&gt;一 事件始于第二次光顾&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0006.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_5&quot; playOrder=&quot;5&quot;&gt; &lt;navLabel&gt; &lt;text&gt;二 Bittersweet Black&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0007.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_6&quot; playOrder=&quot;6&quot;&gt; &lt;navLabel&gt; &lt;text&gt;三 隐藏在乳白色中的心&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0008.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_7&quot; playOrder=&quot;7&quot;&gt; &lt;navLabel&gt; &lt;text&gt;四 棋盘上的狩猎&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0009.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_8&quot; playOrder=&quot;8&quot;&gt; &lt;navLabel&gt; &lt;text&gt;五 past，present，f******？&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0010.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_9&quot; playOrder=&quot;9&quot;&gt; &lt;navLabel&gt; &lt;text&gt;六 Animals in the closed room&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0011.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_10&quot; playOrder=&quot;10&quot;&gt; &lt;navLabel&gt; &lt;text&gt;七 下次见面时，请让我品尝你煮的咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0012.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_11&quot; playOrder=&quot;11&quot;&gt; &lt;navLabel&gt; &lt;text&gt;终章&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0013.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_12&quot; playOrder=&quot;12&quot;&gt; &lt;navLabel&gt; &lt;text&gt;咖啡馆推理事件簿2：她梦到了欧蕾咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0014.xhtml&quot;/&gt; &lt;navPoint id=&quot;np_13&quot; playOrder=&quot;13&quot;&gt; &lt;navLabel&gt; &lt;text&gt;序曲 她的梦&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0018.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_14&quot; playOrder=&quot;14&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第一章 敬启致未来的你&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0019.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_15&quot; playOrder=&quot;15&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第二章 狐狸的迷惑&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0020.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_16&quot; playOrder=&quot;16&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第三章 打碎乳白色的心&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0021.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_17&quot; playOrder=&quot;17&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第四章 咖啡侦探蕾拉事件簿&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0022.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_18&quot; playOrder=&quot;18&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第五章 （She Wanted To Be）WANTED&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0023.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_19&quot; playOrder=&quot;19&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第六章 the Sky Occluded in the Sun&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0024.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_20&quot; playOrder=&quot;20&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第七章 在星空之下同命相连&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0025.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_21&quot; playOrder=&quot;21&quot;&gt; &lt;navLabel&gt; &lt;text&gt;终章 她梦到了欧蕾咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0026.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_22&quot; playOrder=&quot;22&quot;&gt; &lt;navLabel&gt; &lt;text&gt;咖啡馆推理事件簿3：扰人心神的咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0027.xhtml&quot;/&gt; &lt;navPoint id=&quot;np_23&quot; playOrder=&quot;23&quot;&gt; &lt;navLabel&gt; &lt;text&gt;序曲 五年前&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0031.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_24&quot; playOrder=&quot;24&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第一章 参加大赛&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0032.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_25&quot; playOrder=&quot;25&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第二章 前夜&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0033.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_26&quot; playOrder=&quot;26&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第三章 第一天&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0034.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_27&quot; playOrder=&quot;27&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第四章 第二天&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0035.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_28&quot; playOrder=&quot;28&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第五章 真相&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0036.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_29&quot; playOrder=&quot;29&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第六章 日后&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0037.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_30&quot; playOrder=&quot;30&quot;&gt; &lt;navLabel&gt; &lt;text&gt;尾声 五年前&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0038.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_31&quot; playOrder=&quot;31&quot;&gt; &lt;navLabel&gt; &lt;text&gt;咖啡馆推理事件簿4：休闲时光的五种风味&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0039.xhtml&quot;/&gt; &lt;navPoint id=&quot;np_32&quot; playOrder=&quot;32&quot;&gt; &lt;navLabel&gt; &lt;text&gt;午后三点前的无聊风景&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0043.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_33&quot; playOrder=&quot;33&quot;&gt; &lt;navLabel&gt; &lt;text&gt;帕列塔之恋&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0044.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_34&quot; playOrder=&quot;34&quot;&gt; &lt;navLabel&gt; &lt;text&gt;消失的礼物飞镖&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0045.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_35&quot; playOrder=&quot;35&quot;&gt; &lt;navLabel&gt; &lt;text&gt;可视化的原生艺术&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0046.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_36&quot; playOrder=&quot;36&quot;&gt; &lt;navLabel&gt; &lt;text&gt;在塔列兰咖啡馆的庭院里&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0047.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_37&quot; playOrder=&quot;37&quot;&gt; &lt;navLabel&gt; &lt;text&gt;特别篇 如释重负&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0048.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;/navMap&gt;&lt;/ncx&gt; 我们不妨将目光转向较为重要的“目录”的定义上。为了方便观察，笔者偷点懒，使用桌面环境中自带的阅读器观察： 从中可以看出目录是二层结构，恰好和 OEBPS/toc.ncx 中的定义保持一致。而其中的部分重要属性均可“望文生义”，此处不再进一步研究。 Round IV.V. 其余部分最后剩下的是图片、文字和层叠样式表。虽然这部分是在整个 ePub 文件中占比最大也可以说是最重要的部分，但由于这一块的内容实在是太过直白，再讲下去恐怕要开始补习 HTML 和 CSS 知识了，故同样略去。 总结根据上文中的简要探究， ePub 是一种以 XML 文件格式为配置文件类型的、包含有图片及文字等数据的、以压缩档为本质的文件格式。查阅相关资料后可知其实质与上文中分析类似。 而通过上文的分析，我们初步体验到分析一种陌生文件格式的规律和技巧，可以用于后续对更复杂的文件格式的探究。 但最后，别忘了把那个 ePub 文件的名字改回来 XD ： 1[littleye233@lymjrolt Downloads]$ mv test.epub 咖啡馆推理事件簿系列（全四本）.epub 【完】 脚注[^1]: 此处为 XPath 语法，用于描述类 XML 文件各种元素的位置，后文类似者不再注明。","link":"/techdev/format/epub/"},{"title":"蓝桥杯真题：分巧克力","text":"蓝桥杯 2017 年省赛真题《分巧克力》的 Python 解法。 蓝桥杯 2017 年省赛真题：分巧克力。 题目链接：https://www.lanqiao.cn/problems/99/learning/（需要登录）。 题目大意将 $N$ 块大小为 $H_i\\times W_i$ 的巧克力切出部分分给 $K$ 人，要求分给 $K$ 人的巧克力大小相等且都为边长是整数的正方形。求可能分法中每人巧克力的边长最大值（测试点保证答案不小于 $1$）。 数据范围$1\\leq N,K,H_i,W_i\\leq10^5$。 运行限制 时间限制：2s。 分析Python注意到数据范围上限都是 $10^5$，可以猜测本题一解的时间复杂度为 $O(N\\log N)$，继而联想到二分法。 那本题如何绕到二分上呢？先看选定不同的边长对分巧克力过程的影响。从题目中可知若记切出的巧克力的边长为 $a$，能切出 $b$ 块满足题设条件的巧克力，那么所有边长小于 $a$ 的切法均能切出不少于 $b$ 块巧克力。换言之，若将考察范围内的边长排成一个序列，一定存在某个元素 $a_\\mathrm{ans}$，使得在它之前的边长以及它本身都是满足题设条件的分法，而在它之后的边长都不满足——这就说明这个序列可以视作有序的，其元素值仅能被划分到“满足条件的”和“不满足条件的”两类中，而我们则需要找到这两类元素的“分界线”——这正是二分法的一种典型应用。 此外，我们发现，对于给定的边长 $a$ 和大小为 $H_i\\times W_i$ 的巧克力，如果尽可能一块紧挨着一块切分，可以达到最大份数，具体数值为 $\\left\\lfloor\\dfrac{H_i}{a}\\right\\rfloor\\left\\lfloor\\dfrac{W_i}{a}\\right\\rfloor$。这也说明判断某个边长是否满足题设条件的时间复杂度为 $O(N)$。结合上述二分的描述过程，此解法的时间复杂度恰好为 $O(N\\log N)$。 完整代码Python123456789101112131415161718192021222324252627282930313233343536import sysn, k = map(int, sys.stdin.readline().rstrip().split())h, w = [None] * n, [None] * nfor i in range(n): h[i], w[i] = map(int, sys.stdin.readline().rstrip().split())# 考察范围的上限为所有巧克力中长和宽的最大值maxh, maxw = max(h), max(w)maxhw = max(maxh, maxw)# f[i] 为某个边长 i 是否满足题设条件f = [None] * (maxhw + 1)# 参考：Python 安装目录下 Lib/bisect.py# 注意：在更高 Python 版本中，内置模块 bisect 支持在二分查找和排序中加入 `key` 参数，若将判断边长是否符合条件的过程写成函数，则可以# 直接代入 `bisect.bisect_left()`，且该内置函数经过 C 语言优化，运行速度更快。lo, hi = 1, maxhw + 1while lo &lt; hi: mid = (lo + hi) // 2 # 若 `f[mid]` 未被计算出，则开始计算 if f[mid] is None: s = 0 # 可分出的巧克力块数 f[mid] = False for i in range(n): s += (h[i] // mid) * (w[i] // mid) # 本题无需计算出分出巧克力的具体块数，则在判断出其已经超过 `k` 时直接跳出 if s &gt;= k: f[mid] = True break if f[mid] == True: lo = mid + 1 else: hi = mid# `lo` 即为 `bisect.bisect_left()` 的返回值，其为不符合题设条件的边长最小值print(lo - 1)","link":"/acmoi/lanqiao/fen-qiao-ke-li/"},{"title":"Arch Linux 物理机安装大体思路和部分实现细节（MBR &amp; GPT）","text":"背景作为官方文档的补充，大致提供一些安装 Arch Linux 到物理机上并安装桌面环境的思路和文档中未提及的细节。 设备本文的主要篇幅将建立在如下几个设备之上： 主力机 操作系统：Manjaro x86_64 用途：下载并烧录镜像、为目标机器提供网络服务、远程操作、应急使用等 目标机器 操作系统：Windows 7 Utimate x86_64 磁盘数量：1 磁盘记录类型：MBR 启动类型：BIOS 目标：与 Windows 并存安装 Arch Linux U 盘 总容量：8 GB 用途：烧录 Arch Linux 镜像 在文末，会对磁盘记录类型为 GPT、启动类型为 UEFI 的设备的安装过程，及图形界面其他的安装方案作一些说明。 注意：强烈建议为主力机增添显示器、键盘等外设（对笔记本电脑等已有的除外），并在完全配置好网络环境前使用有线网络，防止因安装过程出现问题导致无法联网时难以检修。 安装分区建议在安装 Arch Linux 前分区，或是分出空闲空间，避免因不熟悉命令行环境或参数不直观导致数据丢失。笔者选择后者。 对于主力机是 Linux 的读者，可以使用 gparted 工具进行分区；对于 Windows 读者，可以使用 Disk Genius 工具进行分区。需要注意的是，gparted 底层使用 parted 命令行工具，而该工具在调整分区时无法调整分区头部位置。因此，对于有多启动需求的读者，建议在 Windows 下使用 Disk Genius 工具分区。若主力机上无 Windows 分区，可以在其他可移动介质中安装用于维护的 Windows PE 系统。 笔者的设备已有 BIOS/MBR 类型的 Windows 存在，安装时更加方便。对于大部分使用 UEFI/GPT 类型的读者，请参照官方文档。两种类型的设备的安装过程没有太大差异，且互联网上已有诸多相关的资料供读者参考。但若在安装后出现无法加载 Linux 或其它系统的情况（尤其是 UEFI/GPT 类型），排除软件原因后，考虑升级主板或更换相关硬件。 笔者的分区方案是： 分区 文件类型 大小 格式化 启动项 挂载点 安装镜像环境中的挂载点 /dev/sda1 HPFS/NTFS/exFAT 65GB 否 是 /dev/sda2 HPFS/NTFS/exFAT 312.8GB 否 否 /dev/sda3 Linux swap / Solaris 8GB 是 否 [SWAP] /dev/sda4 Linux 80GB 是 否 / /mnt 其中，“挂载点”表示该分区在安装后操作系统中的路径，“安装镜像环境中的挂载点”表示该分区在当前环境（安装镜像环境）中的路径。 烧录镜像终端执行 sudo fdisk -l 记录需要写入镜像的 U 盘的设备路径。根据官方文档： 1sudo dd bs=4M if=/path/to/archlinux-version-x86_64.iso of=/dev/sdx conv=fsync oflag=direct status=progress 注意写入后 U 盘的卷标应形如 ARCH_YYYYDD，其中 YYYY 和 DD 表示镜像版本号中的年份和月份。若不是，建议手动更改。 U 盘启动U 盘启动成功后进入镜像内置的简易操作系统。与其他发行版镜像稍有不同的是，Arch Linux 镜像默认终端为 zsh，且相比于用户实装的 Arch Linux 内置有更多有利于系统安装和调试的工具。 正常启动后，屏幕显示的应该类似于： 12345678910111213To install Arch Linux follow the installation guide:https://wiki.archlinux.org/title/Installation_guideFor Wi-Fi, authenticate to the wireless network using the iwctl utility.For mobile broadband (WWAN) modems, connect with the mmcli utility.Ethernet, WLAN and WWAN interfaces using DHCP should work automatically.After connecting to the internet, the installation guide can be accessedvia the convenience script Installation_guide.Last login: Mon Apr 25 18:11:37 2022 from 10.42.0.1root@archiso ~ # 并且文字有多种颜色（上方有一行全是空格，在屏幕上实则是不同颜色的色块（经常用于做终端颜色测试））。 而读者若发现屏幕上显示的类似于： 1234567:: Mounting '/dev/disk/by-label/ARCH_202204' to '/run/archiso/bootmnt'Waiting 30 seconds for device /dev/disk/by-label/ARCH_202204 ...ERROR: '/dev/disk/by-label/ARCH_202204' device did not show up after 30 seconds... Falling back to interactive prompt You can try to fix the problem manually, log out when you are finishedsh: can't access tty: job control turned off[rootfs ]# 说明 Arch Linux 安装镜像未找到设备（也就是 U 盘）。出现这种情况，一种原因是如上所述的未修改 U 盘的卷标。而另一种可能的原因则出在硬件上。先在终端上执行： 1ls /dev/disk/by-label 出现的条目中，若有类似 U 盘卷标的，尝试挂载： 12mkdir /mntmount /dev/disk/by-label/&lt;卷标&gt; /mnt 若发现无法挂载，或挂载成功后发现其并非 U 盘的，则说明可能出现了上述硬件问题。此时尝试重新插拔 U 盘，再执行 ls /dev/disk/by-label。若发现形如“ARCH_YYYYDD”的条目出现，则执行 exit 开始安装系统。 另外，有必要检测 U 盘启动时的“启动模式”。执行： 1ls /sys/firmware/efi/efivars 若没有输出，则表示 U 盘在 BIOS 模式启动；反之，则为 UEFI 模式。若启动模式与预计不符，请考虑修改 BIOS 相关的设置。 远程登入上文中笔者提到了“远程操作”。Arch Linux 安装镜像中内置 ssh，可以使用 ssh 远程登入进行安装。需要注意的是，笔者远程登入目标机器是为了方便截取终端上的文字，而考虑到 ssh 连接中断可能导致中断安装进程，不建议这么做。若确实需要，在终端中执行： 1nano /etc/ssh/sshd_config 在文本编辑器中找到： 123# To disable tunneled clear text passwords, change to no here!#PasswordAuthentication yes#PermitEmptyPasswords no 将其修改为： 123# To disable tunneled clear text passwords, change to no here!PasswordAuthentication yesPermitEmptyPasswords yes 按 Ctrl+X，再按 y 保存文件，执行： 1systemctl restart sshd 重启 ssh 服务后，尝试登入。 其他配置本节对应官方文档中“Boot the live environment”小节到“Reboot”小节。大多数情况下只需要根据目标机器的环境修改少数参数就可以直接执行上面的代码。 网络服务正如官方文档中提到的那样，安装镜像中的系统与用户实际使用的系统并不完全相同，在前者环境中能够正常运作的机能可能在后者环境中便会失灵。“Install essential packages”小节中也提到了一些可选的在安装系统时即配置的软件包，不过其中最重要的是网络服务相关的包。若不能保证离开安装镜像环境后 Arch Linux 的网络通信正常，读者可以自行安装相关的包，必要时可提前配置。 另外，对命令行环境不熟悉或读写配置文件不顺畅的读者，可以安装 nmtui，用以在交互式环境下管理网络服务。笔者选择的包为：net-tools、iproute2、dhcpcd、traceroute、networkmanager（nmtui 被包含在该包中）。 文本编辑器后续的安装操作需要读写配置文件，因此建议安装 vim 或 nano 等文本编辑相关的包。 Boot loader这需要读者仔细阅读官方文档（如 GRUB）的全文。绝大多数可能的情况在文档中都有描述。对于笔者的设备，笔者使用 GRUB 做了如下操作，以保证 NTFS 分区下的 Windows 能被 GRUB 识别（假定已经 arch-chroot 进入系统）： 1234pacman -S os-prober grub ntfs-3ggrub-install --target=i386-pc /dev/sda# 修改 `/etc/default/grub`，将 `#GRUB_DISABLE_OS_PROBER=false` 一行的注释去除grub-mkconfig -o /boot/grub/grub.cfg 确认无误后，执行后续安装步骤。 安装后读者可以在官方文档中阅读有关安装后推荐的行动。 桌面环境笔者选择的桌面环境是： 显示服务器：Xorg（优先安装） 显示管理器：SDDM 桌面环境：KDE 这些在 Arch Linux Wiki 上都有同名词条，且描述得十分详细。这里不作赘述。即便在安装桌面环境后未能正常显示桌面，也可以使用其他 TTY 在终端下操作。 对于其中涉及的安装包，笔者不建议安装元包（包名含“-meta”）。这是考虑到： 一般安装桌面环境所需的包后，无彻底卸载的需求； 应用程序相关的组件中若有想卸载的，由于这些组件都是元包的依赖项，此时无法完成卸载。 若不慎安装元包，也可以在 Live CD 环境中卸载元包后重新安装组包（包名不含“-meta”，安装时需要选择组别）。结束后执行 pacman -Qsq &lt;包名&gt; 验证。 多用户登录界面如果读者需要在开机时启动桌面环境，官方文档给出了一种方案。但直接按照文档配置，会发现启动计算机后仍然停留在 TTY1 的终端登录页面，输入用户名后跳过输入密码阶段直接进入桌面环境。这显然不是我们所期待的。修复这个问题很简单，只需要将所给的配置项 123if [ -z &quot;${DISPLAY}&quot; ] &amp;&amp; [ &quot;${XDG_VTNR}&quot; -eq 1 ]; then exec startxfi 放置在系统配置文件 /etc/profile 中即可。 本地化参见《【Arch Linux】本地化：简体中文》和《【Arch Linux】本地化：日语》。 UEFI 和 GPT以下所列同样仅是笔者机器的情况。请读者根据遇到的情况自行判断。 分区根据笔者机器情况，笔者设计的分区方案如下： 分区 文件类型 启动项 挂载点 安装镜像环境中的挂载点 /dev/sda1 Linux 是 /boot /mnt/boot /dev/sda5 Linux 否 / /mnt /dev/sdb4 Linux 否 /home /mnt/home /dev/sdb5 Linux 否 /usr /mnt/usr /dev/sdb6 Linux swap / Solaris 否 [SWAP] 注意到这里 /usr 和 /、/boot 分属不同的硬盘。此类情况将在后文加以说明。 U 盘启动无法找到盘符的问题尝试在 UEFI+GPT 的机器上安装时，未出现此问题。 Boot loader笔者仍然使用 GRUB，但所执行的命令需要更改： 1grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB 这将在 /boot/EFI 文件夹中生成 GRUB 文件夹。一些旧教程中添加了诸如 /dev/sda、/dev/sdb 的参数，但现在实则是不需要的。 /usr 单独分区导致启动失败按照类似笔者的方案分区后，启动系统将失败，并显示类似如下的界面： 123456/dev/sda1: recovering journalError:Root device mounted successfully, but /sbin/init does not exist.Bailing out, you are on your own.Good luck.sh: can't access tty; job control turned off[rootfs ]# 根据官方文档的说明，读者需要重新进入 Live CD 环境，挂载所有分区后 arch-chroot 进入 chroot 环境。编辑其中的 /etc/mkinitcpio.conf 文件，修改类似如下的行 1HOOKS=(base udev autodetect modconf block filesystems keyboard fsck) 为 1HOOKS=(base udev autodetect modconf block filesystems keyboard fsck usr shutdown) 随后重制镜像并重启： 12mkinitcpio -Preboot WaylandWayland 也是一种显示服务协议（display server protocol），致力于成为 Xorg 的优秀后继者。Wayland 亦有兼容 Xorg 和 KDE 的实现，且 SDDM 依然能使用，但在 KDE 环境中并无相对 Xorg 的明显优势。 参照官方文档在 Xorg 基础上安装 Wayland 相关的包，并在登录界面左上角选择桌面为“Plasma (Wayland)”。 注意使用 Wayland 作为显示服务协议时，一些教程中涉及到 .xprofile 等配置文件将会失效。读者需要根据实际情况正确配置。在此不作赘述。","link":"/techdev/arch/installation/"},{"title":"【Arch Linux】maddy 邮件服务器搭建","text":"maddy 是一个开源的轻量级“可组合”（composable）多合一邮件服务器，支持通过 IMAP/SMTP 等协议和 DKIM、SPF、DMARC、DANE、MTA-STS 等安全模式收发邮件。本文将以官方文档为主线，整理 maddy 服务器配置流程。 准备为保证 maddy 的正常运行，请先明确一些建议满足的前提条件： 具有公网地址（本文以 IPv4 为例）并开放 25、143、465（TLS）、587、993（TLS）等端口（一些 VPS 提供商如谷歌云不支持）的服务器； 拥有一个域名（最好是付费二级域名，避免一些 DNS 服务商如 Cloudflare 封禁对其的 API 操作），并接入 DNS 服务商（本文以 Cloudflare 为例）； TLS 证书（本文以 Let’s Encrypt 和一款证书获取软件 certbot 为例）。 为叙述方便，本文假设邮件服务器的主域名为 example.org，邮件交换（MX）域名为 mx1.example.org，公网 IPv4 地址为 10.2.3.4，邮件账户为 postmaster@example.org。 同时需要在服务器上至少安装如下的软件包： maddy certbot certbot-dns-cloudflare nginx（或其他 Web 服务端） 除 maddy 外，其他的软件包都可以使用 pacman 直接安装。 安装可以在 GitHub 的 Releases 页面获取 maddy 最新版本的源码和预编译程序。也可以参照官方文档的说明，从源码构建、AUR 处获取或 Docker 镜像部署。 注意：从 AUR 处获取需要下载体积很大的 golang 编译器。为节约下载并安装编译器的时间，读者可以直接使用 GitHub 的预编译程序。本文也以此为例。 在服务器终端中执行如下命令，以下载 maddy 的预编译程序： 123456789101112131415161718# 安装 zstd 包，以解压 *.zst 类型的文件sudo pacman -S zstd --needed# 下载地址，可以任意选择cd ~/Downloadswget https://github.com/foxcpp/maddy/releases/download/v0.5.4/maddy-0.5.4-x86_64-linux-musl.tar.zst# 参考 zsh 的 extract 插件tar --zstd -xvf maddy-0.5.4-x86_64-linux-musl.tar.zst || zstdcat maddy-0.5.4-x86_64-linux-musl.tar.zst | tar xvf -cd maddy-0.5.4-x86_64-linux-musl# 复制服务sudo cp systemd/*.service /etc/systemd/system# 复制可执行文件sudo cp maddy maddyctl /usr/local/bin# 复制配置文件sudo mkdir -p /etc/maddysudo cp maddy.conf /etc/maddy# 复制 man 文件sudo cp man/*.1 /usr/share/man/man1sudo cp man/*.5 /usr/share/man/man5 启动服务前，先加载所有新增服务： 1sudo systemctl daemon-reload 若要开机自启： 1sudo systemctl enable maddy 因为 maddy 运行在非 root 用户上，还需要创建一个用户用以运行 maddy 服务： 1sudo useradd -mrU -s /sbin/nologin -d /var/lib/maddy -c &quot;maddy mail server&quot; maddy 配置域名使用任何编辑器打开 /etc/maddy/maddy.conf，修改 $(hostname) 和 $(primary_domain) 变量的值为 mx1.example.org 和 example.org。 TLS 证书获取Let’s Enccrypt 签发的 TLS 证书可以通过 certbot 获取。根据 certbot 和 certbot-dns-cloudflare 的官方文档，首先需要在 Cloudflare 的 API Token 配置页面新建一个 Token，选择“Edit zone DNS”的模板，在“Zone Resources”选择目标二级域名（本文则是“example.org”）即可。 注意：Token 只会显示一次，在配置好证书前，请务必牢记。 随后，可以在服务器上存储 Token 以方便后续使用。在终端中执行： 12mkdir -p ~/.secrets/certbotecho '&lt;TOKEN&gt;' &gt; ~/.secrets/certbot/cloudflare.ini # 替换为获取到的 Token 并设置权限提高安全性： 1chmod 600 ~/.secrets/certbot/cloudflare.ini 再使用 certbot 获取证书： 1sudo certbot certonly --dns-cloudflare --dns-cloudflare-credentials ~/.secrets/certbot/cloudflare.ini -d '*.example.org' -d 'example.org' 注意：可以选择不为含通配符域名，而是根据后文实际需要指定必要的三级域名签发证书。 首次获取证书需要填写邮箱等个人信息。签发完毕后则可以通过 sudo certbot certificates 获取证书的详细信息和存储位置。一般存储位置在 /etc/letsencrypt/live/example.org，其中证书文件名为 fullchain.pem，私钥路径为 privkey.pem。 配置编辑 /etc/maddy/maddy.conf，修改 tls file 一行为 1tls file /etc/letsencrypt/live/$(primary_domain)/fullchain.pem /etc/letsencrypt/live/$(primary_domain)/privkey.pem /etc/letsencrypt/live 文件夹默认权限为 750，maddy 无法访问，故需要使用 ACL 进行权限控制： 1sudo setfacl -R -m u:maddy:rX /etc/letsencrypt/{live,archive} 此时可以启动 maddy 服务来测试： 1sudo systemctl start maddy 若服务未报错，则可以继续进行配置。 DNS进入 Cloudflare 的 DNS 配置页，作出如下所示的配置： 123456789example.org. A 10.2.3.4example.org. MX 10 mx1.example.org.mx1.example.org. A 10.2.3.4example.org. TXT &quot;v=spf1 mx ~all&quot;mx1.example.org. TXT &quot;v=spf1 mx ~all&quot;_dmarc.example.org. TXT &quot;v=DMARC1; p=quarantine; ruf=mailto:postmaster@example.org&quot;_mta-sts.example.org. TXT &quot;v=STSv1; id=1&quot;_smtp._tls.example.org. TXT &quot;v=TLSRPTv1;rua=mailto:postmaster@example.org&quot;default._domainkey.example.org. TXT &quot;v=DKIM1; k=ed25519; p=nAcUUozPlhc4VPhp7hZl+owES7j7OlEv0laaDEDBAqg=&quot; 其中最后一条记录的值需要用 1sudo cat /var/lib/maddy/dkim_keys/example.org_default.dns 的输出替换。若显示文件不存在，请确认 maddy 服务是否曾成功运行过至少一次。 MTA-STSMTA-STS 要求访问 https://mta-sts.example.org/.well-known/mta-sts.txt 时能输出类似如下的文本： 1234version: STSv1mode: enforcemax_age: 604800mx: mx1.example.org 对于已经安装 HTTP Echo 模块的 Nginx，直接在 /etc/nginx/nginx.conf 中添加如下条目： 1234567891011121314151617server { listen 443 ssl http2; server_name mta-sts.example.org; error_log /var/log/nginx/log.log; ssl_certificate /etc/letsencrypt/live/example.org/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.org/privkey.pem; ssl_session_timeout 5m; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location /.well-known/mta-sts.txt { echo 'version: STSv1'; echo 'mode: enforce'; echo 'max_age: 604800'; echo 'mx: mx1.example.org'; }} 对于未安装该模块的 Nginx，先添加如下条目： 123456789101112131415server { listen 443 ssl http2; server_name mta-sts.example.org; error_log /var/log/nginx/log.log; ssl_certificate /etc/letsencrypt/live/example.org/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.org/privkey.pem; ssl_session_timeout 5m; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location /.well-known/mta-sts.txt { root /usr/share/nginx/mta-sts; # /usr/share/nginx 是 Nginx 的静态资源默认位置 index /mta-sts.txt; }} 再新建 /usr/share/nginx/mta-sts 文件夹，将指定文本写入 mta-sts.txt 文件中： 123456sudo cat &lt;&lt;EOFversion: STSv1mode: enforcemax_age: 604800mx: mx1.example.orgEOF &gt; /usr/share/nginx/mta-sts/mta-sts.txt 重启 Nginx 服务： 1sudo systemctl restart nginx 检查上述网络路径是否能够正常访问。 DANE设置 TLSA（DANE）需要在 https://www.huque.com/bin/gen_tlsa 生成对应的 DNS 记录。 进入页面后，在“Enter/paste PEM format X.509 certificate here:”下的文本框中输入上文中获取的证书的内容： 1sudo cat /etc/letsencrypt/live/example.org/fullchain.pem 注意：该证书很长，务必复制完全。 下方的“Port Number:”填写 25，Transport Protocol: 填写 tcp，Domain Name: 填写 mx1.example.org。再点击“Generate”生成记录。将 DNS 记录写入 Cloudflare 中。 创建邮件账户在服务器终端中： 12maddyctl creds create postmaster@example.orgmaddyctl imap-acct create postmaster@example.org 此时，邮件账户的用户名为“postmaster@example.org”，密码则在创建账户时要求设置。该账户已经可以在邮件客户端（如 Thunderbird 和 Outlook）中配置并使用。 （可选）开启 DNSSEC 认证DNSSEC（Domain Name System Security Extensions），即域名系统安全扩展，对DNS提供给DNS客户端（解析器）的DNS数据来源进行认证，并验证不存在性和校验数据完整性验证。 Arch Wiki 中给出了一些验证方法。安装 ldns 包后： 1234$ drill -DT example.org # 替换为二级域名# 省略多行[T] example.org. 60 IN A 10.2.3.4;;[S] self sig OK; [B] bogus; [T] trusted 如果命令执行结果如上所示（域名前的 flag 值为“T”），则说明 DNSSEC 认证已开启；反之，请参考 Install a DNSSEC-validating resolver 章节，或参考 DNS 服务商的文档。 以下简单介绍 Cloudflare 为域名开启 DNSSEC 的方法：进入 Cloudflare 控制台后，进入目标域名的详情页面，点击左侧的“DNS”选项卡，在页面尾部的“DNSSEC”部分点击“Enable DNSSEC”。随后 Cloudflare 将给出域名的 DS Record。再进入域名注册商的域名管理页面设置 DS Record。具体设置方法参照 Cloudflare 的官方文档。","link":"/techdev/arch/maddy/"},{"title":"【Arch Linux】misskey 手动部署和配置","text":"misskey 是一款开源的“跨星际”（interplanetary）社交平台，以微博为主要形式，界面美观，内含元素丰富。本文即针对该平台在 Arch Linux 的手动安装方式作说明。 笔者：为什么不用 docker 安装（这是官方认定 recommended 的安装方式）？只是不怎么想用 docker（ 注意：基于 Arch Linux 发行版的特殊性（非开箱即用），笔者会尽可能多地补充安装过程，尽可能让读者能从头到尾依照本文操作。但若存在疏漏，敬请谅解。 检查系统配置misskey 对服务端的性能配置要求较高，建议配置至少 2 核 CPU 和 4GB RAM。笔者使用的服务器部分配置如下（多人共有，但对 misskey 来说也已足够）： 123456$ neofetch# 省略部分输出OS: Arch Linux x86_64Kernel: 5.15.34-1-ltsCPU: AMD EPYC 7282 (4) @ 2.794GHzMemory: 1590MiB / 7950MiB 安装依赖系统安装所有依赖（这里假设读者已经安装了 sudo 并配置好相关权限）： 12345sudo pacman -Syu # 更新系统sudo pacman -S sudo visudo nano base-devel python --neededsudo python -m ensurepip --upgrade # 安装/升级 pipsudo ln -sf /usr/bin/{nano,vi}sudo visudo 在打开的编辑器 nano 中去除 #%wheel ALL=(ALL:ALL) ALL 一行前的注释，依次按 Ctrl+X、y、Enter 保存。 同时考虑到 pip 用户配置下 $PATH 环境变量问题，使用编辑器打开当前终端配置（例如 ~/.bashrc），添加如下行： 1PATH=~/.local/bin:$PATH misskey官方文档中给出的 misskey 需要的依赖有： Node.JS（16.x） PostgreSQL（建议 12.x 或 13.x） Redis yarn（可选，若不安装，后续安装过程中 yarn 应替换为 npx yarn） FFmpeg 考虑到大部分软件的向后兼容性，可以直接安装所有依赖： 1sudo pacman -S nodejs npm postgresql redis yarn ffmpeg --needed 用户因笔者服务器环境中存在多用户、多管理情况，此处的操作与官方文档不同——创建了一个有 sudo 权限、可登录、有家目录的用户。 1useradd -m -G wheel -s /bin/bash misskey 并使用 sudo passwd misskey 设置登录密码。 若依照官方文档，仅需： 1useradd -r -s /usr/bin/nologin misskey 之后切换入该用户继续操作：su - misskey。 下载源码根据上文中用户创建方式，目录的路径可能不能完全如文中所述。请读者根据自身情况合理选择安装路径。 在终端中执行： 12345mkdir .optcd .optgit clone --recursive https://github.com/misskey-dev/misskey.gitcd misskeygit checkout master 注意：截至本文编写时，misskey 源码库克隆大小 88.22MB，子库（misskey-assets）克隆大小 69.76MB。请自行选择是否“科学上网”或使用镜像站。 安装依赖库在终端中执行： 1yarn 注意：请自行选择是否“科学上网”或使用镜像站。 注意：该过程耗时较长。若无人值守，建议使用 tmux 或 screen 防止 ssh 连接中断导致安装过程中断。 编译在终端中执行： 1NODE_ENV=production yarn build 注意：该过程耗时较长。若无人值守，建议使用 tmux 或 screen 防止 ssh 连接中断导致安装过程中断。 初始化数据库Postgresql在终端中执行： 1234567891011sudo -iu postgres # 切换到 postgres 用户initdb -D /var/lib/postgres/data# （可选）修改 locale 和编码：# initdb --locale=en_US.UTF-8 --encoding=UTF8 -D /var/lib/postgres/dataexit # 返回 misskey 用户sudo systemctl enable postgresql --nowsudo systemctl status postgresql # 查看服务状态# （可选）添加 SQL 操作历史文件sudo touch /var/lib/postgres/.psql_historysudo chown postgres:postgres /var/lib/postgres/.psql_historysudo -u postgres psql 进入 Postgresql 操作界面，执行： 1234create database misskey;create user misskey with encrypted password '{YOUR_PASSWORD}';grant all privileges on database misskey to misskey;\\q 其中上面的 '{YOUR_PASSWORD}' 可以任意配置，但需要和后面的 misskey 配置文件保持一致。 Redis在终端中执行： 12sudo systemctl enable redis --nowsudo systemctl status redis # 查看服务状态 前置配置从 .config 文件夹中复制 example.yml 到 default.yml： 1cp .config/{example,default}.yml 然后使用编辑器编辑后者，例如 nano .config/default.yml。其中最重要的配置（不修改就会直接导致 misskey 跑不通）是： 12345678910111213# ┌──────────────────────────┐#───┘ PostgreSQL configuration └────────────────────────────────db: host: localhost port: 5432 # Database name db: misskey # Auth user: example-misskey-user pass: example-misskey-pass 将其中的 user 配置项改为 user: misskey，pass 配置项根据上面的配置保持一致。 初始化在终端中执行： 12yarn run initNODE_ENV=production npm start 若在终端中看到类似如下的输出： 1234567891011121314INFO * [core boot] Welcome to Misskey!INFO * [core boot] Misskey v12.110.1INFO * [core boot env] NODE_ENV: productionINFO * [core boot env] You do not have root privilegesINFO * [core boot nodejs] Version v17.9.0 detected.DONE * [core boot config] LoadedINFO * [core boot db] Connecting...DONE * [core boot db] Connected: v14.2DONE * [core boot] Misskey initializedINFO * [core boot] Starting 1 worker...(node:324552) ExperimentalWarning: Importing JSON modules is an experimental feature. This feature could change at any time(Use `node --trace-warnings ...` to show where the warning was created)DONE * [core boot] All workers startedDONE * [core boot] Now listening on port 3000 on https://example.tld 则表示 misskey 部署成功。 配置systemd 服务可以配置 systemd 服务让其管理 misskey 的运行。新建 /etc/systemd/system/misskey.service，在编辑器中打开并填入如下内容： 1234567891011121314151617[Unit]Description=Misskey daemon[Service]Type=simpleUser=misskeyExecStart=/usr/bin/npm startWorkingDirectory=/home/misskey/.opt/misskeyEnvironment=&quot;NODE_ENV=production&quot;TimeoutSec=60StandardOutput=syslogStandardError=syslogSyslogIdentifier=misskeyRestart=always[Install]WantedBy=multi-user.target 然后分别通过 sudo systemctl start misskey 和 sudo systemctl enable misskey 启动 misskey 并添加开机自启。 端口转发（反向代理）和 TLSmisskey 支持 HTTPS/SSL/TLS 。这需要配置相关证书，并设置端口转发（反向代理）。笔者使用的软件包是 nginx，并已在 Cloudflare 添加一个域名。 注意：部分免费二级域名（如 .cf、.tk）无法使用后文中提及的 Cloudflare API 自动更新 DNS 记录。请读者自行选用其他域名，或使用其他 DNS 服务。 证书首先安装自动签发 Let’s Encrypt 证书的软件包 certbot： 1python -m pip install certbot certbot-cloudflare-dns 为防止证书信息泄露（certbot 默认工作和日志目录均在 /etc、/var 等文件夹中），先创建相关文件夹： 12# 工作目录、日志目录、配置目录（存放证书）mkdir -p ~/.var/letsencrypt ~/.logs/letsencrypt ~/.etc/letsencrypt 再写入 Cloudflare API 的相关配置文件： 12mkdir -p ~/.secrets/certbotecho 'dns_cloudflare_api_token = {API_TOKEN}' &gt; ~/.secrets/certbot/cloudflare.ini 其中 {API_TOKEN} 表示 Cloudflare 账户的 API token。请参见 Cloudflare 和 Certbot 相关文档配置。 为保证安全性，建议为其重新配置权限： 12chmod -R 700 ~/.secretschmod -R 600 ~/.secrets/certbot/cloudflare.ini 最后，在终端中执行： 12# 此处使用 Cloudflare API 更新 DNScertbot certonly --dns-cloudflare --dns-cloudflare-credentials ~/.secrets/certbot/cloudflare.ini -d '{domain}' --config-dir ~/.etc/letsencrypt --work-dir ~/.var/letsencrypt --logs-dir ~/.logs/letsencrypt 其中 '{domain}' 是为 misskey 分配的域名。certbot 运行过程中需要同意相关服务条款并输入邮箱注册。 DNS在 DNS 服务商（如 Cloudflare）中添加一条 A/AAAA 记录，从域名指向服务器的 IP 地址。 端口转发（反向代理）在终端中执行： 12sudo pacman -S nginx-mainline --neededsudo systemctl enable nginx --now 再打开 /etc/nginx/nginx.conf，添加如下类似的配置项： 1234567891011121314151617181920server { listen 443 ssl http2; server_name '{domain}'; error_log /var/log/nginx/log.log; ssl_certificate /home/misskey/.etc/letsencrypt/live/'{domain}'/fullchain.pem; ssl_certificate_key /home/misskey/.etc/letsencrypt/live/'{domain}'/privkey.pem; ssl_session_timeout 5m; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { proxy_pass http://localhost:3000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header Referer http://$host; }} 其中 '{domain}' 表示分配的域名。证书路径以实际情况为准。 最后重启 nginx 服务： 1sudo systemctl restart nginx misskey打开 misskey 配置文件 ~/.opt/misskey/.config/default.yml，修改如下配置项： 12345# ┌─────┐#───┘ URL └─────────────────────────────────────────────────────# Final accessible URL seen by a user.url: '{domain}' 设置为先前分配的域名。 最后重启 misskey 服务： 1sudo systemctl restart misskey 特别致谢感谢一位朋友“梦可味”在撰写本文前提供的在 Ubuntu 发行版中安装 misskey 的教程，其上有对多处踩坑的详细记录，让笔者能更快速地完成安装。之后会发布 misskey 在 Ubuntu 下的安装及配置教程。 参考 misskey 官方文档 build-essential in Arch Linux Users and groups - ArchWiki","link":"/techdev/arch/misskey/"},{"title":"【Arch Linux】本地化：简体中文","text":"本文主要介绍 Arch Linux 本地化为简体中文的操作。 本文的测试环境是 KDE Plasma + SDDM + Wayland。考虑到 Xorg 教程较多，且大部分操作通用，本文会存在 Xorg 和 Wayland 混合描述的情况。 必要配置不建议用户日常使用 root 帐户，则此时用户的当前帐户建议拥有 sudo 权限。安装 sudo 包。 同时部分本地化安装包在 AUR 源中，建议用户安装 AUR helper。本文以 yay 为例。 生成语言环境^1编辑 /etc/locale.gen，找到 #en_US.UTF-8 UTF-8 和 #zh_CN.UTF-8 UTF-8，删除前面的注释符号“#”。 再生成语言环境文件： 1sudo locale-gen 为保证大部分程序和终端环境显示正常，在 /etc/locale.conf 中设置 LANG 环境变量： 1LANG=en_US.UTF-8 （可选）为 Xorg 图形界面设置中文语言环境编辑 ~/.xinitrc 或 ~/.xprofile： 12export LANG=zh_CN.UTF-8export LANGUAGE=zh_CN:en_US 显示简体中文字体此时图形界面的中文显示一般是异常的。这可以通过安装相关字体解决。 安装字体^21sudo pacman -S wqy-microhei wqy-microhei-lite wqy-bitmapfont wqy-zenhei ttf-arphic-ukai ttf-arphic-uming adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts noto-fonts-cjk 可选 AUR 源中 ttf-ms-win11-auto-* 相关的包（存在已知问题，见下文）。 一般此时字体缓存已刷新。若无： 1fc-cache -fv 可以通过类似下述命令验证字体缓存： 1fc-match -s | grep 'Noto Sans CJK' ttf-ms-win11-auto-* 相关包无效参见 ttf-ms-win11-auto AUR 包详情页面下的评论： It still throws ln: failed to create symbolic link '/home/&lt;User&gt;/.cache/yay/ttf-ms-win11-auto/src/' -&gt; '': No such file or directory warnings when I install the package via yay. Manually copy/move the font files from ~/.cache/yay/ttf-ms-win11-auto/src to /usr/share/fonts and fc-cache -fv can solve the problem. 因此，读者只需查看 AUR 包的缓存（如 ~/.cache/yay/ttf-ms-win11-auto），找到其中的字体文件，或是解压其中的压缩包（如 ttf-ms-win11-auto-zh_cn-10.0.22000.318-2-any.pkg.tar.zst）得到字体文件，将其复制到 /usr/share/fonts 并重新生成字体缓存即可。 修复简体中文字符显示为日文的问题^3新建文件 /etc/fonts/conf.avail/64-language-selector-prefer.conf： 若安装 noto-fonts-cjk 包： 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;&lt;fontconfig&gt; &lt;alias&gt; &lt;family&gt;serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Noto Serif CJK SC&lt;/family&gt; &lt;family&gt;Noto Serif CJK TC&lt;/family&gt; &lt;family&gt;Noto Serif CJK JP&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;sans-serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Noto Sans CJK SC&lt;/family&gt; &lt;family&gt;Noto Sans CJK TC&lt;/family&gt; &lt;family&gt;Noto Sans CJK JP&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;monospace&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Noto Sans Mono CJK SC&lt;/family&gt; &lt;family&gt;Noto Sans Mono CJK TC&lt;/family&gt; &lt;family&gt;Noto Sans Mono CJK JP&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt;&lt;/fontconfig&gt; 若安装 adobe-source-han-sans-otc-fonts 包： 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;&lt;fontconfig&gt; &lt;alias&gt; &lt;family&gt;serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Source Han Serif SC&lt;/family&gt; &lt;family&gt;Source Han Serif TC&lt;/family&gt; &lt;family&gt;Source Han Serif HW&lt;/family&gt; &lt;family&gt;Source Han Serif K&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;sans-serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Source Han Sans SC&lt;/family&gt; &lt;family&gt;Source Han Sans TC&lt;/family&gt; &lt;family&gt;Source Han Sans HW&lt;/family&gt; &lt;family&gt;Source Han Sans K&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;monospace&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Source Han Sans SC&lt;/family&gt; &lt;family&gt;Source Han Sans TC&lt;/family&gt; &lt;family&gt;Source Han Sans HW&lt;/family&gt; &lt;family&gt;Source Han Sans K&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt;&lt;/fontconfig&gt; 然后新建软链接应用配置： 1sudo ln -s /etc/fonts/conf.avail/64-language-selector-prefer.conf /etc/fonts/conf.d/64-language-selector-prefer.conf 随后刷新字体缓存生效： 1fc-cache -fv 中文输入法本文使用 Fcitx 5 框架配套 Rime 输入法引擎和 Clover Pinyin（四叶草拼音）输入方案。 Fcitx 5安装^41sudo pacman -S fcitx5 fcitx5-qt fcitx5-gtk fcitx5-configtool 在 Xorg 环境下，编辑 ~/.xprofile：^5 123456export GTK_IM_MODULE=fcitx5export QT_IM_MODULE=fcitx5export XMODIFIERS=&quot;@im=fcitx5&quot;export LANG=&quot;zh_CN.UTF-8&quot;export LC_CTYPE=&quot;zh_CN.UTF-8&quot; 在 Wayland 环境下，编辑 /etc/environment： 123GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=&quot;@im=fcitx&quot; 注销会话或重启。 外观本文使用 Material Color 皮肤。 1sudo pacman -S fcitx5-material-color 再编辑 Fcitx 5 的配置文件 ~/.config/fcitx5/conf/classicui.conf：^6 1234567891011# 垂直候选列表Vertical Candidate List=False# 按屏幕 DPI 使用PerScreenDPI=True# Font (设置成你喜欢的字体)Font=&quot;思源黑体 CN Medium 13&quot;# 主题Theme=Material-Color-Pink 诊断工具1fcitx5-diagnose Rime安装1sudo pacman -S fcitx5-rime 重启 Fcitx 5。依次 System Settings -&gt; Regional Settings -&gt; Input Method -&gt; Add Input Method… -&gt; Only Show Current Language [Uncheck] -&gt; Rime（中州韻）来激活输入法。 注意：Rime 系统目录位于 /usr/share/rime-data。本地目录 ~/.local/share/fcitx5/rime 可以覆盖前者的配置。 单行模式单行模式类似于 Windows 10 中微软拼音的默认行为：输入的拼音序列能同时键入到文本中，待选定候选词后才将其替换为对应的词。 编辑 ~/.config/fcitx5/conf/rime.conf：^7 12# 可用时在应用程序中显示预编辑文本（开启单行模式）PreeditInApplication=True Clover Pinyin安装1yay -S rime-cloverpinyin 编辑 ~/.local/share/fcitx5/rime/default.custom.yaml： 12345patch: # 每页候选词个数 &quot;menu/page_size&quot;: 9 schema_list: - schema: clover 重启 Fcitx 5。 注意：Clover Pinyin 有关快捷键等配置位于 ~/.local/share/fcitx5/rime/build/clover.schema.yaml。 Emoji12sudo pacman -S noto-fonts-emojiyay -S noto-color-emoji-fontconfig 注销会话或重启。 特殊符号指输入特殊符号拼音出现候选词（如“pingfang”出现“²”），或输入“/xx”（“xx”表示一些英文字母的组合）出现一类候选词（如“/sx”出现数学相关特殊符号）。 对于前者，目前尚无较好的解决方案。 对于后者，参考该回复。 注意：特殊符号支持存在已知问题，可能导致内存溢出，可以通过如下命令简单修复：^8 123python -c &quot;$(curl -fsSL https://github.com/fkxxyz/rime-symbols/raw/master/rime-symbols-gen)&quot;mkdir -p ~/.local/share/fcitx5/rime/openccmv symbol.json symbol_category.txt symbol_word.txt ~/.local/share/fcitx5/rime/opencc 重新部署 Rime。 参考","link":"/techdev/arch/localization-simplified-chinese/"},{"title":"Codeforces 266B: Queue at the School","text":"Codeforces 266B C++ 一解。 分析简单的模拟。把 B 想象成箱子，要不断往右侧推。 需要注意的是，没有正确理解题意的话容易理解成每次让箱子统一右移一格。但实际上，遇到 BBG 的情况，下一秒应该是 BGB 而不是 GBB，因为某一时刻某两个相邻位置的 B 和 G 互换后，就只能考虑其后的位置了。再拿箱子举例，应该想象成连续的箱子无法推动，只能推动箱子“队列”的最末一个。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;// brute forcestring solve(int n, int t, string s){ int l = s.length(); for (int i = 0; i &lt; t; ++i) { int j = 0; while (j &lt; l - 1) { if (s[j] == 'B' &amp;&amp; s[j + 1] == 'G') { s[j] = 'G'; s[j + 1] = 'B'; j += 2; } else { ++j; } } } return s;}int main(){ int n, t; string s, a; cin &gt;&gt; n &gt;&gt; t; cin &gt;&gt; s; a = solve(n, t, s); cout &lt;&lt; a &lt;&lt; endl; return 0;}","link":"/acmoi/codeforces/266b/"},{"title":"Codeforces 1520C: Not Adjacent Matrix","text":"Codeforces 1520C C++ 一解. 分析只要求对 $n$ 阶方阵依次填充 $1,2,\\cdots,n^2$, 一种常见的思考模式是依次将这个自然数序列填充到正确的位置. 显然对于本题一个较好的方案是间隔填充: 先从元素 $(0,0)$ (假定方阵左上角元素坐标为此, 其他类推) 开始每次间隔一格填充直至一行填充完毕, 再跳转到下一行间隔填充直至右下角元素 $(n-1,n-1)$, 接着顺序填充剩下的元素. 这样就能满足题意. Codeforces 上编辑者博客中, MikeMirzayazov 用黑白棋盘举例, 先填充白格再填充黑格, 判定颜色依据为横纵坐标之和的奇偶性. 而以下的代码则直接将方阵拉长为长度为 $n$ 的一维数组, 直接根据下标的奇偶性填充数字, 效果类似. 当然以下的代码推出了每个坐标对应的数值的解析式, 并未利用到数组空间. 同时, 利用这样的填充方案, 显然可以得知当且仅当 $n=2$ 时找不到满足题意的方阵; 为方便编程, 这里将 $n=1$ 也做了特殊处理. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;void solveAndPrint(int n){ const int nn = n * n; if (n == 1) { cout &lt;&lt; 1 &lt;&lt; endl; return; } if (n == 2) { cout &lt;&lt; -1 &lt;&lt; endl; return; } if (n % 2) { for (int i = 0; i &lt; nn; ++i) { if (i % 2) { cout &lt;&lt; (nn + i) / 2 + 1 &lt;&lt; ' '; } else { cout &lt;&lt; i / 2 + 1 &lt;&lt; ' '; } if ((i + 1) % n == 0) { cout &lt;&lt; endl; } } } else { for (int i = 0; i &lt; nn; ++i) { if (i % 2) { cout &lt;&lt; (nn + i + 1) / 2 &lt;&lt; ' '; } else { cout &lt;&lt; i / 2 + 1 &lt;&lt; ' '; } if ((i + 1) % n == 0) { cout &lt;&lt; endl; } } }}int main(){ int t, n; cin &gt;&gt; t; for (int i = 0; i &lt; t; ++i) { cin &gt;&gt; n; solveAndPrint(n); } return 0;}","link":"/acmoi/codeforces/1520c/"},{"title":"Codeforces 1474B: Different Divisors","text":"Codeforces 1474B C++ 一解. 分析$a$ 至少要有 $4$ 个因子 (自然包括 $1$ 和 $a$ 本身), 且任意两因子的差不小于 $d$. 为使 $a$ 尽可能小, 我们只希望 $a$ 有且仅有 $4$ 个因子, 也就是再确定两个不同的质因子 $p,q$ ($a=pq$, 且不妨设 $p&lt;q$). 一个很显然的事实是: 对于充分大的 $d$, 我们越能保证 $a-q\\geq d$ (不会证明故从略), 因此我们只需要在质数表中找到不小于 $1+d$ ($1$ 即是因子升序排列的第一个因子) 的 $p$ (第二个因子) 和不小于 $p+d$ 的 $q$ (第三个因子), 再确保 $a$ (第四个因子) 与 $q$ 的差不小于 $d$ 即可. 经过验证, 对于 $d=1$ 依然有 $a-q\\geq d$. 生成质数表生成质数表的方式有很多. 以下代码中尝试利用 STL 的 vector&lt;int&gt; 动态生成/更新指定范围内的质数表. 当然考虑到 $d\\leq 10,000$, 可以直接生成完整长度 (所需的最大质数为 $20,011$, 根据质数定理估计质数表长度为 $2020$) 的质数表. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define MAX_PRIME (20011) // 10007 and 20011 are primes.using namespace std;bool isPrime(int x){ if (x == 1) { return false; } if (x == 2) { return true; } if (x % 2 == 0) { return false; } for (int i = 3; i &lt;= int(floor(sqrt(x))); i += 2) { if (x % i == 0) { return false; } } return true;}vector&lt;int&gt; updatePrimes(int maxn, vector&lt;int&gt; primes){ int lastPrime = 2; if (primes.size()) { lastPrime = primes.back(); } else { primes.push_back(2); } for (int i = lastPrime + (lastPrime == 2 ? 1 : 2); i &lt;= maxn; i += 2) { if (isPrime(i)) { primes.push_back(i); } } return primes;}vector&lt;int&gt; updatePrimes(int maxn){ return updatePrimes(maxn, vector&lt;int&gt;());}int solve(int d, vector&lt;int&gt; primes){ vector&lt;int&gt;::iterator index1 = lower_bound(primes.begin(), primes.end(), 1 + d); vector&lt;int&gt;::iterator index2 = lower_bound(primes.begin(), primes.end(), *index1 + d); return *index1 * *index2;}int main(){ int t, d; vector&lt;int&gt; primes = updatePrimes(MAX_PRIME); cin &gt;&gt; t; while (t--) { cin &gt;&gt; d; cout &lt;&lt; solve(d, primes) &lt;&lt; endl; } return 0;}","link":"/acmoi/codeforces/1474b/"},{"title":"Codeforces 766A: Mahmoud and Longest Uncommon Subsequence","text":"Codeforces 766A C++ 一解. 分析两个字符串的最长不公共子序列被定义为最长的仅为其中一个字符串的子序列的字符串. 对于两个长度不相同的字符串 (不妨设 $a,b$ 且 $a$ 的长度较长), 一个非常直观的想法是: 因为一个字符串的子序列的长度必须不大于该串的长度, 只要选取 $a$ 本身作为所求的子序列, 其肯定是 $a$ 的子序列, 而不是 $b$ 的子序列. 而对于长度相同的情况, 我们同样可以使用类似的思路: 若两个串不相同, 我们总能选择其中一个串本身作为所求的子序列, 这样其一定不会是另一个串的子序列; 若两个串完全相同, 此时我们就无法找到一个串 (根据题意, 包括空串) 作为所求的子序列, 只能输出 $-1$. 代码12345678910111213141516171819202122#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int main(){ string a, b; cin &gt;&gt; a &gt;&gt; b; if (a == b) { cout &lt;&lt; -1 &lt;&lt; endl; } else { cout &lt;&lt; max(a.length(), b.length()) &lt;&lt; endl; } return 0;}","link":"/acmoi/codeforces/766a/"},{"title":"Codeforces 1312B: Bogosort","text":"Codeforces 1312B C++ 一解. 分析此题相当于排序数组后使两个有限数列 (一个是数列 ${1,2,\\cdots,n}$, 一个是排序后的数组 $a_\\mathrm{sorted}$) 的差各不相同. 一个很容易想到的构造方法是对一个单调 (不一定严格) 递减数列与严格单调递增数列求差, 这样得到的差数列的各元素一定各不相同 (且是单调递减的). 代码123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int main(){ int t, n, a[100]; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i]; } sort(a, a + n); // 先递增排列 while (n--) { cout &lt;&lt; a[n] &lt;&lt; ' '; // 再倒序输出, 相当于 &quot;构造&quot; 出了递减数列 } cout &lt;&lt; endl; } return 0;}","link":"/acmoi/codeforces/1312b/"},{"title":"Codeforces 1419D1: Sage&#39;s Birthday (easy version)","text":"Codeforces 1419D1 C++ 一解. 分析本题是简单版本, 各个冰淇淋球的价格都不相同. 我们只需要构造出数量最多的 “谷” 即可. 与上篇 Codeforces 1312B: Bogosort 类似, 这次相当于对一个排序后的数组同时从两边取数输出, 例如对输入数据 $[7,6,5,4,3,2,1]$, 两边取数得到 $[7,1,6,2,5,3,4]$, 这样得到的新数列的 “谷” 数量最多, 且为 $\\left[\\dfrac{n-1}{2}\\right]$. 代码12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int a[100000];int main(){ int n, p = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i]; } cout &lt;&lt; (n - 1) / 2 &lt;&lt; endl; sort(a, a + n); while (p++ &lt; n / 2) { cout &lt;&lt; a[n - p] &lt;&lt; ' ' &lt;&lt; a[p - 1] &lt;&lt; ' '; } if (n % 2) { cout &lt;&lt; a[p - 1]; } cout &lt;&lt; endl; return 0;}","link":"/acmoi/codeforces/1419d1/"},{"title":"Codeforces 1368B: Codeforces Subsequences","text":"Codeforces 1368B C++ 和 Python 一解. 终于看到一道比较有趣的 constructive algorithm 的题目了. 分析本题是 “乘法原理” 的经典应用之一: 每一个内容为 codeforces 子序列都需要在源串中各选择十个字符连续重复的字符串 (指连续的 c, o, d 等十个字符串) 中的一个字符. 若假定源串 $s$ 中 c, o, d 等字符各连续重复 $a_0,a_1,a_2,\\cdots,a_9$ 次, 则最终能生成的 codeforces 子序列共有 $l=a_0a_1a_2\\cdots a_9$ 个. 而为满足题意, 需要选择合适的 $a_0,a_1,a_2,\\cdots,a_9$, 使得 $l\\geq k$ 且 $L=a_0+a_1+a_2+\\cdots+a_9$ 尽可能小. 一种贪心的策略我们知道, 根据均值不等式, 对于长度为 $n$ 的正有限实数列 ${a_i}$, 有 $$\\sqrt[n]{\\prod^{n}{i=1}{a_i}}\\leq\\sum^{n}{i=1}{a_i},$$ 当且仅当 ${a_i}$ 是常数列时取等号. 对于本题, 可以猜想: 当左式恒定, 即 $l$ 恒定时, 若要使右式 (也即 $L$) 尽可能小, 则需要选择相差不大的 $a_i(i=0,1,\\cdots,9)$. 这即是一种贪心策略. 我们希望 $a_i$ 的极差尽可能小, 一种选择方法是令其中一部分 $a_i$ 比另一部分恰好大 $1$ (当然理想情况是这些 $a_i$ 都相等). 不妨假设 $a_0,a_1,\\cdots,a_{m-1}$ ($m=0,1,\\cdots,10$, 当 $m=0$ 时规定 $a_i=a$, 当 $m=10$ 时规定 $a_i=a+1$) 都等于 $a+1(a\\in\\mathbb{N}^{*})$, $a_m,a_{m+1},\\cdots,a_9$ 都等于 $a$. 那么 $$l=(a+1)^{10-m}a^m,\\L=(10-m)(a+1)+ma=10a-m+10.$$ $a$ 和 $m$ 的确定首先我们关注 $m=10$ 即 $l=a^{10}$ 的情况. 注意到此时若要使 $l\\geq k$, 则 $a\\geq\\sqrt[10]{k}$. 而当 $a$ 固定时, 对于不同的 $m$, 有 $\\sup l=(a+1)^{10}$, $\\inf l=a^{10}$, 且考虑到当 $a_p&gt;a_q$ 时恒有 $\\left.L\\right|{a=a_p}\\geq\\left.L\\right|{a=a_q}$, 则 $a$ 可以选取 $\\lfloor\\sqrt[10]{k}\\rfloor$. 对于 $m$, 理论上根据 $l\\geq k$ 可以推导得到 $m\\leq\\dfrac{10\\ln(a+1)-\\ln k}{\\ln(a+1)-\\ln a}$, 但在实际编程中考虑到浮点数存在的误差 (直接用此式计算无法通过 Codeforces 测试集), 我们需要利用大整数 (long long unsigned 足够) 从 $m=0$ 或 $m=10$ 开始逐个测试 (理论上也可以使用二分查找, 但本题的数据规模下不必要), 直到找到符合要求的 $m$. 为方便起见, 确定 $a$ 的过程依然使用了对数法, 同时为尽可能保证计算准确, 代码中使用了自定义的下取整函数 better_floor(). 在 Python 中, 考虑到其原生支持处理超长整数, 对上述推导公式修改为 $k(a+1)^m\\leq a^m(a+1)^{10}$, 同样可以达到题意所需要求, 而这式两边即对应下述代码中的 left 和 right. 代码C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define EPS (1e-14)using namespace std;const string base(&quot;codeforces&quot;);double better_floor(double x){ double y = ceil(x); return (y - x &lt; EPS ? y : floor(x));}int calc_m(long long unsigned k, int a){ long long unsigned l = 1; int m = 10; for (int i = 0; i &lt; m; ++i) { l *= a; } while (l &lt; k &amp;&amp; m-- &gt;= 0) { l = l * (a + 1) / a; } return m;}int main(){ long long unsigned k; int a, m; cin &gt;&gt; k; a = int(better_floor(pow(k, 0.1))); m = calc_m(k, a); for (int i = 0; i &lt; 10 - m; ++i) { cout &lt;&lt; string(a + 1, base[i]); } for (int i = 10 - m; i &lt; 10; ++i) { cout &lt;&lt; string(a, base[i]); } return 0;} Python123456789101112131415161718def calc_m3(k, a): left, right = k, (a + 1) ** 10 for i in range(1, 12): left *= a + 1 right *= a if left &gt; right: return i - 1 return -1k = int(input())base = 'codeforces'a = int(k ** 0.1)m = calc_m3(k, a)for i in range(10 - m): print(base[i] * (a + 1), end='')for i in range(10 - m, 10): print(base[i] * a, end='')","link":"/acmoi/codeforces/1368b/"},{"title":"Codeforces 1430C: Numbers on Whiteboard","text":"Codeforces 1430C C++ 一解. 分析白板上的数字初始状态是固定的 $1,2,\\cdots,n$. 每次操作都会 “折损” 当下所有数字之和, 而 “折损” 的量即为选定的两个数之和的一半. 因此为使最后得到的数字最小, 一种贪心的方法是每次选择最大的两个数字做操作. 操作时对于两数之和为奇数的, 得到的新数字需要向上取整. 虽然有 “凭空” 增大数字总和的可能性, 但经过数学归纳即可得知最后一次操作选定的数字一定是 $1$ 和 $3$ $(n&gt;2)$ 或 $1$ 和 $2$ $(n=2)$, 也即最后得到的数字为 $2$. 显然若要得到小于 $2$ 的数字, 需要在倒数第二次操作时白板上只剩下两个 $1$, 而这在向上取整的规则下是做不到的. 因此这种贪心方法即为最优解. 空间和时间优化因为白板数字的初始状态是规律性的连续自然数列, 选定数字的过程也极为规律, 无需要实际使用栈等数据结构模拟. 官方题解则提供了使用实际数据结构 vector&lt;int&gt; 的方法. 代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;void solveAndPrint(int n){ cout &lt;&lt; 2 &lt;&lt; endl; cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; endl; for (int i = 2; i &lt; n; ++i) { cout &lt;&lt; n - i &lt;&lt; ' ' &lt;&lt; n - i + 2 &lt;&lt; endl; }}int main(){ int t, n; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; solveAndPrint(n); } return 0;}","link":"/acmoi/codeforces/1430c/"},{"title":"Codeforces 1399D: Binary String to Subsequences","text":"Codeforces 1399D C++ 一解. 分析本题本身的思路是很清晰的, 但考虑到一些极端数据, 需要额外添加一些数据结构. 可以确定的是, 给定的字符串的每个字符都要纳入某一个子序列中. 同时可以注意到, 如果已经存在一些子序列, 对于源串的某个字符, 只要其能接在某个子序列之后, 就不会增加现有子序列的数量; 若这个字符无法接在任何现有子序列之后, 拆开其中一部分子序列使其能够纳入也不会使子序列数量减少. 因此这种策略是最优的. 本题给定的数据规模 $\\sum n\\leq2\\times10^5$. 若每次尝试添加字符到子序列时都顺序搜索现有子序列, 部分测试点无法通过 (例如: 1231200000111111111111... (200000 个 1) ). 因此可以设置两个栈结构用于存储现有的 “尾数” 为 0 和 1 的子序列的序号. 因为只需要构造出一种可行的组合子序列的方案即可, 只需要对栈作入栈, 出栈操作, 其时间开销可以接受. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;char change_bit(char x){ return x == '1' ? '0' : '1';}int change_bit(int x){ return x ? 0 : 1;}int get_bit(char x){ return x - '0';}void solve_and_print(string s){ int n = s.length(), total = 0; vector&lt;int&gt; ans(n, 0), stack[2]; for (int i = 0; i &lt; n; ++i) { char c = change_bit(s[i]); int x = get_bit(c), y = get_bit(s[i]); if (stack[x].empty()) { ++total; ans[i] = total; stack[y].push_back(total - 1); } else { int j = stack[x].back(); stack[x].pop_back(); stack[y].push_back(j); ans[i] = j + 1; } } cout &lt;&lt; total &lt;&lt; endl; for (int i = 0; i &lt; n; ++i) { cout &lt;&lt; ans[i] &lt;&lt; ' '; } cout &lt;&lt; endl;}int main(){ ios_base::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t, n; string s; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; s; solve_and_print(s); } return 0;}","link":"/acmoi/codeforces/1399d/"},{"title":"【Arch Linux】编译安装 AUR 上的 Linux 内核","text":"Arch Linux 可以使用多种 Linux 内核. 默认的内核由官方 core 仓库的 linux 包提供, 一般另附有 linux-headers 包. 官方仓库中提供的预编译内核还有同为 core 仓库的 linux-lts 和 extra 仓库的 linux-zen. 不过, 在一些场合下, 例如需要更新的或是有 patch 的内核时, 我们可能需要从 AUR 中获取需要的内核并手动编译安装. 本文以 linux-mainline 包为例, 主要借助 yay 更便捷地处理相关操作. 通常情况下, 只需要 yay -S linux-mainline 即可. 以下需要对编译安装过程做一些可选操作. 获取 PKGBUILD使用 yay 的 -G 选项仅获得 PKGBUILD 等相关的文件. 添加 --force 以强制保持与上游 AUR 包内容一致. 由于该操作默认目标文件夹为当前文件夹, 所以可以切换到 ~/.cache/yay 后再获取. 12mkdir -p ~/.cache/yay &amp;&amp; cd ~/.cache/yayyay -G --force linux-mainline (可选) 修改上游仓库 URL进入 linux-mainline 文件夹查看 PKGBUILD 后可以发现其从 &lt;kernel.org&gt; 的 Git 服务器获取上游的 Linux 源码: 123456...source=( &quot;$_srcname::git+https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git#tag=$_tag&quot; config # the main kernel config file)... 但是完整的 Linux 仓库体积已经超过 2 GB, 对于中国大陆用户不够友好. 好在 &lt;kernel.org&gt; 在北京已经设置 Git 镜像: https://kernel.source.codeaurora.cn/. 所以我们可以修改上游仓库的 URL, 以提高下载速度. 在编辑器中打开 PKGBUILD: 123426c26&lt; &quot;$_srcname::git+https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git#tag=$_tag&quot;---&gt; &quot;$_srcname::git+https://kernel.source.codeaurora.cn/pub/scm/linux/kernel/git/torvalds/linux.git#tag=$_tag&quot; 或者是执行下面的命令修改: 1sed -i 's/git+https\\:\\/\\/git\\.kernel\\.org\\/pub\\/scm\\/linux\\/kernel\\/git\\/torvalds\\/linux\\.git/git+https:\\/\\/kernel.source.codeaurora.cn\\/pub\\/scm\\/linux\\/kernel\\/git\\/torvalds\\/linux.git/' PKGBUILD 此外, 还可以通过 yay 的 --editmenu 参数交互式编辑: 1yay -S --editmenu linux-mainline (可选) 获取 PGP 密钥查看 PKGBUILD 可以看到用户需要接受三个 PGP 密钥, 分别是: 1234567...validpgpkeys=( 'ABAF11C65A2970B130ABE3C479BE3E4300411886' # Linus Torvalds '647F28654894E3BD457199BE38DBBDC86092693E' # Greg Kroah-Hartman 'A2FF3A36AAA56654109064AB19802F8B0D70FC30' # Jan Alexander Steffens (heftig))... 但是安装过程中可能发现 yay 卡在获取密钥的部分. 对于后两个密钥, 可以通过:^1 12gpg --keyserver hkp://keys.openpgp.org --recv-keys 647F28654894E3BD457199BE38DBBDC86092693Egpg --keyserver hkp://keys.openpgp.org --recv-keys A2FF3A36AAA56654109064AB19802F8B0D70FC30 获取. 这个选项可以持久化:^2 1yay -Y --gpgflags &quot;--keyserver hkp://keys.openpgp.org&quot; --save 不过对于第一个密钥, 可能需要其他的方法. 首先保证存在 gpg2 (对应包为 core 仓库的 gnupg), 再: 1gpg2 --auto-key-locate cert,pka,dane,wkd,keyserver --locate-keys torvalds@kernel.org (可选) 多线程编译安装需要手动传入 make 命令的编译 flags: 1MAKEFLAGS=&quot;-j16&quot; yay -S linux-mainline # 16 线程 多线程编译仍然可能需要较长时间 (笔者测试需要 30 分钟左右, 因机器配置而异). 请不要断电. 更新 Boot loader 配置以 GRUB 为例: 1sudo grub-mkconfig -o /boot/grub/grub.cfg 重启这是非常重要的 - 否则折腾半天系统服务没法加载的时候会很痛苦. 参考","link":"/techdev/arch/kernel-compilation/"}],"tags":[{"name":"ACG","slug":"ACG","link":"/tags/ACG/"},{"name":"Music","slug":"Music","link":"/tags/Music/"},{"name":"Ceui","slug":"Ceui","link":"/tags/Ceui/"},{"name":"现在就想告诉哥哥，我是妹妹！","slug":"现在就想告诉哥哥，我是妹妹！","link":"/tags/%E7%8E%B0%E5%9C%A8%E5%B0%B1%E6%83%B3%E5%91%8A%E8%AF%89%E5%93%A5%E5%93%A5%EF%BC%8C%E6%88%91%E6%98%AF%E5%A6%B9%E5%A6%B9%EF%BC%81/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Arch Linux","slug":"Arch-Linux","link":"/tags/Arch-Linux/"},{"name":"Time","slug":"Time","link":"/tags/Time/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"Simplified Chinese","slug":"Simplified-Chinese","link":"/tags/Simplified-Chinese/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"OI","slug":"OI","link":"/tags/OI/"},{"name":"Lanqiao","slug":"Lanqiao","link":"/tags/Lanqiao/"},{"name":"Problem","slug":"Problem","link":"/tags/Problem/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Performance","slug":"Performance","link":"/tags/Performance/"},{"name":"RPG","slug":"RPG","link":"/tags/RPG/"},{"name":"Continuous Infinity","slug":"Continuous-Infinity","link":"/tags/Continuous-Infinity/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"File Format","slug":"File-Format","link":"/tags/File-Format/"},{"name":"ePub","slug":"ePub","link":"/tags/ePub/"},{"name":"Boot Loader","slug":"Boot-Loader","link":"/tags/Boot-Loader/"},{"name":"Desktop","slug":"Desktop","link":"/tags/Desktop/"},{"name":"misskey","slug":"misskey","link":"/tags/misskey/"},{"name":"maddy","slug":"maddy","link":"/tags/maddy/"},{"name":"Email","slug":"Email","link":"/tags/Email/"},{"name":"Localization","slug":"Localization","link":"/tags/Localization/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"Solution","slug":"Solution","link":"/tags/Solution/"},{"name":"Kernel","slug":"Kernel","link":"/tags/Kernel/"},{"name":"AUR","slug":"AUR","link":"/tags/AUR/"},{"name":"Compilation","slug":"Compilation","link":"/tags/Compilation/"}],"categories":[{"name":"Share","slug":"Share","link":"/categories/Share/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"Translation","slug":"Translation","link":"/categories/Translation/"},{"name":"Record","slug":"Record","link":"/categories/Record/"},{"name":"Tutorial","slug":"Essay/Tutorial","link":"/categories/Essay/Tutorial/"}]}