{"posts":[{"title":"【ACG音乐分享】Ceui《今、歩き出す君へ》","text":"《今、歩き出す君へ》是日本公司 fairys 制作的恋爱 AVG 《いますぐお兄ちゃんに妹だっていいたい！》的插曲，由 Ceui 演唱。 《今、歩き出す君へ》（此刻，致迈步向前的你）是日本公司 fairys 制作的恋爱 AVG 《いますぐお兄ちゃんに妹だっていいたい！》（现在就想告诉哥哥，我是妹妹！）的插曲，由 Ceui 演唱，被收录于专辑《PCゲーム『いますぐお兄ちゃんに妹だっていいたい！』ボーカルアルバム》。 图源为亚马逊商城。 歌词歌词原作者为网易云音乐用户虚伪的祈愿。 日文歌词123456789101112131415161718192021222324252627282930313233343536心の中で描いた地図は行き止まりばかり 迷路みたいできっと誰もが傷つきながら心に鍵かけて泣いているんだろういつも強がって 自分を奮い立たせ溢れる人ごみの中 遠い空、見上げてた過去の言葉より 未来のノートを開こうつまづいた分だけ 少しずつ 強くなれるよ世界でひとつの君という奇跡がモノクロの世界を色鮮やかに変えてゆく生きていく意味を見出すことが出来たなら描く未来は 君から始まる勇気上手く行かずに 臆病になって自分らしささえ 見失っても握り締めてる 熱い想いをずっと忘れずに 歩き続けたい夢を追いかけた 少年の日の輝き誰もが抱きしめながら 同じ今を生きてる寂しい夜だって 誰かと繋がってる気持ち心のどこかで いつも信じていたいんだ世界でひとつの明日という未来が小さな涙の種を大きな花へ変える生きていく意味を見出すことが出来たなら昨日までの自分を越えられるはず理想や憧れが大きすぎてつらくなったらありのままの心で君に語りかけよう回り道のどこかで 道なき道のどこかで出会えるかもしれない その時は笑顔で…世界でひとつの君という奇跡が消えない希望を僕に教えてくれたんだ生きていく意味は いつでもその胸にあるよ描く未来は もうすぐその先に世界でひとつの君という光が小さなこの地球のなか 広がる闇を照らす繋がる空の下 さあ自分らしく進もう始まりの詩贈るよ 歩き出す君へ 日文歌词 LRC 格式 1234567891011121314151617181920212223242526272829303132333435363738[00:00.000] 作词 : Ceui[00:01.000] 作曲 : 小高光太郎[00:21.930]心の中で描いた地図は[00:27.670]行き止まりばかり 迷路みたいで[00:33.040]きっと誰もが傷つきながら[00:38.430]心に鍵かけて泣いているんだろう[00:44.100]いつも強がって 自分を奮い立たせ[00:49.430]溢れる人ごみの中 遠い空、見上げてた[00:54.960]過去の言葉より 未来のノートを開こう[01:00.650]つまづいた分だけ 少しずつ 強くなれるよ[01:08.870]世界でひとつの君という奇跡が[01:14.150]モノクロの世界を色鮮やかに変えてゆく[01:19.780]生きていく意味を見出すことが出来たなら[01:26.200]描く未来は 君から始まる勇気[01:41.530]上手く行かずに 臆病になって[01:47.260]自分らしささえ 見失っても[01:52.500]握り締めてる 熱い想いを[01:58.120]ずっと忘れずに 歩き続けたい[02:03.740]夢を追いかけた 少年の日の輝き[02:09.020]誰もが抱きしめながら 同じ今を生きてる[02:14.600]寂しい夜だって 誰かと繋がってる気持ち[02:20.130]心のどこかで いつも信じていたいんだ[02:28.450]世界でひとつの明日という未来が[02:33.680]小さな涙の種を大きな花へ変える[02:39.410]生きていく意味を見出すことが出来たなら[02:45.830]昨日までの自分を越えられるはず[02:52.900]理想や憧れが大きすぎてつらくなったら[02:58.530]ありのままの心で君に語りかけよう[03:04.160]回り道のどこかで 道なき道のどこかで[03:09.480]出会えるかもしれない その時は笑顔で…[03:28.600]世界でひとつの君という奇跡が消えない希望を[03:36.480]僕に教えてくれたんだ[03:39.960]生きていく意味は いつでもその胸にあるよ[03:45.830]描く未来は もうすぐその先に[03:50.760]世界でひとつの君という光が[03:56.180]小さなこの地球のなか 広がる闇を照らす[04:01.560]繋がる空の下 さあ自分らしく進もう[04:08.280]始まりの詩贈るよ 歩き出す君へ 中文歌词123456789101112131415161718192021222324252627282930313233343536曾近绘于心的地图如同迷路了一般 总是处处碰壁谁都一样 都是在受伤时闭上自己的心扉哭泣着吧一直故作坚强 让自己奋起直追在这比肩接踵的人群中 仰望那遥远的天空抛弃过去的只言片语 打开那未来的一页吧在失足倒地后 慢慢坚强起来在这世间 有一个被称为「你」的奇迹让这黑白两色的世界变得五彩斑斓若能找到活下去的意义从中描绘出的未来 便是源自于你的勇气无法好好前进 变得胆怯懦弱就算心中的真实逐渐迷失也绝不会放手 绝不会忘怀那份热切的思念 坚持一步步前行追逐着梦想的少年 每一天都闪耀着光辉谁都会拥抱着 那不变的当下生活下去寂寞的夜晚里 也会感到和某人心心相印在心中的某处 一直这样坚信不疑在这世间 有一种被称为「明天」的未来将小小的泪珠变化为大大的花儿若能说出活下去的意义就一定会超越昨日的自己理想与憧憬太过宏大 变得举步维艰之时就用那毫无掩饰的心向你细细诉说吧在刻意绕远的道路某处 在没有尽头的道路某处也许会再次 和那时的笑颜相遇吧····在这世间 有一个被称为「你」的奇迹带给了我永不消逝的希望那活下去的意义 一直都在这心中哦描绘的未来 就在不远的前方在这世间 有一道被称为「你」的光芒在这小小的地球上不断扩大 照亮了黑暗彼此相连的青空之下 来吧 用自己独有的方式前进将这起始的诗篇 赠与迈出步伐的你 中文歌词 LRC 格式 12345678910111213141516171819202122232425262728293031323334353637[by:请不要在意我的昵称][00:21.930]曾近绘于心的地图[00:27.670]如同迷路了一般 总是处处碰壁[00:33.040]谁都一样 都是在受伤时[00:38.430]闭上自己的心扉哭泣着吧[00:44.100]一直故作坚强 让自己奋起直追[00:49.430]在这比肩接踵的人群中 仰望那遥远的天空[00:54.960]抛弃过去的只言片语 打开那未来的一页吧[01:00.650]在失足倒地后 慢慢坚强起来[01:08.870]在这世间 有一个被称为「你」的奇迹[01:14.150]让这黑白两色的世界变得五彩斑斓[01:19.780]若能找到活下去的意义[01:26.200]从中描绘出的未来 便是源自于你的勇气[01:41.530]无法好好前进 变得胆怯懦弱[01:47.260]就算心中的真实逐渐迷失[01:52.500]也绝不会放手 绝不会忘怀[01:58.120]那份热切的思念 坚持一步步前行[02:03.740]追逐着梦想的少年 每一天都闪耀着光辉[02:09.020]谁都会拥抱着 那不变的当下生活下去[02:14.600]寂寞的夜晚里 也会感到和某人心心相印[02:20.130]在心中的某处 一直这样坚信不疑[02:28.450]在这世间 有一种被称为「明天」的未来[02:33.680]将小小的泪珠变化为大大的花儿[02:39.410]若能说出活下去的意义[02:45.830]就一定会超越昨日的自己[02:52.900]理想与憧憬太过宏大 变得举步维艰之时[02:58.530]就用那毫无掩饰的心向你细细诉说吧[03:04.160]在刻意绕远的道路某处 在没有尽头的道路某处[03:09.480]也许会再次 和那时的笑颜相遇吧····[03:28.600]在这世间 有一个被称为「你」的奇迹[03:36.480]带给了我永不消逝的希望[03:39.960]那活下去的意义 一直都在这心中哦[03:45.830]描绘的未来 就在不远的前方[03:50.760]在这世间 有一道被称为「你」的光芒[03:56.180]在这小小的地球上不断扩大 照亮了黑暗[04:01.560]彼此相连的青空之下 来吧 用自己独有的方式前进[04:08.280]将这起始的诗篇 赠与迈出步伐的你 相关链接 网易云音乐： https://music.163.com/#/song?id=26209670 萌娘百科同名词条： https://zh.moegirl.org.cn/此刻，致迈步向前的你 萌娘百科“Ceui”词条： https://zh.moegirl.org.cn/Ceui 萌娘百科“现在就想告诉哥哥,我是妹妹!”词条： https://zh.moegirl.org.cn/现在就想告诉哥哥,我是妹妹!","link":"/acg/ima-aruki-dasu-kimi-e/"},{"title":"使用 GPG 加密、解密和验证信息","text":"本文将主要利用 GNU Privacy Guard (简称 “GnuPG” 或 “GPG”) 完成信息的加密, 解密和验证任务. 本文不会对 GPG 的工作原理以及 OpenPGP 的规范 (参见 RFC 4880) 做过多的解读. 仅针对完成上述的任务而言, 只需要对其了解大体的情况即可. 简要原理 以上截取自 Pretty Good Privacy 维基词条的 SVG 图像 (可能需要切换为亮色模式以看清图中的文字). 其中的大部分工作将会由 GPG 完成. 读者需要注意的是从图中可以看到 “receiver’s public key” 和 “receiver’s private key” - 这暗示 OpenPGP 标准中存在 “公钥” 和 “私钥” 两个概念, 且这两种密钥都归属于同一个人. 加密时, 信息发送者需要信息接收者的公钥; 解密时, 信息接收者需要自己的私钥. 测试环境笔者将主要使用本机的 Arch Linux 进行测试和演示. 同时会利用一台远端的 Linux 服务器用以演示双方通信操作. 涉及软件包 core/gnupg - 提供 gpg core/coreutils - 提供 tr, head core/openssh - 提供 ssh, scp 信息本文中涉及到本地机器的所有工作将在 ~/Temp/gpg 文件夹下进行. 该文件夹下有需要传输的信息 message.txt: 12$ cat message.txt CjYIdc[&quot;Ns`3[BA\\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A'R_h!9SU2v$oJ2SIKGp&quot;l 信息收发双方 角色 用户名 邮箱 发送者 test1 test1@foo.bar 接收者 test2 test2@foo.bar 准备安装 GPGLinux 环境无需多言. 对于 Windows 可以选择 Gpg4win - 这是一个 GPG 在 Windows 上的实现. 生成强密码后续的操作中可能会涉及到生成强密码的需求. 自然, 一个可以在脑中记住的强密码是最好不过的, 不过这里将演示一个利用 /dev/urandom 生成高强度密码的方法: 12$ tr -dc &quot;[:graph:]&quot; &lt; /dev/urandom | head -c 64; echo ''Q-SU0QZA:{6h%LLoR@Bd2M#jPOb.nu8&amp;xcimt}atyo|G]O{Ay&gt;+R;T'gGrUH)bWk 其主要原理是, tr 可以 “translate or delete characters”^1. tr 从 /dev/urandom 设备文件中获取到随机字符流后, 可以仅保留符合 [:graph:] 条件 (“all printable characters, not including space”^1) 的字符, 再让 head 截取其中的前 64 个字符即可. 由此得到的则是长度为 64 的随机可见字符串. 同理, 若要生成 32 位仅包含小写字母和数字的字符串: 12$ tr -dc &quot;a-z0-9&quot; &lt; /dev/urandom | head -c 32; echo ''b2ylyqcs9x5gureu43b3ycw9txgww5sb 生成低熵随机数一些无头服务器可能无法满足 “低熵” 的条件, 从而导致生成的随机数不满足一些安全性要求较高的程序 (例如本文提到的 GPG) 的需求. Linux 上可以借助 haveged, rng-tools 等来避免这种情况. 本文不再赘述. 密钥操作生成密钥使用 gpg --full-generate-key 来生成一个密钥对. 以下的代码块记录了终端中回显的整个过程. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$ gpg --full-generate-key gpg (GnuPG) 2.2.40; Copyright (C) 2022 g10 Code GmbHThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from cardYour selection? 1RSA keys may be between 1024 and 4096 bits long.What keysize do you want? (3072) 4096Requested keysize is 4096 bitsPlease specify how long the key should be valid. 0 = key does not expire &lt;n&gt; = key expires in n days &lt;n&gt;w = key expires in n weeks &lt;n&gt;m = key expires in n months &lt;n&gt;y = key expires in n yearsKey is valid for? (0) 0Key does not expire at allIs this correct? (y/N) yGnuPG needs to construct a user ID to identify your key.Real name: test1Email address: test1@foo.barComment: test1's PGP keyYou selected this USER-ID: &quot;test1 (test1's PGP key) &lt;test1@foo.bar&gt;&quot;Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? oWe need to generate a lot of random bytes. It is a good idea to performsome other action (type on the keyboard, move the mouse, utilize thedisks) during the prime generation; this gives the random numbergenerator a better chance to gain enough entropy.We need to generate a lot of random bytes. It is a good idea to performsome other action (type on the keyboard, move the mouse, utilize thedisks) during the prime generation; this gives the random numbergenerator a better chance to gain enough entropy.gpg: revocation certificate stored as '/home/littleye233/.gnupg/openpgp-revocs.d/EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198.rev'public and secret key created and signed.pub rsa4096 2022-12-09 [SC] EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198uid test1 (test1's PGP key) &lt;test1@foo.bar&gt;sub rsa4096 2022-12-09 [E] 其中需要用户回答如下几个问题: 密钥的种类 - RSA and RSA RSA 密钥的长度 - 4096 密钥的有效期 - key does not expire 确认信息正确性 - y 真实姓名 - test1 电子邮件地址 - test1@foo.bar 注释 - test1's PGP key 确认信息正确性 - o (未回显) (可选) 密码片语 (passphrase) 若设置密码片语, 在解密时则需要输入该字符串. 查看密钥查看本机中导入或生成的密钥有多种形式. 列出私钥和指纹123456789101112$ gpg --list-secret-keys --keyid-format=long --with-fingerprintgpg: checking the trustdbgpg: marginals needed: 3 completes needed: 1 trust model: pgpgpg: depth: 0 valid: 11 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 11u/home/littleye233/.gnupg/pubring.kbx------------------------------------... 省略多个私钥 ...sec rsa4096/46D85BAE755DB198 2022-12-09 [SC] Key fingerprint = EB28 C6D4 2ACF C179 8DC7 D1CB 46D8 5BAE 755D B198uid [ultimate] test1 (test1's PGP key) &lt;test1@foo.bar&gt;ssb rsa4096/EEAD650E9DE15AB8 2022-12-09 [E] 列出公钥和指纹123456789$ gpg --list-keys --keyid-format=long --with-fingerprint /home/littleye233/.gnupg/pubring.kbx------------------------------------... 省略多个公钥 ...pub rsa4096/46D85BAE755DB198 2022-12-09 [SC] Key fingerprint = EB28 C6D4 2ACF C179 8DC7 D1CB 46D8 5BAE 755D B198uid [ultimate] test1 (test1's PGP key) &lt;test1@foo.bar&gt;sub rsa4096/EEAD650E9DE15AB8 2022-12-09 [E] 如果仅仅需要获取公钥指纹 (Key fingerprint) 等信息, 这个指令和上一条指令呈现的结果几乎类似. 但前者同时可以列出导入的公钥 - 这对于加密和验证信息的工作很有用. 导出公钥1234$ gpg --export --armor 46D85BAE755DB198-----BEGIN PGP PUBLIC KEY BLOCK-----... 省略具体内容 ...-----END PGP PUBLIC KEY BLOCK----- --armor 选项在 GPG 的帮助文档中有如下说明: 12--armor-a Create ASCII armored output. The default is to create the binary OpenPGP format. 这种输出形式便于在不同机器之间传输密钥^2. 同时这也是一种很好的分享公钥的方式: 1gpg --output test1_at_foo_dot_bar.asc --export --armor 46D85BAE755DB198 值得注意的是, 这里确定密钥使用的是密钥 ID - 46D85BAE755DB198. 事实上, 换用真实姓名和电子邮箱也是可以用来确定密钥的. 这里可以看出, 如果对同一个真实姓名或电子邮箱生成了多个密钥, GPG 在搜索密钥时, 默认会从列表中的第一个符合条件的密钥开始. 这在一些场合下 (例如需要输入密码片语的情景, 此时为了跳过某个密钥可能需要反复关闭输入密码片语的窗口) 可能会比较烦人. 因此, 若确实有需要多个 PGP 密钥的场合, 请最好避免使用相同的真实姓名和电子邮箱. 导出私钥1234$ gpg --export-secret-key 46D85BAE755DB198-----BEGIN PGP PRIVATE KEY BLOCK-----... 省略具体内容 ...-----END PGP PRIVATE KEY BLOCK----- 导入密钥假设 test2 用户发送来了 Ta 的 PGP 公钥 (test2_at_foo_dot_bar.asc), 则此时可以使用 gpg --import 导入: 1gpg --import test2_at_foo_dot_bar.asc 对于远端机器, 则可以使用管道 (pipe)^2: 1234sec rsa4096/11B3A67EC13C2571 2022-12-09 [SC] Key fingerprint = 5359 F3FA 8933 9C43 DB47 61A8 11B3 A67E C13C 2571uid [ultimate] test2 (test2's PGP key) &lt;test2@foo.bar&gt;ssb rsa4096/9C0A6E908BC7D25D 2022-12-09 [E] 1234$ ssh root@54.255.5.62 gpg --export --armor 11B3A67EC13C2571 | gpg --importgpg: key 11B3A67EC13C2571: public key &quot;test2 (test2's PGP key) &lt;test2@foo.bar&gt;&quot; importedgpg: Total number processed: 1gpg: imported: 1 移除密钥移除公钥需要 --delete-keys 选项: 1gpg --delete-keys test2@foo.bar 移除私钥则需要 --delete-secret-keys 选项: 1gpg --delete-secret-keys test2@foo.bar 设置信任等级默认导入的密钥的信任等级是 “unknown”. 在后续解密和验证信息的时候, 则可能会出现如下的输出: 123gpg: WARNING: This key is not certified with a trusted signature!gpg: There is no indication that the signature belongs to the owner.Primary key fingerprint: EB28 C6D4 2ACF C179 8DC7 D1CB 46D8 5BAE 755D B198 此时则需要将信任等级更改为 “utimate” - 与本地生成的密钥的信任等级相同. 具体操作则是执行 gpg --edit-key. 例如, 在 test2 用户的远端服务器上更改 test1 用户的 PGP 密钥的信任等级时: 1234567891011121314151617181920212223242526272829303132333435363738394041424344$ gpg --edit-key test1@foo.bargpg (GnuPG) 2.2.27; Copyright (C) 2021 Free Software Foundation, Inc.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.pub rsa4096/46D85BAE755DB198 created: 2022-12-09 expires: never usage: SC trust: full validity: unknownsub rsa4096/EEAD650E9DE15AB8 created: 2022-12-09 expires: never usage: E [ unknown] (1). test1 (test1's PGP key) &lt;test1@foo.bar&gt;gpg&gt; trustpub rsa4096/46D85BAE755DB198 created: 2022-12-09 expires: never usage: SC trust: full validity: unknownsub rsa4096/EEAD650E9DE15AB8 created: 2022-12-09 expires: never usage: E [ unknown] (1). test1 (test1's PGP key) &lt;test1@foo.bar&gt;Please decide how far you trust this user to correctly verify other users' keys(by looking at passports, checking fingerprints from different sources, etc.) 1 = I don't know or won't say 2 = I do NOT trust 3 = I trust marginally 4 = I trust fully 5 = I trust ultimately m = back to the main menuYour decision? 5Do you really want to set this key to ultimate trust? (y/N) ypub rsa4096/46D85BAE755DB198 created: 2022-12-09 expires: never usage: SC trust: ultimate validity: unknownsub rsa4096/EEAD650E9DE15AB8 created: 2022-12-09 expires: never usage: E [ unknown] (1). test1 (test1's PGP key) &lt;test1@foo.bar&gt;Please note that the shown key validity is not necessarily correctunless you restart the program.gpg&gt; q 信息加密正如前文所述, 信息的加密需要信息接收者的公钥. 而刚刚笔者已经导入了 test2 用户的公钥. 现在则需要 --encrypt 选项来进行加密: 1gpg --encrypt --armor --recipient test2@foo.bar message.txt --armor 的作用略去不提. --recipient 用以指定信息接收方 (这样其就可以使用自己的私钥解密), 可以指定多个 (诸如 --recipient email1 --recipient email2 的格式). 命令执行成功后, 当前目录会生成一个扩展名为 .asc 的文件 (message.txt.asc). 使用 file 查看其文件信息, 得到: 12$ file message.txt.asc message.txt.asc: PGP message Public-Key Encrypted Session Key (old) 签名--sign 可以表明信息的发送者是谁. 默认签名使用 “默认密钥” (若未明确设置, 则是密钥列表的第一个密钥). 若要显式指定一个密钥, 则需要使用 --local-user 选项. 另外换用 --default-key 选项可以同时设置 “默认密钥”. 1gpg --encrypt --armor --sign --local-user test1@foo.bar --recipient test2@foo.bar message.txt 当然, 签名操作需要验证签名方的密码片语, 如果有的话. 信息解密解密时, 则需要使用 --decrypt 选项: 1gpg --decrypt message.txt.asc 与加密操作不同的是, 解密时, GPG 会尝试所有的密钥, 无需自行指定密钥. 对于未签名的加密信息, 可能的输出如下: 12345$ gpg --decrypt message.txt.asc CjYIdc[&quot;Ns`3[BA\\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A'R_h!9SU2v$oJ2SIKGp&quot;lgpg: encrypted with RSA key, ID EEAD650E9DE15AB8gpg: encrypted with 4096-bit RSA key, ID 9C0A6E908BC7D25D, created 2022-12-09 &quot;test2 (test2's PGP key) &lt;test2@foo.bar&gt;&quot; 对于已签名的加密信息, 在信息发送者的公钥未导入时, 此时无法检查签名, 可能的输出如下: 12345678$ gpg --decrypt message.txt.ascCjYIdc[&quot;Ns`3[BA\\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A'R_h!9SU2v$oJ2SIKGp&quot;lgpg: encrypted with 4096-bit RSA key, ID 9C0A6E908BC7D25D, created 2022-12-09 &quot;test2 (test2's PGP key) &lt;test2@foo.bar&gt;&quot;gpg: Signature made Fri 09 Dec 2022 04:25:43 PM UTCgpg: using RSA key EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198gpg: issuer &quot;test1@foo.bar&quot;gpg: Can't check signature: No public key 导入并设置信任等级后, 可能的输出如下: 123456789101112$ gpg --decrypt message.txt.asc CjYIdc[&quot;Ns`3[BA\\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A'R_h!9SU2v$oJ2SIKGp&quot;lgpg: encrypted with 4096-bit RSA key, ID 9C0A6E908BC7D25D, created 2022-12-09 &quot;test2 (test2's PGP key) &lt;test2@foo.bar&gt;&quot;CjYIdc[&quot;Ns`3[BA\\=5#+TM&lt;[ORUhQ|i-E&gt;!S0e!hc_A'R_h!9SU2v$oJ2SIKGp&quot;lgpg: Signature made Fri 09 Dec 2022 04:25:43 PM UTCgpg: using RSA key EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198gpg: issuer &quot;test1@foo.bar&quot;gpg: checking the trustdbgpg: marginals needed: 3 completes needed: 1 trust model: pgpgpg: depth: 0 valid: 4 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 4ugpg: Good signature from &quot;test1 (test1's PGP key) &lt;test1@foo.bar&gt;&quot; [ultimate] 信息验证分离密钥之前生成的加密文件 message.txt.asc 包含了原始文件的信息. 如下的命令使用了 --detach-sign 选项, 则是生成一个分离式 (detached) 的密钥. 这可以用来在无需加密的场合验证身份: 1gpg --local-user 46D85BAE755DB198 --output message.txt.asc --detach-sign --armor message.txt 验证1234$ gpg --verify message.txt.asc message.txtgpg: Signature made Sat 10 Dec 2022 12:46:26 AM CSTgpg: using RSA key EB28C6D42ACFC1798DC7D1CB46D85BAE755DB198gpg: Good signature from &quot;test1 (test1's PGP key) &lt;test1@foo.bar&gt;&quot; [ultimate] 脚注","link":"/techdev/gpg-encryption-decryption-validation/"},{"title":"【翻译】如何编写 Git 提交消息","text":"《【翻译】如何编写 Git 提交消息》[^1]的简体中文翻译版本对应原文为 How to Write a Git Commit Message ，原作者为 Chris Beams 。 《【翻译】如何编写 Git 提交消息》[^1]的简体中文翻译版本对应原文为 How to Write a Git Commit Message ，原作者为 Chris Beams 。请注意： 正文格式尽可能与原网页保持一致； 译者注将以脚注 (footnote) 的形式呈现，且其内容应以”译者注：“起始； 原文中若有文内跳转超链接，如无必要，将直接去除，且不在译文中作进一步说明； 原文中若有翻译后难以传达作者写作意图的词句 (通常是命令，或由源语言的特殊性质等原因导致) ，此时将不再翻译，且不在译文中作进一步说明。 翻译文本将从随后的分隔线开始展示。 如何编写 Git 提交信息 原作者： Chris Beams原文创作日期： 2014 年 8 月 31 日 提交消息很重要。这里将展示如何写好它们。 引子：为什么好的提交消息很重要如果你曾随意地浏览过一些 Git 仓库，你很可能会发现它们的提交消息或多或少有些杂乱。例如，你可以看看我早期提交给 Spring 的一些 Gem[^2] 的日志： 1234567$ git log --oneline -5 --author cbeams --before &quot;Fri Mar 26 2009&quot;e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removal in r814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culprits in the recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The test method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTests until further investigation determines why it causes downstream tests to fail (such as the seemingly unrelated ClassPathXmlApplicationContextTests)147709f Tweaks to package-info.java files22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils7f96f57 polishing 呀！再比较一下同一个仓库近期的一些提交的日志： 1234567$ git log --oneline -5 --author pwebb --before &quot;Sat Aug 30 2014&quot;5ba3db6 Fix failing CompositePropertySourceTests84564a0 Rework @PropertySource early parsing logice142fd1 Add tests for ImportSelector meta-data887815f Update docbook dependency and generate epubac8326d Polish mockito usage 你更想去阅读哪一种呢？ 前者的提交消息在长度和形式上各不相同，而后者更加精准和一致；前者是自然而然的结果，而后者绝不会是碰巧写成的。 当许多提交日志类似于前者的仓库随处可见时，也有一些例外存在。 Linux 内核和 Git 自身的源码正是良好的范例。或是看看 Spring Boot 或由 Tim Pope 管理的仓库。 这些仓库的贡献者们知道，一个经过精心打磨的 Git 提交消息是将一个更改与其他开发者 (以及未来的自己) 交流其来龙去脉的最好方式[^3]。一个 diff 的输出结果将告诉你什么改变了，而只有提交消息能恰当地告诉你为什么改变了。 Peter Hutterer 将这个观点表达得很好： 重新确定一段代码的上下文是浪费的。我们不能完全避免它，因此我们应当努力去[竭尽]所能减少这种情况的发生。提交消息能准确地做到这一点，所以一条提交消息能够展示出一位开发者是不是好的协作者。[^4] 如果你还没有很多思路来编写良好的 Git 提交消息，这或许说明你没有花费很多时间使用 git log 命令和相关的工具。这里有一个残酷的循环：因为提交历史是缺少结构和一致性的，某个人不会花费很多时间使用或关心它。并且因为它不被使用或关心，它将始终缺少结构和一致性。 然而，被维护得很好的日志是一种优美和实用的东西，这会让 git blame 、revert 、rebase 、log 、shortlog 和其他子命令充满活力，会给回顾其他人的提交和 pull requests 带来一些价值——并且它们突然能被独立地完成。理解几个月或几年前一些事情为什么发生将不但变得可能，还将变得高效。 一个项目能否取得长远的成功 (相较于其他因素) 不但取决于其可维护性如何，还在于一个维护者是否没有多少比日志更加有力的工具了。我们值得花费一些时间来学习如何适切地维护项目的日志。起初维护日志时可能的困境不久就会转变为习惯，并最终成为所有参与者自豪感和生产力的源泉。 在这篇文章中，我将会告诉你保持一份健康的提交历史的最基础的要素：如何编写一条独立的提交消息。还有其他我在这里不会提及的重要习惯，比如说统整提交[^5]，或许我会在后续的投稿中谈到它们。 大多数编程语言都有着已经成形的惯例，它们构建了符合语言习惯的风格，就像命名、格式等等[^6]。当然，这些惯例有诸多变种，但大部分开发者都认同专注于其中一种的情形远优于每个人各自选用一种造成的混乱局面。 一个团队对待提交日志的方式应当没有丝毫不同。为了创建一份实用的修订历史，团队应该首先在至少符合以下三点的提交消息惯例上达成共识： 风格。标记语言的句法[^7]，折行的间隔，语法[^8]，大小写，标点符号。将这些都明确给出，去除猜测，并且让一切都尽可能简单。最终的结果将会是一份格外一致的日志——不仅阅读起来很愉悦，而且实际上的确能被定期阅读[^9]。 内容。提交消息的主体 (如果有的话) 应该包含什么信息？什么是不能包含的？ 元数据。诸如 issue 的追踪编号[^10]、 pull request 的编号应当如何被提及？ 万幸的是，已经有一些成形的惯例来创建一条符合语言习惯的 Git 提交消息。的确，这些都假定在特定的 Git 命令运作的方式下。这里没有你需要重新发明的地方，只要遵循下方的七条规则，你就推开了像专家一样提交的大门。 编写好的 Git 提交消息的七条规则 请谨记：这些都已被提出过了。 用一个空行分隔标题和主体； 标题控制在 50 个字符以内； 标题的首字母大写； 标题的末尾不要写句号； 标题使用祈使语气； 主体每 72 个字符折行； 用主体解释做了什么和为什么，而不是如何做到。 例如： 123456789101112131415161718192021222324252627Summarize changes in around 50 characters or lessMore detailed explanatory text, if necessary. Wrap it to about 72characters or so. In some contexts, the first line is treated as thesubject of the commit and the rest of the text as the body. Theblank line separating the summary from the body is critical (unlessyou omit the body entirely); various tools like `log`, `shortlog`and `rebase` can get confused if you run the two together.Explain the problem that this commit is solving. Focus on why youare making this change as opposed to how (the code explains that).Are there side effects or other unintuitive consequences of thischange? Here's the place to explain them.Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded by a single space, with blank lines in between, but conventions vary hereIf you use an issue tracker, put references to them at the bottom,like this:Resolves: #123See also: #456, #789 1. 用一个空行分隔标题和主体根据 git commit 命令的帮助页面： 尽管不是必须的，一个好主意是，提交消息以一行简短的 (少于 50 个字符) 概括这个更改的文字为开始，紧接着是一个空行，随后是一段更详细的描述。整段文本的首行将被认作为提交的标题，那个标题将贯穿整个 Git[^11] 。例如， Git-format-patch(1) 将提交转变为邮件，它将提交的标题作为邮件的主题，将剩余的提交内容作为邮件的主体。 首先，不是每一次提交都需要标题和主体。有时一行也很好，尤其是当更改很简单以至于进一步的阐释都不必要的时候。例如： 1Fix typo in introduction to user guide 没有什么是需要解释的了。如果读者想知道这个拼写错误是什么，直接看这个更改本身即可，换句话说使用 git show 、 git diff 或 git log -p 。 如果你想用命令提交，给 git commit 命令添加 -m 选项是很容易的： 1$ git commit -m&quot;Fix typo in introduction to user guide&quot; 然而，当一个提交需要一点解释和上下文时，你需要编写它的主体。例如： 12345Derezz the master control programMCP turned out to be evil and had become intent on world domination.This commit throws Tron's disc into MCP (causing its deresolution)and turns it back into a chess game. 用 -m 选项来写提交消息的主体不是很容易，你最好在一个合适的文本编辑器中编写它。如果你还没有一个编辑器，使用 Git 命令行来设置，参阅 Pro Git 的这一节。 在任何情形下，标题和主体之间的间隔都能在浏览日志时得到回报。这里是完整的日志： 12345678910$ git logcommit 42e769bdf4894310333942ffc5a15151222a87beAuthor: Kevin Flynn &lt;kevin@flynnsarcade.com&gt;Date: Fri Jan 01 00:00:00 1982 -0200 Derezz the master control program MCP turned out to be evil and had become intent on world domination. This commit throws Tron's disc into MCP (causing its deresolution) and turns it back into a chess game. 现在执行 git log --oneline ，这会仅输出标题行： 12$ git log --oneline42e769 Derezz the master control program 或者是执行 git shortlog ，这会按照用户给提交分组，为了简洁，同样会仅输出标题行： 1234567891011121314$ git shortlogKevin Flynn (1): Derezz the master control programAlan Bradley (1): Introduce security program &quot;Tron&quot;Ed Dillinger (3): Rename chess program to &quot;MCP&quot; Modify chess program Upgrade chess programWalter Gibbs (1): Introduce protoype chess program 也有一些 Git 中的其他上下文，它们的标题行和主体的区别被打破了——但它们都无法在二者之间不空行时做得合适[^12]。 2. 标题控制在 50 个字符以内50 个字符不是硬性限制，只是一个经验法则。将标题行控制在这个长度能保证它们是可读的，并且能强迫作者花一些时间思考如何最简洁地解释将要发生什么。 提示：如果你难以概括你提交的内容，或许是因为你一次提交了太多的更改。努力做到原子级提交[^13] (另一篇投稿的话题) 吧。 GitHub 的用户界面全面地意识到了这些惯例。例如，它会在你的标题行超过 50 个字符时警告你： 并且会截断超过 72 个字符的标题行，后续用省略号代替： 因此，争取限制在 50 个字符以内，并把 72 个字符当作是硬性限制。 3. 标题的首字母大写这就跟听起来一样简单。所有的标题行的首字母都需要大写。 例如，用： Accelerate to 88 miles per hour 来替代： accelerate to 88 miles per hour 4. 标题的末尾不要写句号句末标点在标题中时无关紧要的。另外，当你想要控制 50 个字符时，空格是很珍贵的。 例如，用： Open the pod bay doors 来替代： Open the pod bay doors. 5. 标题使用祈使语气祈使语气意思就是“说出或写出类似命令或指示的东西”。以下是一些例子： 清理你的房间 关上这扇门 拿走垃圾 你正在阅读的七条规则的每一条都是用祈使语气写成的 (“主体每 72 个字符折行”以及其他的) 。 祈使语气听起来有一些失礼，这就是为什么我们不常使用，但是这对于 Git 提交的标题来说很完美，其中一个原因是 Git 自身以你的名义创建提交时都是使用祈使语气。 例如，使用 git merge 后的默认提交消息即是： 1Merge branch 'myfeature' 还有使用 git revert 后： 123Revert &quot;Add the thing with the stuff&quot;This reverts commit cc87791524aedd593cff5a74532befe7ab69ce9d. 或者是在 GitHub 的Pull Request 界面点击 “Merge” 按钮时： 1Merge pull request #123 from someuser/somebranch 因此，当你用祈使语气编写提交消息时，你就是在遵守 Git 内置的惯例。例如： Refactor subsystem X for readability Update getting started documentation Remove deprecated methods Release version 1.0.0 起初这样写可能显得有些蠢。我们更常用陈述语气说话，这种语气都是用于描述事实，这就是为什么提交消息很多都像这样结束了： Fixed bug with Y Changing behavior of X 并且有时提交消息写起来就像是它们的内容的描述： More fixes for broken stuff Sweet new API methods 为了去除任何困惑，这里是一条简单的规则来让你每次都能做对： 一个合适的 Git 提交的标题应当总是能完成如下的句子： 如果被应用了，这个提交将会这是你的标题 例如： If applied, this commit will refactor subsystem X for readability If applied, this commit will update getting started documentation If applied, this commit will remove deprecated methods If applied, this commit will release version 1.0.0 If applied, this commit will merge pull request #123 from user/branch 注意到对于非祈使语气，这是不能成功的： If applied, this commit will fixed bug with Y If applied, this commit will changing behavior of X If applied, this commit will more fixes for broken stuff If applied, this commit will sweet new API methods 记住：祈使语气的使用仅对标题很重要。在写主体时，你可以放松这条规定。 6. 主体每 72 个字符折行Git 从来不会自动折行。当你编写一个提交的主体时，你需要注意到它的右边界，并手动折行。 折行的推荐值是 72 个字符，因此 Git 在大体上将对 80 个字符以内的内容保持原样，有足够的空间用于缩进排版。 一个好的文本编辑器能帮到你。 Vim 的配置很容易，例如在编写 Git 提交消息时在 72 个字符处折行。然而，在传统意义上， IDE 对于智能地支持提交消息的折行很糟糕 (尽管 IntelliJ IDEA 在最近的版本中终于做得比以前好了) 。 7. 用主体解释做了什么和为什么，而不是如何做到这里的一条来自 Bitcoin Core 的提交 是解释更改了什么和为什么的最佳范例： 123456789101112131415161718192021commit eb0b56b19017ab5c16c745e6da39c53126924ed6Author: Pieter Wuille &lt;pieter.wuille@gmail.com&gt;Date: Fri Aug 1 22:57:55 2014 +0200 Simplify serialize.h's exception handling Remove the 'state' and 'exceptmask' from serialize.h's stream implementations, as well as related methods. As exceptmask always included 'failbit', and setstate was always called with bits = failbit, all it did was immediately raise an exception. Get rid of those variables, and replace the setstate with direct exception throwing (which also removes some dead code). As a result, good() is never reached after a failure (there are only 2 calls, one of which is in tests), and can just be replaced by !eof(). fail(), clear(n) and exceptions() are just never called. Delete them. 看一看它的完整的 diff 信息，思考这位作者在此时此地花费时间提供代码的上下文节约了其他和未来的提交者多少时间。如果他没有做到，这次提交将很可能会永远被遗忘。 在大多数情况下，你可以省去这个更改如何被做出的细节。在这点上，代码通常能自我解释 (如果这段代码如此复杂以至于它需要用枯燥的语言来解释，那就是源代码注释应该做的事情了) 。只是专注于首先明确更改的原因——你在更改之前所做的事 (以及出现了什么错误) ，它们现在如何工作的，以及为什么你决定用你的方式解决这个问题[^14]。 未来感谢你的维护者可能就是你自己！ 提示学着热爱命令行。把 IDE 抛在脑后。处于诸多原因，比如说 Git 子命令的存在，拥抱命令行是一种明智之举。 Git 有着令人疯狂的力量， IDE 亦然，但这两者体现在不同的方面上。我每天都使用一款 IDE (IntelliJ IDEA) ，也广泛地使用其他的 (Eclipse) ，但我还从没有见过哪款 IDE 的 Git 集成能比得上简单有力的命令行 (一旦你意识到了这点) 。 某些 Git 相关的 IDE 功能是无价的[^15]，就像当你删除文件时执行 git rm ，在你重命名文件的时候用 git 执行正确的命令。而当你开始试着用 IDE 提交、合并、 rebase 或分析高深莫测的历史记录时，一切都会崩溃。 当支配 Git 的全部法力之日到来之时，一切都只剩下命令行。 记住不论你是使用 Bash 、 zsh 还是 PowerShell ，都有 Tab 自动补全脚本来减轻不少记忆子命令和开关的痛苦。 阅读 Pro GitPro Git 在网上可以免费阅读，并且它很美妙。好好利用它吧！ 题图提供者： xkcd 【完】 脚注[^1]: 译者注：”提交消息“原文为 ”commit message“ ，下同。[^2]: 译者注： Spring 库的插件名为 “Gem” 。[^3]: 译者注：原文为 ”The contributors to these repositories know that a well-crafted Git commit message is the best way to communicate context about a change to fellow developers (and indeed to their future selves)“ 。[^4]: 译者注：原文为 ”Re-establishing the context of a piece of code is wasteful. We can’t avoid it completely, so our efforts should go to reducing it [as much] as possible. Commit messages can do exactly that and as a result, a commit message shows whether a developer is a good collaborator“ 。[^5]: 译者注：原文为 “commit squashing” 。[^6]: 译者注：原文为 “Most programming languages have well-established conventions as to what constitutes idiomatic style, i.e. naming, formatting and so on” 。[^7]: 译者注：原文为 “syntax” 。[^8]: 译者注：原文为 “grammar” 。[^9]: 译者注：原文为 “The end result will be a remarkably consistent log that’s not only a pleasure to read but that actually does get read on a regular basis” 。[^10]: 译者注：原文为 “issue tracking IDs” 。[^11]: 译者注：原文为 “ The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git” 。[^12]: 译者注：原文为 “There are a number of other contexts in Git where the distinction between subject line and body kicks in—but none of them work properly without the blank line in between” 。[^13]: 译者注：原文为 “atomic commits” 。[^14]: 译者注：原文为 “Just focus on making clear the reasons why you made the change in the first place—the way things worked before the change (and what was wrong with that), the way they work now, and why you decided to solve it the way you did” 。[^15]: 译者注：原文为 “Certain Git-related IDE functions are invaluable” 。","link":"/techdev/how-to-write-a-git-commit-message-chs/"},{"title":"Linux 时间操作及其同步","text":"本文将以 Arch Linux 为例，讨论 Linux 的时间操作和同步方法。 本文围绕 Linux 的时间将 ArchWiki 上 System time 页面的部分内容做简化，并整理其他文章作为补充，简化理论性，增强可操作性。 概述操作系统的时间 (clock) 由三或四部分决定： 时间值； 是否为 UTC 时间； 时区； （如果有）夏令时。 而操作系统的时间一般有两种：硬件时间和系统时间。 硬件时间硬件时间 (也即真实时间 (Real Time Clock, RTC) 或 CMOS 时钟) 一般只存储时间值，直至 2016 年后 UEFI 硬件支持对时区和夏令时的存储。 系统时间系统时间 (也即软件时间) 可以追踪时间值、时区以及可能存在的夏令时。系统时间由 Linux 内核计算，时间值为 UTC+0 下自 1970 年 1 月 1 日午夜至今的秒数——可以在 time.is 网站查询得到。 尤其需要注意的是：操作系统完全启动后，系统时间与硬件时间是独立的。 读取状态Linux 的时间状态可由 timedatectl 或 timedatectl status 命令获取。输出类似于： 1234567 Local time: Sun 2022-02-27 12:52:24 UTC Universal time: Sun 2022-02-27 12:52:24 UTC RTC time: n/a Time zone: UTC (UTC, +0000)System clock synchronized: yes NTP service: active RTC in local TZ: no 我们可以得知： 本地时间值和 UTC 时间值均为 Sun 2022-02-27 12:52:24 UTC； 硬件时间不存在； 时区为 UTC (UTC+0)； 已经开启系统时间同步。 硬件时间上方的示例中硬件时间 (RTC time) 显示为“n/a”，也就是不存在。在一部存在硬件时间的 Linux 设备上，可以执行 hwclock --show 查看硬件时间： 12$ hwclock --show2022-02-27 21:14:16.129670+08:00 比 timedatectl 更进一步的是，hwclock 可以显示有关硬件时间的更详细信息： 12345678910111213$ hwclock --verbosehwclock from util-linux 2.34System Time: 1645967662.035542Trying to open: /dev/rtc0Using the rtc interface to the clock.Assuming hardware clock is kept in UTC time.Waiting for clock tick......got clock tickTime read from Hardware Clock: 2022/02/27 13:14:24Hw clock time : 2022/02/27 13:14:24 = 1645967664 seconds since 1969Time since last adjustment is 1645967664 secondsCalculated Hardware Clock drift is 0.000000 seconds2022-02-27 21:14:23.020178+08:00 对此输出不再作进一步介绍。 设置硬件时间（与系统时间一致）我们一般很少手动设置硬件时间。若要设置，可以使其与系统时间保持一致： 1sudo hwclock --systohc 这会新建或更新 /etc/adjtime 的内容，示例如下： 1234$ cat /etc/adjtime0.000000 1645969156 0.0000001645969156LOCAL 系统时间1sudo timedatectl set-time &quot;yyyy-MM-dd hh:mm:ss&quot; 例如： 1sudo timedatectl set-time &quot;2014-05-26 11:13:54&quot; 时区设置时区前，先需要知道可用的时区： 1timedatectl list-timezones 其中有“Asia/Shanghai”，可将时区设置为此： 1sudo timedatectl set-timezone Asia/Shanghai 同步此处提到的同步指的是系统时间与其他服务器提供的时间同步。以下提供两种方式。 systemd-timesyncd 服务配置首先启用该服务，执行 systemctl start systemd-timesyncd。可以选择加入自启动项。 打开 /etc/systemd/timesyncd.conf 文件，其中的内容可能如下： 1234567[Time]#NTP=#FallbackNTP=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.org#RootDistanceMaxSec=5#PollIntervalMinSec=32#PollIntervalMaxSec=2048#SaveIntervalSec=60 删去前两行的注释记号，并作如下修改： 12NTP=0.cn.pool.ntp.org 1.cn.pool.ntp.org 2.cn.pool.ntp.org 3.cn.pool.ntp.orgFallbackNTP=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.org 若要验证配置，执行 timedatectl show-timesync --all。一般输出类似于： 1234567891011LinkNTPServers=SystemNTPServers=FallbackNTPServers=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.orgServerName=0.arch.pool.ntp.orgServerAddress=103.47.76.177RootDistanceMaxUSec=5sPollIntervalMinUSec=32sPollIntervalMaxUSec=34min 8sPollIntervalUSec=1min 4sNTPMessage={ Leap=0, Version=4, Mode=4, Stratum=2, Precision=-21, RootDelay=177.398ms, RootDispersion=142.196ms, Reference=C342F10A, OriginateTimestamp=Mon 2018-07-16 13:53:43 +08, ReceiveTimestamp=Mon 2018-07-16 13:53:43 +08, TransmitTimestamp=Mon 2018-07-16 13:53:43 +08, DestinationTimestamp=Mon 2018-07-16 13:53:43 +08, Ignored=no PacketCount=1, Jitter=0 }Frequency=22520548 但若出现类似如下的输出： 12345678910LinkNTPServers=SystemNTPServers=0.cn.pool.ntp.org 1.cn.pool.ntp.org 2.cn.pool.ntp.org 3.cn.pool.ntp.orgFallbackNTPServers=0.pool.ntp.org 1.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.orgServerName=ServerAddress=RootDistanceMaxUSec=5sPollIntervalMinUSec=32sPollIntervalMaxUSec=34min 8sPollIntervalUSec=0Frequency=0 请跳过本小节，跳转至 chrony。 生效若要使配置生效，执行 timedatectl set-ntp true。 同步过程需要持续一段时间。若要检查同步状态，执行 timedatectl status。输出类似于： 1234567 Local time: Thu 2015-07-09 18:21:33 CEST Universal time: Thu 2015-07-09 16:21:33 UTC RTC time: Thu 2015-07-09 16:21:33 Time zone: Europe/Amsterdam (CEST, +0200)System clock synchronized: yes NTP service: active RTC in local TZ: no 若要查看详细信息，执行 timedatectl timesync-status。输出类似于： 12345678910111213 Server: 103.47.76.177 (0.arch.pool.ntp.org)Poll interval: 2min 8s (min: 32s; max 34min 8s) Leap: normal Version: 4 Stratum: 2 Reference: C342F10A Precision: 1us (-21)Root distance: 231.856ms (max: 5s) Offset: -19.428ms Delay: 36.717ms Jitter: 7.343ms Packet count: 2 Frequency: +267.747ppm chronychrony 是一个漫游友好型、且专为非所有时间在线的系统设计的程序，可以用以同步系统时间。 安装大部分软件管理器中均有该软件包。执行： 1sudo pacman -S chrony 这将在 /usr/bin 下放置 chrony 的两个可执行文件 chronyc 和 chronyd，分别作为客户端和服务端（保护进程）。 也可以在官网中查阅其他安装方式。 配置配置文件一般为 /etc/chrony.conf 或 /etc/chrony/chrony.conf。 打开配置文件，做如下更改： 定位到 pool 配置项，修改其后的服务器地址为 0.cn.pool.ntp.org； 定位到 makestep 配置项，根据需求修改； 第一个数字：进行“时间跳跃”的阈值——同步时若系统时间与服务器返回结果相差在阈值内，则程序会逐渐调整当前系统时间；反之则会直接将系统时间设为正确时间（注意：“时间跳跃”可能会对其他程序造成负面影响，不宜将此值调至过小）； 第二个数字：可进行时间调整的范围——设置为 n 表示仅前 n 次时间更新过程可发生这种调整。 定位到 logdir 配置项，删去配置记号； 定位到 rtcsync 配置项，删去注释记号。 生效启用该服务，执行 systemctl start chronyd。可以选择加入自启动项。重启，读取系统时间检查： 1234567 Local time: Sun 2022-02-27 23:16:28 CST Universal time: Sun 2022-02-27 15:16:28 UTC RTC time: n/a Time zone: Asia/Shanghai (CST, +0800)System clock synchronized: yes NTP service: active RTC in local TZ: no 观察到“System clock synchronized”栏的输出是“yes”。 若要立刻更改系统时间，执行 chronyc makestep。 参考 https://wiki.archlinux.org/title/System_time https://wiki.archlinux.org/title/Systemd-timesyncd https://www.tecmint.com/install-chrony-in-centos-ubuntu-linux/","link":"/techdev/linux-time-operations-and-sync/"},{"title":"【实测】Python 和 C++ 下字符串查找的速度对比","text":"最近在备战一场算法竞赛，语言误选了 Python ，无奈只能着手对常见场景进行语言迁移。而字符串查找的场景在算法竞赛中时有出现。本文即对此场景在 Python 和竞赛常用语言 C++ 下的速度进行对比，并提供相关参数和运行结果供他人参考。 背景最近在备战一场算法竞赛，语言误选了 Python ，无奈只能着手对常见场景进行语言迁移。而字符串查找的场景在算法竞赛中时有出现。本文即对此场景在 Python 和竞赛常用语言 C++ 下的速度进行对比，并提供相关参数和运行结果供他人参考。 参数硬件和操作系统12345678910111213141516171819 -` root@&lt;hostname&gt; .o+` ------------ `ooo/ OS: Arch Linux ARM aarch64 `+oooo: Host: Raspberry Pi 4 Model B `+oooooo: Kernel: 5.16.12-1-aarch64-ARCH -+oooooo+: Uptime: 3 hours, 32 mins `/:-:++oooo+: Packages: 378 (pacman) `/++++/+++++++: Shell: zsh 5.8.1 `/++++++++++++++: Terminal: /dev/pts/0 `/+++ooooooooooooo/` CPU: (4) @ 1.500GHz ./ooosssso++osssssso+` Memory: 102MiB / 7797MiB .oossssso-````/ossssss+` -osssssso. :ssssssso. :osssssss/ osssso+++. /ossssssss/ +ssssooo/- `/ossssso+/:- -:/+osssso+- `+sso+:-` `.-/+oso:`++:. `-/+/.` `/ 编译环境和解释环境 Python 解释器：Python 3.10.2 (main, Jan 23 2022, 21:20:14) [GCC 10.2.0] on linux 交互环境：IPython 8.0.1 C++ 编译器：g++ (GCC) 11.2.0 编译命令：g++ test.cpp -Wall -O2 -g -std=c++11 -o test 场景本次实测设置两个场景：场景 1 的源串字符分布使用伪随机数生成器生成，表示字符串查找的平均情况；场景 2 的源串可连续分割成 20,000 个长度为 50 的字符片段，其中第 15,001 个即为模式串，形如“ab…b”（1 个“a”，49 个 “b”），其余的字符片段形如“ab…c”（1 个“a”，48 个“b”，1 个“c”）。 项目 场景 1：平均情况 场景 2：较坏情况 字符集 小写字母 abc 字符分布 random.choice 有较强规律性 源串长度 1,000,000 1,000,000 模式串长度 1,000 50 模式串出现位置 250,000、500,000、750,000 750,000 模式串出现次数 1 1 测试方法本次实测中，Python 语言使用内置类型 str 的 .find() 成员函数，C++ 语言分别使用 string 类的 .find() 成员函数、strstr 标准库函数和用户实现的 KMP 算法。 测试对象 核心代码 Python src.find(pat) C++ - test.cpp src.find(pat) C++ - test_strstr.cpp strstr(src, pat) C++ - test_kmp.cpp KMP(src, pat) 源代码生成源串和模式串123456789101112131415161718192021import random# 场景 1：# 源串s = &quot;&quot;.join(chr(random.choice(range(ord(&quot;a&quot;), ord(&quot;z&quot;) + 1))) for _ in range(1000000))# 模式串列表，三个元素各对应一个模式串p = [s[250000:251000], s[500000:501000], s[750000:751000]]# 场景 2：# 模式串p = 'a' + 'b' * 49# 其他字符片段_s = &quot;a&quot; + &quot;b&quot; * 48 + &quot;c&quot;# 源串s = _s * 15000 + p + _s * 4999# 存储到文件，便于 C++ 程序获取with open('source.in', 'w') as f: f.write(s)with open('pattern.in', 'w') as f: f.write(p[0]) 测试代码Python1In []: %timeit s.find(p[0]) C++ - test.cpp12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#define LOOP_COUNT (1000)using namespace std;using std::chrono::high_resolution_clock;using std::chrono::duration_cast;using std::chrono::duration;using std::chrono::milliseconds;double test(string s, string p, size_t* pos_ptr) { auto t1 = high_resolution_clock::now(); *pos_ptr = s.find(p); auto t2 = high_resolution_clock::now(); duration&lt;double, milli&gt; ms_double = t2 - t1; return ms_double.count();}int main() { string s, p; size_t pos; ifstream srcfile(&quot;source.in&quot;); ifstream patfile(&quot;pattern.in&quot;); srcfile &gt;&gt; s; patfile &gt;&gt; p; double tot_time = 0; for (int i = 0; i &lt; LOOP_COUNT; ++i) { tot_time += test(s, p, &amp;pos); } cout &lt;&lt; &quot;Loop count: &quot; &lt;&lt; LOOP_COUNT &lt;&lt; endl; cout &lt;&lt; &quot;Source string length: &quot; &lt;&lt; s.length() &lt;&lt; endl; cout &lt;&lt; &quot;Pattern string length: &quot; &lt;&lt; p.length() &lt;&lt; endl; cout &lt;&lt; &quot;Search result: &quot; &lt;&lt; pos &lt;&lt; endl; cout &lt;&lt; &quot;Time: &quot; &lt;&lt; tot_time / LOOP_COUNT &lt;&lt; &quot; ms&quot; &lt;&lt; endl; return 0;} C++ - test_strstr.cpp123456789101112131415161718192021222324252627282930313233343536373839#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#define LOOP_COUNT (1000)using namespace std;using std::chrono::high_resolution_clock;using std::chrono::duration_cast;using std::chrono::duration;using std::chrono::milliseconds;char s[1000005], p[1005], *pos=NULL;double test(char* s, char* p, char** pos_ptr) { auto t1 = high_resolution_clock::now(); *pos_ptr = strstr(s, p); auto t2 = high_resolution_clock::now(); duration&lt;double, milli&gt; ms_double = t2 - t1; return ms_double.count();}int main() { ifstream srcfile(&quot;source.in&quot;); ifstream patfile(&quot;pattern.in&quot;); srcfile &gt;&gt; s; patfile &gt;&gt; p; double tot_time = 0; for (int i = 0; i &lt; LOOP_COUNT; ++i) { tot_time += test(s, p, &amp;pos); } cout &lt;&lt; &quot;Loop count: &quot; &lt;&lt; LOOP_COUNT &lt;&lt; endl; cout &lt;&lt; &quot;Source string length: &quot; &lt;&lt; strlen(s) &lt;&lt; endl; cout &lt;&lt; &quot;Pattern string length: &quot; &lt;&lt; strlen(p) &lt;&lt; endl; cout &lt;&lt; &quot;Search result: &quot; &lt;&lt; pos - s &lt;&lt; endl; cout &lt;&lt; &quot;Time: &quot; &lt;&lt; tot_time / LOOP_COUNT &lt;&lt; &quot; ms&quot; &lt;&lt; endl; return 0;} C++ - test_kmp.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#define LOOP_COUNT (1000)using namespace std;using std::chrono::high_resolution_clock;using std::chrono::duration_cast;using std::chrono::duration;using std::chrono::milliseconds;int dp[1005];int KMP(string s, string p) { int m = s.length(), n = p.length(); if (n == 0) return 0; if (m &lt; n) return -1; memset(dp, 0, sizeof(int) * (n+1)); for (int i = 1; i &lt; n; ++i) { int j = dp[i+1]; while (j &gt; 0 &amp;&amp; p[j] != p[i]) j = dp[j]; if (j &gt; 0 || p[j] == p[i]) dp[i+1] = j + 1; } for (int i = 0, j = 0; i &lt; m; ++i) if (s[i] == p[j]) { if (++j == n) return i - j + 1; } else if (j &gt; 0) { j = dp[j]; --i; } return -1;}double test(string s, string p, int* pos_ptr) { auto t1 = high_resolution_clock::now(); *pos_ptr = KMP(s, p); auto t2 = high_resolution_clock::now(); duration&lt;double, milli&gt; ms_double = t2 - t1; return ms_double.count();}int main() { string s, p; int pos; ifstream srcfile(&quot;source.in&quot;); ifstream patfile(&quot;pattern.in&quot;); srcfile &gt;&gt; s; patfile &gt;&gt; p; double tot_time = 0; for (int i = 0; i &lt; LOOP_COUNT; ++i) { tot_time += test(s, p, &amp;pos); } cout &lt;&lt; &quot;Loop count: &quot; &lt;&lt; LOOP_COUNT &lt;&lt; endl; cout &lt;&lt; &quot;Source string length: &quot; &lt;&lt; s.length() &lt;&lt; endl; cout &lt;&lt; &quot;Pattern string length: &quot; &lt;&lt; p.length() &lt;&lt; endl; cout &lt;&lt; &quot;Search result: &quot; &lt;&lt; pos &lt;&lt; endl; cout &lt;&lt; &quot;Time: &quot; &lt;&lt; tot_time / LOOP_COUNT &lt;&lt; &quot; ms&quot; &lt;&lt; endl; return 0;} 结果IPython 的 %timeit 魔法命令可以输出代码多次执行的平均时间和标准差，在此取平均时间。C++ 的代码对每个模式串固定运行 1,000 次后取平均时间。 以下时间若无特别说明，均以微秒为单位，保留到整数位。 场景 模式串出现位置 Python C++ - test.cpp C++ - test_strstr.cpp C++ - test_kmp.cpp 场景 1 250,000 105 523 155 2564 场景 1 500,000 183 1053 274 3711 场景 1 750,000 291 1589 447 4900 场景 2 750,000 2630* 618 353 3565 * 原输出为“2.63 ms”。IPython 的 %timeit 输出的均值保留 3 位有效数字，由于此时间已超过 1 毫秒，微秒位被舍弃。此处仍以微秒作单位，数值记为“2630”。 局限性本次实测时使用的设备硬件上劣于算法竞赛中的标准配置机器，实测结果中的“绝对数值”参考性较低。 总结根据上表中的结果，在给定环境和相关参数条件下，场景 1 中 Python 的运行时间大约为 C++ 中 string::find 的五分之一，与 std:strstr 接近；而在场景 2 中 Python 的运行时间明显增长，但 C++ 的前两种测试方法的运行时间与先前接近甚至更短。四次测试中，C++ 的用户实现的 KMP 算法运行时间均较长，长于同条件下 Python 的情况。 Python 中的内置类型 str 的快速查找（.find()）和计数（.count()）算法基于 Boyer-Moore 算法和 Horspool 算法的混合，其中后者是前者的简化，而前者与 Knuth-Morris-Pratt 算法有关。 有关 C++ 的 string::find 比 std::strstr 运行时间长的相关情况，参见 Bug 66414 - string::find ten times slower than strstr。 值得关注的是：C++ 中自行实现的 KMP 算法的运行时间竟然远长于 C++ 标准库甚至 Python 中的算法。这也类似于常说的“自己设计汇编代码运行效率低于编译器”的情况。Stack Overflow 的一个问题 strstr faster than algorithms? 下有人回答如下： Why do you think strstr should be slower than all the others? Do you know what algorithm strstr uses? I think it’s quite likely that strstr uses a fine-tuned, processor-specific, assembly-coded algorithm of the KMP type or better. In which case you don’t stand a chance of out-performing it in C for such small benchmarks. KMP 算法并非是所有线性复杂度算法中最快的。在不同的环境（软硬件、测试数据等）下，KMP 与其变种乃至其他线性复杂度算法，孰优孰劣都无法判断。编译器在设计时考虑到诸多可能的因素，尽可能使不同环境下都能有相对较优的策略来得到结果。因而，在保证结果正确的情况下，与其根据算法原理自行编写，不如直接使用标准库中提供的函数。 同时本次实测也在运行时间角度再次印证 Python 并不适合在算法竞赛中取得高成绩的说法。 参考 https://stackoverflow.com/questions/22387586/measuring-execution-time-of-a-function-in-c https://www.cplusplus.com/reference/string/string/find/ https://stackoverflow.com/questions/681649/how-is-string-find-implemented-in-cpython https://github.com/python/cpython/blob/main/Objects/stringlib/fastsearch.h#L5 https://stackoverflow.com/questions/8869605/c-stringfind-complexity https://stackoverflow.com/questions/19506571/can-it-be-faster-to-find-the-minimum-periodic-string-inside-another-string-in-te https://gcc.gnu.org/onlinedocs/gcc-9.4.0/libstdc++/api/a17342_source.html https://opensource.apple.com/source/tcl/tcl-10/tcl/compat/strstr.c.auto.html https://gist.github.com/hsinewu/44a1ce38a1baf47893922e3f54807713 https://stackoverflow.com/questions/11799956/performance-comparison-strstr-vs-stdstringfind https://stackoverflow.com/questions/7586990/strstr-faster-than-algorithms https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66414 http://0x80.pl/notesen/2016-10-08-slow-std-string-find.html","link":"/techdev/python-cpp-string-find-perf-test/"},{"title":"Codeforces 1312B: Bogosort","text":"Codeforces 1312B C++ 一解. 分析此题相当于排序数组后使两个有限数列 (一个是数列 ${1,2,\\cdots,n}$, 一个是排序后的数组 $a_\\mathrm{sorted}$) 的差各不相同. 一个很容易想到的构造方法是对一个单调 (不一定严格) 递减数列与严格单调递增数列求差, 这样得到的差数列的各元素一定各不相同 (且是单调递减的). 代码123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int main(){ int t, n, a[100]; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i]; } sort(a, a + n); // 先递增排列 while (n--) { cout &lt;&lt; a[n] &lt;&lt; ' '; // 再倒序输出, 相当于 &quot;构造&quot; 出了递减数列 } cout &lt;&lt; endl; } return 0;}","link":"/acmoi/codeforces/1312b/"},{"title":"Codeforces 1368B: Codeforces Subsequences","text":"Codeforces 1368B C++ 和 Python 一解. 终于看到一道比较有趣的 constructive algorithm 的题目了. 分析本题是 “乘法原理” 的经典应用之一: 每一个内容为 codeforces 子序列都需要在源串中各选择十个字符连续重复的字符串 (指连续的 c, o, d 等十个字符串) 中的一个字符. 若假定源串 $s$ 中 c, o, d 等字符各连续重复 $a_0,a_1,a_2,\\cdots,a_9$ 次, 则最终能生成的 codeforces 子序列共有 $l=a_0a_1a_2\\cdots a_9$ 个. 而为满足题意, 需要选择合适的 $a_0,a_1,a_2,\\cdots,a_9$, 使得 $l\\geq k$ 且 $L=a_0+a_1+a_2+\\cdots+a_9$ 尽可能小. 一种贪心的策略我们知道, 根据均值不等式, 对于长度为 $n$ 的正有限实数列 ${a_i}$, 有 $$\\sqrt[n]{\\prod^{n}{i=1}{a_i}}\\leq\\sum^{n}{i=1}{a_i},$$ 当且仅当 ${a_i}$ 是常数列时取等号. 对于本题, 可以猜想: 当左式恒定, 即 $l$ 恒定时, 若要使右式 (也即 $L$) 尽可能小, 则需要选择相差不大的 $a_i(i=0,1,\\cdots,9)$. 这即是一种贪心策略. 我们希望 $a_i$ 的极差尽可能小, 一种选择方法是令其中一部分 $a_i$ 比另一部分恰好大 $1$ (当然理想情况是这些 $a_i$ 都相等). 不妨假设 $a_0,a_1,\\cdots,a_{m-1}$ ($m=0,1,\\cdots,10$, 当 $m=0$ 时规定 $a_i=a$, 当 $m=10$ 时规定 $a_i=a+1$) 都等于 $a+1(a\\in\\mathbb{N}^{*})$, $a_m,a_{m+1},\\cdots,a_9$ 都等于 $a$. 那么 $$l=(a+1)^{10-m}a^m,\\L=(10-m)(a+1)+ma=10a-m+10.$$ $a$ 和 $m$ 的确定首先我们关注 $m=10$ 即 $l=a^{10}$ 的情况. 注意到此时若要使 $l\\geq k$, 则 $a\\geq\\sqrt[10]{k}$. 而当 $a$ 固定时, 对于不同的 $m$, 有 $\\sup l=(a+1)^{10}$, $\\inf l=a^{10}$, 且考虑到当 $a_p&gt;a_q$ 时恒有 $\\left.L\\right|{a=a_p}\\geq\\left.L\\right|{a=a_q}$, 则 $a$ 可以选取 $\\lfloor\\sqrt[10]{k}\\rfloor$. 对于 $m$, 理论上根据 $l\\geq k$ 可以推导得到 $m\\leq\\dfrac{10\\ln(a+1)-\\ln k}{\\ln(a+1)-\\ln a}$, 但在实际编程中考虑到浮点数存在的误差 (直接用此式计算无法通过 Codeforces 测试集), 我们需要利用大整数 (long long unsigned 足够) 从 $m=0$ 或 $m=10$ 开始逐个测试 (理论上也可以使用二分查找, 但本题的数据规模下不必要), 直到找到符合要求的 $m$. 为方便起见, 确定 $a$ 的过程依然使用了对数法, 同时为尽可能保证计算准确, 代码中使用了自定义的下取整函数 better_floor(). 在 Python 中, 考虑到其原生支持处理超长整数, 对上述推导公式修改为 $k(a+1)^m\\leq a^m(a+1)^{10}$, 同样可以达到题意所需要求, 而这式两边即对应下述代码中的 left 和 right. 代码C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define EPS (1e-14)using namespace std;const string base(&quot;codeforces&quot;);double better_floor(double x){ double y = ceil(x); return (y - x &lt; EPS ? y : floor(x));}int calc_m(long long unsigned k, int a){ long long unsigned l = 1; int m = 10; for (int i = 0; i &lt; m; ++i) { l *= a; } while (l &lt; k &amp;&amp; m-- &gt;= 0) { l = l * (a + 1) / a; } return m;}int main(){ long long unsigned k; int a, m; cin &gt;&gt; k; a = int(better_floor(pow(k, 0.1))); m = calc_m(k, a); for (int i = 0; i &lt; 10 - m; ++i) { cout &lt;&lt; string(a + 1, base[i]); } for (int i = 10 - m; i &lt; 10; ++i) { cout &lt;&lt; string(a, base[i]); } return 0;} Python123456789101112131415161718def calc_m3(k, a): left, right = k, (a + 1) ** 10 for i in range(1, 12): left *= a + 1 right *= a if left &gt; right: return i - 1 return -1k = int(input())base = 'codeforces'a = int(k ** 0.1)m = calc_m3(k, a)for i in range(10 - m): print(base[i] * (a + 1), end='')for i in range(10 - m, 10): print(base[i] * a, end='')","link":"/acmoi/codeforces/1368b/"},{"title":"Codeforces 1419D1: Sage&#39;s Birthday (easy version)","text":"Codeforces 1419D1 C++ 一解. 分析本题是简单版本, 各个冰淇淋球的价格都不相同. 我们只需要构造出数量最多的 “谷” 即可. 与上篇 Codeforces 1312B: Bogosort 类似, 这次相当于对一个排序后的数组同时从两边取数输出, 例如对输入数据 $[7,6,5,4,3,2,1]$, 两边取数得到 $[7,1,6,2,5,3,4]$, 这样得到的新数列的 “谷” 数量最多, 且为 $\\left[\\dfrac{n-1}{2}\\right]$. 代码12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int a[100000];int main(){ int n, p = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i]; } cout &lt;&lt; (n - 1) / 2 &lt;&lt; endl; sort(a, a + n); while (p++ &lt; n / 2) { cout &lt;&lt; a[n - p] &lt;&lt; ' ' &lt;&lt; a[p - 1] &lt;&lt; ' '; } if (n % 2) { cout &lt;&lt; a[p - 1]; } cout &lt;&lt; endl; return 0;}","link":"/acmoi/codeforces/1419d1/"},{"title":"Codeforces 1399D: Binary String to Subsequences","text":"Codeforces 1399D C++ 一解. 分析本题本身的思路是很清晰的, 但考虑到一些极端数据, 需要额外添加一些数据结构. 可以确定的是, 给定的字符串的每个字符都要纳入某一个子序列中. 同时可以注意到, 如果已经存在一些子序列, 对于源串的某个字符, 只要其能接在某个子序列之后, 就不会增加现有子序列的数量; 若这个字符无法接在任何现有子序列之后, 拆开其中一部分子序列使其能够纳入也不会使子序列数量减少. 因此这种策略是最优的. 本题给定的数据规模 $\\sum n\\leq2\\times10^5$. 若每次尝试添加字符到子序列时都顺序搜索现有子序列, 部分测试点无法通过 (例如: 1231200000111111111111... (200000 个 1) ). 因此可以设置两个栈结构用于存储现有的 “尾数” 为 0 和 1 的子序列的序号. 因为只需要构造出一种可行的组合子序列的方案即可, 只需要对栈作入栈, 出栈操作, 其时间开销可以接受. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;char change_bit(char x){ return x == '1' ? '0' : '1';}int change_bit(int x){ return x ? 0 : 1;}int get_bit(char x){ return x - '0';}void solve_and_print(string s){ int n = s.length(), total = 0; vector&lt;int&gt; ans(n, 0), stack[2]; for (int i = 0; i &lt; n; ++i) { char c = change_bit(s[i]); int x = get_bit(c), y = get_bit(s[i]); if (stack[x].empty()) { ++total; ans[i] = total; stack[y].push_back(total - 1); } else { int j = stack[x].back(); stack[x].pop_back(); stack[y].push_back(j); ans[i] = j + 1; } } cout &lt;&lt; total &lt;&lt; endl; for (int i = 0; i &lt; n; ++i) { cout &lt;&lt; ans[i] &lt;&lt; ' '; } cout &lt;&lt; endl;}int main(){ ios_base::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t, n; string s; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; s; solve_and_print(s); } return 0;}","link":"/acmoi/codeforces/1399d/"},{"title":"Codeforces 1430C: Numbers on Whiteboard","text":"Codeforces 1430C C++ 一解. 分析白板上的数字初始状态是固定的 $1,2,\\cdots,n$. 每次操作都会 “折损” 当下所有数字之和, 而 “折损” 的量即为选定的两个数之和的一半. 因此为使最后得到的数字最小, 一种贪心的方法是每次选择最大的两个数字做操作. 操作时对于两数之和为奇数的, 得到的新数字需要向上取整. 虽然有 “凭空” 增大数字总和的可能性, 但经过数学归纳即可得知最后一次操作选定的数字一定是 $1$ 和 $3$ $(n&gt;2)$ 或 $1$ 和 $2$ $(n=2)$, 也即最后得到的数字为 $2$. 显然若要得到小于 $2$ 的数字, 需要在倒数第二次操作时白板上只剩下两个 $1$, 而这在向上取整的规则下是做不到的. 因此这种贪心方法即为最优解. 空间和时间优化因为白板数字的初始状态是规律性的连续自然数列, 选定数字的过程也极为规律, 无需要实际使用栈等数据结构模拟. 官方题解则提供了使用实际数据结构 vector&lt;int&gt; 的方法. 代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;void solveAndPrint(int n){ cout &lt;&lt; 2 &lt;&lt; endl; cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; endl; for (int i = 2; i &lt; n; ++i) { cout &lt;&lt; n - i &lt;&lt; ' ' &lt;&lt; n - i + 2 &lt;&lt; endl; }}int main(){ int t, n; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; solveAndPrint(n); } return 0;}","link":"/acmoi/codeforces/1430c/"},{"title":"Codeforces 1474B: Different Divisors","text":"Codeforces 1474B C++ 一解. 分析$a$ 至少要有 $4$ 个因子 (自然包括 $1$ 和 $a$ 本身), 且任意两因子的差不小于 $d$. 为使 $a$ 尽可能小, 我们只希望 $a$ 有且仅有 $4$ 个因子, 也就是再确定两个不同的质因子 $p,q$ ($a=pq$, 且不妨设 $p&lt;q$). 一个很显然的事实是: 对于充分大的 $d$, 我们越能保证 $a-q\\geq d$ (不会证明故从略), 因此我们只需要在质数表中找到不小于 $1+d$ ($1$ 即是因子升序排列的第一个因子) 的 $p$ (第二个因子) 和不小于 $p+d$ 的 $q$ (第三个因子), 再确保 $a$ (第四个因子) 与 $q$ 的差不小于 $d$ 即可. 经过验证, 对于 $d=1$ 依然有 $a-q\\geq d$. 生成质数表生成质数表的方式有很多. 以下代码中尝试利用 STL 的 vector&lt;int&gt; 动态生成/更新指定范围内的质数表. 当然考虑到 $d\\leq 10,000$, 可以直接生成完整长度 (所需的最大质数为 $20,011$, 根据质数定理估计质数表长度为 $2020$) 的质数表. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define MAX_PRIME (20011) // 10007 and 20011 are primes.using namespace std;bool isPrime(int x){ if (x == 1) { return false; } if (x == 2) { return true; } if (x % 2 == 0) { return false; } for (int i = 3; i &lt;= int(floor(sqrt(x))); i += 2) { if (x % i == 0) { return false; } } return true;}vector&lt;int&gt; updatePrimes(int maxn, vector&lt;int&gt; primes){ int lastPrime = 2; if (primes.size()) { lastPrime = primes.back(); } else { primes.push_back(2); } for (int i = lastPrime + (lastPrime == 2 ? 1 : 2); i &lt;= maxn; i += 2) { if (isPrime(i)) { primes.push_back(i); } } return primes;}vector&lt;int&gt; updatePrimes(int maxn){ return updatePrimes(maxn, vector&lt;int&gt;());}int solve(int d, vector&lt;int&gt; primes){ vector&lt;int&gt;::iterator index1 = lower_bound(primes.begin(), primes.end(), 1 + d); vector&lt;int&gt;::iterator index2 = lower_bound(primes.begin(), primes.end(), *index1 + d); return *index1 * *index2;}int main(){ int t, d; vector&lt;int&gt; primes = updatePrimes(MAX_PRIME); cin &gt;&gt; t; while (t--) { cin &gt;&gt; d; cout &lt;&lt; solve(d, primes) &lt;&lt; endl; } return 0;}","link":"/acmoi/codeforces/1474b/"},{"title":"Codeforces 1520C: Not Adjacent Matrix","text":"Codeforces 1520C C++ 一解. 分析只要求对 $n$ 阶方阵依次填充 $1,2,\\cdots,n^2$, 一种常见的思考模式是依次将这个自然数序列填充到正确的位置. 显然对于本题一个较好的方案是间隔填充: 先从元素 $(0,0)$ (假定方阵左上角元素坐标为此, 其他类推) 开始每次间隔一格填充直至一行填充完毕, 再跳转到下一行间隔填充直至右下角元素 $(n-1,n-1)$, 接着顺序填充剩下的元素. 这样就能满足题意. Codeforces 上编辑者博客中, MikeMirzayazov 用黑白棋盘举例, 先填充白格再填充黑格, 判定颜色依据为横纵坐标之和的奇偶性. 而以下的代码则直接将方阵拉长为长度为 $n$ 的一维数组, 直接根据下标的奇偶性填充数字, 效果类似. 当然以下的代码推出了每个坐标对应的数值的解析式, 并未利用到数组空间. 同时, 利用这样的填充方案, 显然可以得知当且仅当 $n=2$ 时找不到满足题意的方阵; 为方便编程, 这里将 $n=1$ 也做了特殊处理. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;void solveAndPrint(int n){ const int nn = n * n; if (n == 1) { cout &lt;&lt; 1 &lt;&lt; endl; return; } if (n == 2) { cout &lt;&lt; -1 &lt;&lt; endl; return; } if (n % 2) { for (int i = 0; i &lt; nn; ++i) { if (i % 2) { cout &lt;&lt; (nn + i) / 2 + 1 &lt;&lt; ' '; } else { cout &lt;&lt; i / 2 + 1 &lt;&lt; ' '; } if ((i + 1) % n == 0) { cout &lt;&lt; endl; } } } else { for (int i = 0; i &lt; nn; ++i) { if (i % 2) { cout &lt;&lt; (nn + i + 1) / 2 &lt;&lt; ' '; } else { cout &lt;&lt; i / 2 + 1 &lt;&lt; ' '; } if ((i + 1) % n == 0) { cout &lt;&lt; endl; } } }}int main(){ int t, n; cin &gt;&gt; t; for (int i = 0; i &lt; t; ++i) { cin &gt;&gt; n; solveAndPrint(n); } return 0;}","link":"/acmoi/codeforces/1520c/"},{"title":"Codeforces 266B: Queue at the School","text":"Codeforces 266B C++ 一解。 分析简单的模拟。把 B 想象成箱子，要不断往右侧推。 需要注意的是，没有正确理解题意的话容易理解成每次让箱子统一右移一格。但实际上，遇到 BBG 的情况，下一秒应该是 BGB 而不是 GBB，因为某一时刻某两个相邻位置的 B 和 G 互换后，就只能考虑其后的位置了。再拿箱子举例，应该想象成连续的箱子无法推动，只能推动箱子“队列”的最末一个。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;// brute forcestring solve(int n, int t, string s){ int l = s.length(); for (int i = 0; i &lt; t; ++i) { int j = 0; while (j &lt; l - 1) { if (s[j] == 'B' &amp;&amp; s[j + 1] == 'G') { s[j] = 'G'; s[j + 1] = 'B'; j += 2; } else { ++j; } } } return s;}int main(){ int n, t; string s, a; cin &gt;&gt; n &gt;&gt; t; cin &gt;&gt; s; a = solve(n, t, s); cout &lt;&lt; a &lt;&lt; endl; return 0;}","link":"/acmoi/codeforces/266b/"},{"title":"Codeforces 766A: Mahmoud and Longest Uncommon Subsequence","text":"Codeforces 766A C++ 一解. 分析两个字符串的最长不公共子序列被定义为最长的仅为其中一个字符串的子序列的字符串. 对于两个长度不相同的字符串 (不妨设 $a,b$ 且 $a$ 的长度较长), 一个非常直观的想法是: 因为一个字符串的子序列的长度必须不大于该串的长度, 只要选取 $a$ 本身作为所求的子序列, 其肯定是 $a$ 的子序列, 而不是 $b$ 的子序列. 而对于长度相同的情况, 我们同样可以使用类似的思路: 若两个串不相同, 我们总能选择其中一个串本身作为所求的子序列, 这样其一定不会是另一个串的子序列; 若两个串完全相同, 此时我们就无法找到一个串 (根据题意, 包括空串) 作为所求的子序列, 只能输出 $-1$. 代码12345678910111213141516171819202122#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int main(){ string a, b; cin &gt;&gt; a &gt;&gt; b; if (a == b) { cout &lt;&lt; -1 &lt;&lt; endl; } else { cout &lt;&lt; max(a.length(), b.length()) &lt;&lt; endl; } return 0;}","link":"/acmoi/codeforces/766a/"},{"title":"蓝桥杯真题：纯质数","text":"蓝桥杯 2021 年国赛真题《纯质数》的 Python 解法。 蓝桥杯 2021 年国赛真题：纯质数。 题目链接：https://www.lanqiao.cn/problems/1561/learning/（需要登录）。 题目大意输出 1 到 20210605 之间（包括两端）的“纯质数”（指十进制各数位皆为质数的质数，1 不视作质数）。 分析Python本题是填空题，原则上无需时间复杂度较低的程序也可被接受。当然，这里将给出非填空题的解法。 Python 在大数据规模的循环上耗时较大，而本题显然绕不开判断质数这一话题——乍看本题给出的数据规模达到了千万级，判断其是否为质数最坏情况下需要千级别的循环，而我们要判断 20210605 个数字是否为质数，这个耗时显然是不可接受的（预测在 C/C++ 下也难以接受）。 因此我们可以考虑能否降低需要判断是否为质数的数字的数量。注意到本题中所提到的“纯质数”不仅要求其本身是质数，还要求十进制各数位也为质数——这下我们可以先借此排除掉一定不是纯质数的数字，继而大大简化运算量。 经过分析，我们得知如果一个数要满足“十进制各数位为质数”这一条件，必须满足各个数位只可取 2、3、5、7 中的一个。粗略来看，我们省下了约五分之三的运算量。而更进一步，对于不小于 10 的数字，个位数若为 2 或 5，则一定是合数，故也可提前去除。 为了更好地实现上面的需求，我们最好是自行生成纯质数的“候选”，而不是生成一个长度为 20210605 的列表再删除不符合条件的。每一个数位有可以选择的数字，而这些选择都是互不干扰的，因此我们可以利用标准库 itertools 里的 product() 生成器生成笛卡尔积，以便于快速生成符合条件的数字。实现这一需求的主要代码如下： 1234567891011121314151617181920from itertools import product# （不小于 10 的数字）非个位可取的数字集合、个位可取的数字集合_a, _b = (2, 3, 5, 7), (3, 7)# 生成“候选”数字的生成器def candidate_gen(): # 1 位数 for i in _a: yield i # 2~8 位数 for i in range(2, 9): # star expression，表示生成 (i-1) 个 `_a`，一个 `_b` for j in product(*([_a] * (i-1)), _b): # `j` 是一个由各个数位组成的元组，需要先将其拼成一个整数 x = packtup(j) # 超出范围，终止生成 if x &gt; 20210605: return yield x 判断质数的代码较为简单，在此不作详述，注意设置循环时除数的上限略高于目标数字的算术平方根即可。 完整代码Python123456789101112131415161718192021222324252627282930from itertools import product_a, _b = (2, 3, 5, 7), (3, 7)def packtup(t): return sum(map(lambda i: t[::-1][i] * 10 ** i, range(len(t))))def candidate_gen(): for i in _a: yield i for i in range(2, 9): for j in product(*([_a] * (i-1)), _b): x = packtup(j) if x &gt; 20210605: return yield xdef isprime(x): if x == 1: return False if x == 2: return True if x % 2 == 0: return False for i in range(3, int(x ** 0.5) + 1): if x % i == 0: return False return Trueprint(len(list(filter(isprime, candidate_gen()))))","link":"/acmoi/lanqiao/chun-zhi-shu/"},{"title":"蓝桥杯真题：分巧克力","text":"蓝桥杯 2017 年省赛真题《分巧克力》的 Python 解法。 蓝桥杯 2017 年省赛真题：分巧克力。 题目链接：https://www.lanqiao.cn/problems/99/learning/（需要登录）。 题目大意将 $N$ 块大小为 $H_i\\times W_i$ 的巧克力切出部分分给 $K$ 人，要求分给 $K$ 人的巧克力大小相等且都为边长是整数的正方形。求可能分法中每人巧克力的边长最大值（测试点保证答案不小于 $1$）。 数据范围$1\\leq N,K,H_i,W_i\\leq10^5$。 运行限制 时间限制：2s。 分析Python注意到数据范围上限都是 $10^5$，可以猜测本题一解的时间复杂度为 $O(N\\log N)$，继而联想到二分法。 那本题如何绕到二分上呢？先看选定不同的边长对分巧克力过程的影响。从题目中可知若记切出的巧克力的边长为 $a$，能切出 $b$ 块满足题设条件的巧克力，那么所有边长小于 $a$ 的切法均能切出不少于 $b$ 块巧克力。换言之，若将考察范围内的边长排成一个序列，一定存在某个元素 $a_\\mathrm{ans}$，使得在它之前的边长以及它本身都是满足题设条件的分法，而在它之后的边长都不满足——这就说明这个序列可以视作有序的，其元素值仅能被划分到“满足条件的”和“不满足条件的”两类中，而我们则需要找到这两类元素的“分界线”——这正是二分法的一种典型应用。 此外，我们发现，对于给定的边长 $a$ 和大小为 $H_i\\times W_i$ 的巧克力，如果尽可能一块紧挨着一块切分，可以达到最大份数，具体数值为 $\\left\\lfloor\\dfrac{H_i}{a}\\right\\rfloor\\left\\lfloor\\dfrac{W_i}{a}\\right\\rfloor$。这也说明判断某个边长是否满足题设条件的时间复杂度为 $O(N)$。结合上述二分的描述过程，此解法的时间复杂度恰好为 $O(N\\log N)$。 完整代码Python123456789101112131415161718192021222324252627282930313233343536import sysn, k = map(int, sys.stdin.readline().rstrip().split())h, w = [None] * n, [None] * nfor i in range(n): h[i], w[i] = map(int, sys.stdin.readline().rstrip().split())# 考察范围的上限为所有巧克力中长和宽的最大值maxh, maxw = max(h), max(w)maxhw = max(maxh, maxw)# f[i] 为某个边长 i 是否满足题设条件f = [None] * (maxhw + 1)# 参考：Python 安装目录下 Lib/bisect.py# 注意：在更高 Python 版本中，内置模块 bisect 支持在二分查找和排序中加入 `key` 参数，若将判断边长是否符合条件的过程写成函数，则可以# 直接代入 `bisect.bisect_left()`，且该内置函数经过 C 语言优化，运行速度更快。lo, hi = 1, maxhw + 1while lo &lt; hi: mid = (lo + hi) // 2 # 若 `f[mid]` 未被计算出，则开始计算 if f[mid] is None: s = 0 # 可分出的巧克力块数 f[mid] = False for i in range(n): s += (h[i] // mid) * (w[i] // mid) # 本题无需计算出分出巧克力的具体块数，则在判断出其已经超过 `k` 时直接跳出 if s &gt;= k: f[mid] = True break if f[mid] == True: lo = mid + 1 else: hi = mid# `lo` 即为 `bisect.bisect_left()` 的返回值，其为不符合题设条件的边长最小值print(lo - 1)","link":"/acmoi/lanqiao/fen-qiao-ke-li/"},{"title":"Android 使用 Gradle 命令行签名 APK","text":"本文主要探讨如何使用 Android 项目包含的 gradlew 命令行程序签名 APK 文件. 这同时适用于 Debug 和 Release 等多个 variants. 以下以 Linux/OS X 环境为例. 笔者编译环境为 Gradle 8.0+ 和 Kotlin Gradle Settings, 对于 Groovy Gradle Settings 可能无等效方案. 原理与主要思路在 Android 项目根目录下执行如下命令行 1./gradlew assemble 即可以生成所有 variants 对应的 APK 文件, 并根据 variant 名称分别存放于 app/build/outputs/apk/&lt;variant&gt; 中. 一般默认生成的 Android 项目包含 Debug 和 Release 两个 variants, 也可以分别使用 1./gradlew assembleDebug 或 1./gradlew assembleRelease 生成对应 variant 的 APK. 但是在默认的 Gradle 配置中, 如此生成的 APK 文件是未签名的. 例如 Release variant 生成的 APK 文件默认会包含后缀名 “unsigned”. 若需要对其签名, 则需要传入对应的选项 (option) 实现. 本文选择在应用的 build.gradle.kts 中添加签名所需的选项, 并利用 Kotlin 语言 (相较于 Groovy) 的优势分离出敏感信息. 这样无需修改命令行指令即可编译出签名文件, 同时在不包含签名密钥的情况下也可以编译出未签名文件, 不影响编译命令原本的输出结果. build.gradle.kts 中控制签名的选项主要是 android.signingConfigs 和 android.buildTypes.&lt;variant&gt;.signingConfig. 前者用于指定密钥数据库位置, 密码等敏感信息作为一个 signing config, 后者用于指定该 variant 使用何种 signing config. 实现设置密钥信息假定存储敏感信息的文件名为 credentials.properties. 我们选择利用 java.util.Properties 读取该文件. 在该文件中写入类似如下的内容: 1234STORE_FILE=/path/to/keystore.jks # Key store 路径STORE_PASSWORD=password # Key store 密码KEY_ALIAS=MyApp # Key 别名 (alias)KEY_PASSWORD=password # Key 密码 以上内容需要符合 Java Properties 的语法规则, 特别注意等号 (=) 等只要出现在键名之后则不需要特别转义, 但是反斜杠 (\\) 需要特别转义为 \\\\. 在 build.gradle.kts 中指定密钥打开应用的 build.gradle.kts, 在开头添加[^1] 123456789import java.util.Propertiesval f = rootProject.file(&quot;credentials.properties&quot;)var credentials: Properties? = nullif (f.exists() &amp;&amp; f.isFile) { credentials = Properties().apply { load(f.reader()) }} 这段代码表示仅在 credentials.properties 文件存在时才读取并将其存入 credentials 变量中. 其他类似的写法皆可. 再在 android {} 语句块中添加如下内容[^2]: 123456789101112131415161718192021222324252627282930android { // ... if (credentials != null) { signingConfigs { create(&quot;release&quot;) { storeFile = credentials!![&quot;STORE_FILE&quot;]?.let { file(it) } storePassword = credentials!![&quot;STORE_PASSWORD&quot;].toString() keyAlias = credentials!![&quot;KEY_ALIAS&quot;].toString() keyPassword = credentials!![&quot;KEY_PASSWORD&quot;].toString() enableV1Signing = true enableV2Signing = true enableV3Signing = true enableV4Signing = true } } } buildTypes { release { // ... if (credentials != null) { signingConfig = signingConfigs.getByName(&quot;release&quot;) } } } // ...} 这段代码在 credentials 正确读入密钥信息后设置相应的 signing config, 并开启 v1 至 v4 的应用签名方案, 随后设置仅对 Release 的 variant 签名. 如此, 使用 ./gradlew assembleRelease 命令即可生成签名后的 APK 了. 验证 APK 签名使用 jarsigner 程序即可检查签名的有效性[^3]: 1jarsigner -verify -verbose -certs /path/to/my/signed/apk.apk 如果输出中 CN= 后为自己的密钥的签发者, 则说明 APK 签名成功. 特别提醒若使用 Git 等版本控制工具, 请务必将 credentials.properties 忽略掉! 参考[^1]: https://stackoverflow.com/a/71934561/12002560.[^2]: https://gist.github.com/mileskrell/7074c10cb3298a2c9d75e733be7061c2.[^3]: https://stackoverflow.com/a/7104680/12002560.","link":"/techdev/android/sign-apk-gradlew/"},{"title":"Arch Linux 物理机安装大体思路和部分实现细节（MBR &amp; GPT）","text":"背景作为官方文档的补充，大致提供一些安装 Arch Linux 到物理机上并安装桌面环境的思路和文档中未提及的细节。 设备本文的主要篇幅将建立在如下几个设备之上： 主力机 操作系统：Manjaro x86_64 用途：下载并烧录镜像、为目标机器提供网络服务、远程操作、应急使用等 目标机器 操作系统：Windows 7 Utimate x86_64 磁盘数量：1 磁盘记录类型：MBR 启动类型：BIOS 目标：与 Windows 并存安装 Arch Linux U 盘 总容量：8 GB 用途：烧录 Arch Linux 镜像 在文末，会对磁盘记录类型为 GPT、启动类型为 UEFI 的设备的安装过程，及图形界面其他的安装方案作一些说明。 注意：强烈建议为主力机增添显示器、键盘等外设（对笔记本电脑等已有的除外），并在完全配置好网络环境前使用有线网络，防止因安装过程出现问题导致无法联网时难以检修。 安装分区建议在安装 Arch Linux 前分区，或是分出空闲空间，避免因不熟悉命令行环境或参数不直观导致数据丢失。笔者选择后者。 对于主力机是 Linux 的读者，可以使用 gparted 工具进行分区；对于 Windows 读者，可以使用 Disk Genius 工具进行分区。需要注意的是，gparted 底层使用 parted 命令行工具，而该工具在调整分区时无法调整分区头部位置。因此，对于有多启动需求的读者，建议在 Windows 下使用 Disk Genius 工具分区。若主力机上无 Windows 分区，可以在其他可移动介质中安装用于维护的 Windows PE 系统。 笔者的设备已有 BIOS/MBR 类型的 Windows 存在，安装时更加方便。对于大部分使用 UEFI/GPT 类型的读者，请参照官方文档。两种类型的设备的安装过程没有太大差异，且互联网上已有诸多相关的资料供读者参考。但若在安装后出现无法加载 Linux 或其它系统的情况（尤其是 UEFI/GPT 类型），排除软件原因后，考虑升级主板或更换相关硬件。 笔者的分区方案是： 分区 文件类型 大小 格式化 启动项 挂载点 安装镜像环境中的挂载点 /dev/sda1 HPFS/NTFS/exFAT 65GB 否 是 /dev/sda2 HPFS/NTFS/exFAT 312.8GB 否 否 /dev/sda3 Linux swap / Solaris 8GB 是 否 [SWAP] /dev/sda4 Linux 80GB 是 否 / /mnt 其中，“挂载点”表示该分区在安装后操作系统中的路径，“安装镜像环境中的挂载点”表示该分区在当前环境（安装镜像环境）中的路径。 烧录镜像终端执行 sudo fdisk -l 记录需要写入镜像的 U 盘的设备路径。根据官方文档： 1sudo dd bs=4M if=/path/to/archlinux-version-x86_64.iso of=/dev/sdx conv=fsync oflag=direct status=progress 注意写入后 U 盘的卷标应形如 ARCH_YYYYDD，其中 YYYY 和 DD 表示镜像版本号中的年份和月份。若不是，建议手动更改。 U 盘启动U 盘启动成功后进入镜像内置的简易操作系统。与其他发行版镜像稍有不同的是，Arch Linux 镜像默认终端为 zsh，且相比于用户实装的 Arch Linux 内置有更多有利于系统安装和调试的工具。 正常启动后，屏幕显示的应该类似于： 12345678910111213To install Arch Linux follow the installation guide:https://wiki.archlinux.org/title/Installation_guideFor Wi-Fi, authenticate to the wireless network using the iwctl utility.For mobile broadband (WWAN) modems, connect with the mmcli utility.Ethernet, WLAN and WWAN interfaces using DHCP should work automatically.After connecting to the internet, the installation guide can be accessedvia the convenience script Installation_guide.Last login: Mon Apr 25 18:11:37 2022 from 10.42.0.1root@archiso ~ # 并且文字有多种颜色（上方有一行全是空格，在屏幕上实则是不同颜色的色块（经常用于做终端颜色测试））。 而读者若发现屏幕上显示的类似于： 1234567:: Mounting '/dev/disk/by-label/ARCH_202204' to '/run/archiso/bootmnt'Waiting 30 seconds for device /dev/disk/by-label/ARCH_202204 ...ERROR: '/dev/disk/by-label/ARCH_202204' device did not show up after 30 seconds... Falling back to interactive prompt You can try to fix the problem manually, log out when you are finishedsh: can't access tty: job control turned off[rootfs ]# 说明 Arch Linux 安装镜像未找到设备（也就是 U 盘）。出现这种情况，一种原因是如上所述的未修改 U 盘的卷标。而另一种可能的原因则出在硬件上。先在终端上执行： 1ls /dev/disk/by-label 出现的条目中，若有类似 U 盘卷标的，尝试挂载： 12mkdir /mntmount /dev/disk/by-label/&lt;卷标&gt; /mnt 若发现无法挂载，或挂载成功后发现其并非 U 盘的，则说明可能出现了上述硬件问题。此时尝试重新插拔 U 盘，再执行 ls /dev/disk/by-label。若发现形如“ARCH_YYYYDD”的条目出现，则执行 exit 开始安装系统。 另外，有必要检测 U 盘启动时的“启动模式”。执行： 1ls /sys/firmware/efi/efivars 若没有输出，则表示 U 盘在 BIOS 模式启动；反之，则为 UEFI 模式。若启动模式与预计不符，请考虑修改 BIOS 相关的设置。 远程登入上文中笔者提到了“远程操作”。Arch Linux 安装镜像中内置 ssh，可以使用 ssh 远程登入进行安装。需要注意的是，笔者远程登入目标机器是为了方便截取终端上的文字，而考虑到 ssh 连接中断可能导致中断安装进程，不建议这么做。若确实需要，在终端中执行： 1nano /etc/ssh/sshd_config 在文本编辑器中找到： 123# To disable tunneled clear text passwords, change to no here!#PasswordAuthentication yes#PermitEmptyPasswords no 将其修改为： 123# To disable tunneled clear text passwords, change to no here!PasswordAuthentication yesPermitEmptyPasswords yes 按 Ctrl+X，再按 y 保存文件，执行： 1systemctl restart sshd 重启 ssh 服务后，尝试登入。 其他配置本节对应官方文档中“Boot the live environment”小节到“Reboot”小节。大多数情况下只需要根据目标机器的环境修改少数参数就可以直接执行上面的代码。 网络服务正如官方文档中提到的那样，安装镜像中的系统与用户实际使用的系统并不完全相同，在前者环境中能够正常运作的机能可能在后者环境中便会失灵。“Install essential packages”小节中也提到了一些可选的在安装系统时即配置的软件包，不过其中最重要的是网络服务相关的包。若不能保证离开安装镜像环境后 Arch Linux 的网络通信正常，读者可以自行安装相关的包，必要时可提前配置。 另外，对命令行环境不熟悉或读写配置文件不顺畅的读者，可以安装 nmtui，用以在交互式环境下管理网络服务。笔者选择的包为：net-tools、iproute2、dhcpcd、traceroute、networkmanager（nmtui 被包含在该包中）。 文本编辑器后续的安装操作需要读写配置文件，因此建议安装 vim 或 nano 等文本编辑相关的包。 Boot loader这需要读者仔细阅读官方文档（如 GRUB）的全文。绝大多数可能的情况在文档中都有描述。对于笔者的设备，笔者使用 GRUB 做了如下操作，以保证 NTFS 分区下的 Windows 能被 GRUB 识别（假定已经 arch-chroot 进入系统）： 1234pacman -S os-prober grub ntfs-3ggrub-install --target=i386-pc /dev/sda# 修改 `/etc/default/grub`，将 `#GRUB_DISABLE_OS_PROBER=false` 一行的注释去除grub-mkconfig -o /boot/grub/grub.cfg 确认无误后，执行后续安装步骤。 安装后读者可以在官方文档中阅读有关安装后推荐的行动。 桌面环境笔者选择的桌面环境是： 显示服务器：Xorg（优先安装） 显示管理器：SDDM 桌面环境：KDE 这些在 Arch Linux Wiki 上都有同名词条，且描述得十分详细。这里不作赘述。即便在安装桌面环境后未能正常显示桌面，也可以使用其他 TTY 在终端下操作。 对于其中涉及的安装包，笔者不建议安装元包（包名含“-meta”）。这是考虑到： 一般安装桌面环境所需的包后，无彻底卸载的需求； 应用程序相关的组件中若有想卸载的，由于这些组件都是元包的依赖项，此时无法完成卸载。 若不慎安装元包，也可以在 Live CD 环境中卸载元包后重新安装组包（包名不含“-meta”，安装时需要选择组别）。结束后执行 pacman -Qsq &lt;包名&gt; 验证。 多用户登录界面如果读者需要在开机时启动桌面环境，官方文档给出了一种方案。但直接按照文档配置，会发现启动计算机后仍然停留在 TTY1 的终端登录页面，输入用户名后跳过输入密码阶段直接进入桌面环境。这显然不是我们所期待的。修复这个问题很简单，只需要将所给的配置项 123if [ -z &quot;${DISPLAY}&quot; ] &amp;&amp; [ &quot;${XDG_VTNR}&quot; -eq 1 ]; then exec startxfi 放置在系统配置文件 /etc/profile 中即可。 本地化参见《【Arch Linux】本地化：简体中文》和《【Arch Linux】本地化：日语》。 UEFI 和 GPT以下所列同样仅是笔者机器的情况。请读者根据遇到的情况自行判断。 分区根据笔者机器情况，笔者设计的分区方案如下： 分区 文件类型 启动项 挂载点 安装镜像环境中的挂载点 /dev/sda1 Linux 是 /boot /mnt/boot /dev/sda5 Linux 否 / /mnt /dev/sdb4 Linux 否 /home /mnt/home /dev/sdb5 Linux 否 /usr /mnt/usr /dev/sdb6 Linux swap / Solaris 否 [SWAP] 注意到这里 /usr 和 /、/boot 分属不同的硬盘。此类情况将在后文加以说明。 U 盘启动无法找到盘符的问题尝试在 UEFI+GPT 的机器上安装时，未出现此问题。 Boot loader笔者仍然使用 GRUB，但所执行的命令需要更改： 1grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB 这将在 /boot/EFI 文件夹中生成 GRUB 文件夹。一些旧教程中添加了诸如 /dev/sda、/dev/sdb 的参数，但现在实则是不需要的。 /usr 单独分区导致启动失败按照类似笔者的方案分区后，启动系统将失败，并显示类似如下的界面： 123456/dev/sda1: recovering journalError:Root device mounted successfully, but /sbin/init does not exist.Bailing out, you are on your own.Good luck.sh: can't access tty; job control turned off[rootfs ]# 根据官方文档的说明，读者需要重新进入 Live CD 环境，挂载所有分区后 arch-chroot 进入 chroot 环境。编辑其中的 /etc/mkinitcpio.conf 文件，修改类似如下的行 1HOOKS=(base udev autodetect modconf block filesystems keyboard fsck) 为 1HOOKS=(base udev autodetect modconf block filesystems keyboard fsck usr shutdown) 随后重制镜像并重启： 12mkinitcpio -Preboot WaylandWayland 也是一种显示服务协议（display server protocol），致力于成为 Xorg 的优秀后继者。Wayland 亦有兼容 Xorg 和 KDE 的实现，且 SDDM 依然能使用，但在 KDE 环境中并无相对 Xorg 的明显优势。 参照官方文档在 Xorg 基础上安装 Wayland 相关的包，并在登录界面左上角选择桌面为“Plasma (Wayland)”。 注意使用 Wayland 作为显示服务协议时，一些教程中涉及到 .xprofile 等配置文件将会失效。读者需要根据实际情况正确配置。在此不作赘述。","link":"/techdev/arch/installation/"},{"title":"【Arch Linux】编译安装 AUR 上的 Linux 内核","text":"Arch Linux 可以使用多种 Linux 内核. 默认的内核由官方 core 仓库的 linux 包提供, 一般另附有 linux-headers 包. 官方仓库中提供的预编译内核还有同为 core 仓库的 linux-lts 和 extra 仓库的 linux-zen. 不过, 在一些场合下, 例如需要更新的或是有 patch 的内核时, 我们可能需要从 AUR 中获取需要的内核并手动编译安装. 本文以 linux-mainline 包为例, 主要借助 yay 更便捷地处理相关操作. 通常情况下, 只需要 yay -S linux-mainline 即可. 以下需要对编译安装过程做一些可选操作. 获取 PKGBUILD使用 yay 的 -G 选项仅获得 PKGBUILD 等相关的文件. 添加 --force 以强制保持与上游 AUR 包内容一致. 由于该操作默认目标文件夹为当前文件夹, 所以可以切换到 ~/.cache/yay 后再获取. 12mkdir -p ~/.cache/yay &amp;&amp; cd ~/.cache/yayyay -G --force linux-mainline (可选) 修改上游仓库 URL进入 linux-mainline 文件夹查看 PKGBUILD 后可以发现其从 &lt;kernel.org&gt; 的 Git 服务器获取上游的 Linux 源码: 123456...source=( &quot;$_srcname::git+https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git#tag=$_tag&quot; config # the main kernel config file)... 但是完整的 Linux 仓库体积已经超过 2 GB, 对于中国大陆用户不够友好. 好在 &lt;kernel.org&gt; 在北京已经设置 Git 镜像: https://kernel.source.codeaurora.cn/. 所以我们可以修改上游仓库的 URL, 以提高下载速度. 在编辑器中打开 PKGBUILD: 123426c26&lt; &quot;$_srcname::git+https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git#tag=$_tag&quot;---&gt; &quot;$_srcname::git+https://kernel.source.codeaurora.cn/pub/scm/linux/kernel/git/torvalds/linux.git#tag=$_tag&quot; 或者是执行下面的命令修改: 1sed -i 's/git+https\\:\\/\\/git\\.kernel\\.org\\/pub\\/scm\\/linux\\/kernel\\/git\\/torvalds\\/linux\\.git/git+https:\\/\\/kernel.source.codeaurora.cn\\/pub\\/scm\\/linux\\/kernel\\/git\\/torvalds\\/linux.git/' PKGBUILD 此外, 还可以通过 yay 的 --editmenu 参数交互式编辑: 1yay -S --editmenu linux-mainline (可选) 获取 PGP 密钥查看 PKGBUILD 可以看到用户需要接受三个 PGP 密钥, 分别是: 1234567...validpgpkeys=( 'ABAF11C65A2970B130ABE3C479BE3E4300411886' # Linus Torvalds '647F28654894E3BD457199BE38DBBDC86092693E' # Greg Kroah-Hartman 'A2FF3A36AAA56654109064AB19802F8B0D70FC30' # Jan Alexander Steffens (heftig))... 但是安装过程中可能发现 yay 卡在获取密钥的部分. 对于后两个密钥, 可以通过:^1 12gpg --keyserver hkp://keys.openpgp.org --recv-keys 647F28654894E3BD457199BE38DBBDC86092693Egpg --keyserver hkp://keys.openpgp.org --recv-keys A2FF3A36AAA56654109064AB19802F8B0D70FC30 获取. 这个选项可以持久化:^2 1yay -Y --gpgflags &quot;--keyserver hkp://keys.openpgp.org&quot; --save 不过对于第一个密钥, 可能需要其他的方法. 首先保证存在 gpg2 (对应包为 core 仓库的 gnupg), 再: 1gpg2 --auto-key-locate cert,pka,dane,wkd,keyserver --locate-keys torvalds@kernel.org (可选) 多线程编译安装需要手动传入 make 命令的编译 flags: 1MAKEFLAGS=&quot;-j16&quot; yay -S linux-mainline # 16 线程 多线程编译仍然可能需要较长时间 (笔者测试需要 30 分钟左右, 因机器配置而异). 请不要断电. 更新 Boot loader 配置以 GRUB 为例: 1sudo grub-mkconfig -o /boot/grub/grub.cfg 重启这是非常重要的 - 否则折腾半天系统服务没法加载的时候会很痛苦. 参考","link":"/techdev/arch/kernel-compilation/"},{"title":"【Arch Linux】本地化：简体中文","text":"本文主要介绍 Arch Linux 本地化为简体中文的操作。 本文的测试环境是 KDE Plasma + SDDM + Wayland。考虑到 Xorg 教程较多，且大部分操作通用，本文会存在 Xorg 和 Wayland 混合描述的情况。 必要配置不建议用户日常使用 root 帐户，则此时用户的当前帐户建议拥有 sudo 权限。安装 sudo 包。 同时部分本地化安装包在 AUR 源中，建议用户安装 AUR helper。本文以 yay 为例。 生成语言环境^1编辑 /etc/locale.gen，找到 #en_US.UTF-8 UTF-8 和 #zh_CN.UTF-8 UTF-8，删除前面的注释符号“#”。 再生成语言环境文件： 1sudo locale-gen 为保证大部分程序和终端环境显示正常，在 /etc/locale.conf 中设置 LANG 环境变量： 1LANG=en_US.UTF-8 （可选）为 Xorg 图形界面设置中文语言环境编辑 ~/.xinitrc 或 ~/.xprofile： 12export LANG=zh_CN.UTF-8export LANGUAGE=zh_CN:en_US 显示简体中文字体此时图形界面的中文显示一般是异常的。这可以通过安装相关字体解决。 安装字体^21sudo pacman -S wqy-microhei wqy-microhei-lite wqy-bitmapfont wqy-zenhei ttf-arphic-ukai ttf-arphic-uming adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts noto-fonts-cjk 可选 AUR 源中 ttf-ms-win11-auto-* 相关的包（存在已知问题，见下文）。 一般此时字体缓存已刷新。若无： 1fc-cache -fv 可以通过类似下述命令验证字体缓存： 1fc-match -s | grep 'Noto Sans CJK' ttf-ms-win11-auto-* 相关包无效参见 ttf-ms-win11-auto AUR 包详情页面下的评论： It still throws ln: failed to create symbolic link '/home/&lt;User&gt;/.cache/yay/ttf-ms-win11-auto/src/' -&gt; '': No such file or directory warnings when I install the package via yay. Manually copy/move the font files from ~/.cache/yay/ttf-ms-win11-auto/src to /usr/share/fonts and fc-cache -fv can solve the problem. 因此，读者只需查看 AUR 包的缓存（如 ~/.cache/yay/ttf-ms-win11-auto），找到其中的字体文件，或是解压其中的压缩包（如 ttf-ms-win11-auto-zh_cn-10.0.22000.318-2-any.pkg.tar.zst）得到字体文件，将其复制到 /usr/share/fonts 并重新生成字体缓存即可。 修复简体中文字符显示为日文的问题^3新建文件 /etc/fonts/conf.avail/64-language-selector-prefer.conf： 若安装 noto-fonts-cjk 包： 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;&lt;fontconfig&gt; &lt;alias&gt; &lt;family&gt;serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Noto Serif CJK SC&lt;/family&gt; &lt;family&gt;Noto Serif CJK TC&lt;/family&gt; &lt;family&gt;Noto Serif CJK JP&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;sans-serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Noto Sans CJK SC&lt;/family&gt; &lt;family&gt;Noto Sans CJK TC&lt;/family&gt; &lt;family&gt;Noto Sans CJK JP&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;monospace&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Noto Sans Mono CJK SC&lt;/family&gt; &lt;family&gt;Noto Sans Mono CJK TC&lt;/family&gt; &lt;family&gt;Noto Sans Mono CJK JP&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt;&lt;/fontconfig&gt; 若安装 adobe-source-han-sans-otc-fonts 包： 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;&lt;fontconfig&gt; &lt;alias&gt; &lt;family&gt;serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Source Han Serif SC&lt;/family&gt; &lt;family&gt;Source Han Serif TC&lt;/family&gt; &lt;family&gt;Source Han Serif HW&lt;/family&gt; &lt;family&gt;Source Han Serif K&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;sans-serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Source Han Sans SC&lt;/family&gt; &lt;family&gt;Source Han Sans TC&lt;/family&gt; &lt;family&gt;Source Han Sans HW&lt;/family&gt; &lt;family&gt;Source Han Sans K&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;monospace&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Source Han Sans SC&lt;/family&gt; &lt;family&gt;Source Han Sans TC&lt;/family&gt; &lt;family&gt;Source Han Sans HW&lt;/family&gt; &lt;family&gt;Source Han Sans K&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt;&lt;/fontconfig&gt; 然后新建软链接应用配置： 1sudo ln -s /etc/fonts/conf.avail/64-language-selector-prefer.conf /etc/fonts/conf.d/64-language-selector-prefer.conf 随后刷新字体缓存生效： 1fc-cache -fv 中文输入法本文使用 Fcitx 5 框架配套 Rime 输入法引擎和 Clover Pinyin（四叶草拼音）输入方案。 Fcitx 5安装^41sudo pacman -S fcitx5 fcitx5-qt fcitx5-gtk fcitx5-configtool 在 Xorg 环境下，编辑 ~/.xprofile：^5 123456export GTK_IM_MODULE=fcitx5export QT_IM_MODULE=fcitx5export XMODIFIERS=&quot;@im=fcitx5&quot;export LANG=&quot;zh_CN.UTF-8&quot;export LC_CTYPE=&quot;zh_CN.UTF-8&quot; 在 Wayland 环境下，编辑 /etc/environment： 123GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=&quot;@im=fcitx&quot; 注销会话或重启。 外观本文使用 Material Color 皮肤。 1sudo pacman -S fcitx5-material-color 再编辑 Fcitx 5 的配置文件 ~/.config/fcitx5/conf/classicui.conf：^6 1234567891011# 垂直候选列表Vertical Candidate List=False# 按屏幕 DPI 使用PerScreenDPI=True# Font (设置成你喜欢的字体)Font=&quot;思源黑体 CN Medium 13&quot;# 主题Theme=Material-Color-Pink 诊断工具1fcitx5-diagnose Rime安装1sudo pacman -S fcitx5-rime 重启 Fcitx 5。依次 System Settings -&gt; Regional Settings -&gt; Input Method -&gt; Add Input Method… -&gt; Only Show Current Language [Uncheck] -&gt; Rime（中州韻）来激活输入法。 注意：Rime 系统目录位于 /usr/share/rime-data。本地目录 ~/.local/share/fcitx5/rime 可以覆盖前者的配置。 单行模式单行模式类似于 Windows 10 中微软拼音的默认行为：输入的拼音序列能同时键入到文本中，待选定候选词后才将其替换为对应的词。 编辑 ~/.config/fcitx5/conf/rime.conf：^7 12# 可用时在应用程序中显示预编辑文本（开启单行模式）PreeditInApplication=True Clover Pinyin安装1yay -S rime-cloverpinyin 编辑 ~/.local/share/fcitx5/rime/default.custom.yaml： 12345patch: # 每页候选词个数 &quot;menu/page_size&quot;: 9 schema_list: - schema: clover 重启 Fcitx 5。 注意：Clover Pinyin 有关快捷键等配置位于 ~/.local/share/fcitx5/rime/build/clover.schema.yaml。 Emoji12sudo pacman -S noto-fonts-emojiyay -S noto-color-emoji-fontconfig 注销会话或重启。 特殊符号指输入特殊符号拼音出现候选词（如“pingfang”出现“²”），或输入“/xx”（“xx”表示一些英文字母的组合）出现一类候选词（如“/sx”出现数学相关特殊符号）。 对于前者，目前尚无较好的解决方案。 对于后者，参考该回复。 注意：特殊符号支持存在已知问题，可能导致内存溢出，可以通过如下命令简单修复：^8 123python -c &quot;$(curl -fsSL https://github.com/fkxxyz/rime-symbols/raw/master/rime-symbols-gen)&quot;mkdir -p ~/.local/share/fcitx5/rime/openccmv symbol.json symbol_category.txt symbol_word.txt ~/.local/share/fcitx5/rime/opencc 重新部署 Rime。 参考","link":"/techdev/arch/localization-simplified-chinese/"},{"title":"【Arch Linux】maddy 邮件服务器搭建","text":"maddy 是一个开源的轻量级“可组合”（composable）多合一邮件服务器，支持通过 IMAP/SMTP 等协议和 DKIM、SPF、DMARC、DANE、MTA-STS 等安全模式收发邮件。本文将以官方文档为主线，整理 maddy 服务器配置流程。 准备为保证 maddy 的正常运行，请先明确一些建议满足的前提条件： 具有公网地址（本文以 IPv4 为例）并开放 25、143、465（TLS）、587、993（TLS）等端口（一些 VPS 提供商如谷歌云不支持）的服务器； 拥有一个域名（最好是付费二级域名，避免一些 DNS 服务商如 Cloudflare 封禁对其的 API 操作），并接入 DNS 服务商（本文以 Cloudflare 为例）； TLS 证书（本文以 Let’s Encrypt 和一款证书获取软件 certbot 为例）。 为叙述方便，本文假设邮件服务器的主域名为 example.org，邮件交换（MX）域名为 mx1.example.org，公网 IPv4 地址为 10.2.3.4，邮件账户为 postmaster@example.org。 同时需要在服务器上至少安装如下的软件包： maddy certbot certbot-dns-cloudflare nginx（或其他 Web 服务端） 除 maddy 外，其他的软件包都可以使用 pacman 直接安装。 安装可以在 GitHub 的 Releases 页面获取 maddy 最新版本的源码和预编译程序。也可以参照官方文档的说明，从源码构建、AUR 处获取或 Docker 镜像部署。 注意：从 AUR 处获取需要下载体积很大的 golang 编译器。为节约下载并安装编译器的时间，读者可以直接使用 GitHub 的预编译程序。本文也以此为例。 在服务器终端中执行如下命令，以下载 maddy 的预编译程序： 123456789101112131415161718# 安装 zstd 包，以解压 *.zst 类型的文件sudo pacman -S zstd --needed# 下载地址，可以任意选择cd ~/Downloadswget https://github.com/foxcpp/maddy/releases/download/v0.5.4/maddy-0.5.4-x86_64-linux-musl.tar.zst# 参考 zsh 的 extract 插件tar --zstd -xvf maddy-0.5.4-x86_64-linux-musl.tar.zst || zstdcat maddy-0.5.4-x86_64-linux-musl.tar.zst | tar xvf -cd maddy-0.5.4-x86_64-linux-musl# 复制服务sudo cp systemd/*.service /etc/systemd/system# 复制可执行文件sudo cp maddy maddyctl /usr/local/bin# 复制配置文件sudo mkdir -p /etc/maddysudo cp maddy.conf /etc/maddy# 复制 man 文件sudo cp man/*.1 /usr/share/man/man1sudo cp man/*.5 /usr/share/man/man5 启动服务前，先加载所有新增服务： 1sudo systemctl daemon-reload 若要开机自启： 1sudo systemctl enable maddy 因为 maddy 运行在非 root 用户上，还需要创建一个用户用以运行 maddy 服务： 1sudo useradd -mrU -s /sbin/nologin -d /var/lib/maddy -c &quot;maddy mail server&quot; maddy 配置域名使用任何编辑器打开 /etc/maddy/maddy.conf，修改 $(hostname) 和 $(primary_domain) 变量的值为 mx1.example.org 和 example.org。 TLS 证书获取Let’s Enccrypt 签发的 TLS 证书可以通过 certbot 获取。根据 certbot 和 certbot-dns-cloudflare 的官方文档，首先需要在 Cloudflare 的 API Token 配置页面新建一个 Token，选择“Edit zone DNS”的模板，在“Zone Resources”选择目标二级域名（本文则是“example.org”）即可。 注意：Token 只会显示一次，在配置好证书前，请务必牢记。 随后，可以在服务器上存储 Token 以方便后续使用。在终端中执行： 12mkdir -p ~/.secrets/certbotecho '&lt;TOKEN&gt;' &gt; ~/.secrets/certbot/cloudflare.ini # 替换为获取到的 Token 并设置权限提高安全性： 1chmod 600 ~/.secrets/certbot/cloudflare.ini 再使用 certbot 获取证书： 1sudo certbot certonly --dns-cloudflare --dns-cloudflare-credentials ~/.secrets/certbot/cloudflare.ini -d '*.example.org' -d 'example.org' 注意：可以选择不为含通配符域名，而是根据后文实际需要指定必要的三级域名签发证书。 首次获取证书需要填写邮箱等个人信息。签发完毕后则可以通过 sudo certbot certificates 获取证书的详细信息和存储位置。一般存储位置在 /etc/letsencrypt/live/example.org，其中证书文件名为 fullchain.pem，私钥路径为 privkey.pem。 配置编辑 /etc/maddy/maddy.conf，修改 tls file 一行为 1tls file /etc/letsencrypt/live/$(primary_domain)/fullchain.pem /etc/letsencrypt/live/$(primary_domain)/privkey.pem /etc/letsencrypt/live 文件夹默认权限为 750，maddy 无法访问，故需要使用 ACL 进行权限控制： 1sudo setfacl -R -m u:maddy:rX /etc/letsencrypt/{live,archive} 此时可以启动 maddy 服务来测试： 1sudo systemctl start maddy 若服务未报错，则可以继续进行配置。 DNS进入 Cloudflare 的 DNS 配置页，作出如下所示的配置： 123456789example.org. A 10.2.3.4example.org. MX 10 mx1.example.org.mx1.example.org. A 10.2.3.4example.org. TXT &quot;v=spf1 mx ~all&quot;mx1.example.org. TXT &quot;v=spf1 mx ~all&quot;_dmarc.example.org. TXT &quot;v=DMARC1; p=quarantine; ruf=mailto:postmaster@example.org&quot;_mta-sts.example.org. TXT &quot;v=STSv1; id=1&quot;_smtp._tls.example.org. TXT &quot;v=TLSRPTv1;rua=mailto:postmaster@example.org&quot;default._domainkey.example.org. TXT &quot;v=DKIM1; k=ed25519; p=nAcUUozPlhc4VPhp7hZl+owES7j7OlEv0laaDEDBAqg=&quot; 其中最后一条记录的值需要用 1sudo cat /var/lib/maddy/dkim_keys/example.org_default.dns 的输出替换。若显示文件不存在，请确认 maddy 服务是否曾成功运行过至少一次。 MTA-STSMTA-STS 要求访问 https://mta-sts.example.org/.well-known/mta-sts.txt 时能输出类似如下的文本： 1234version: STSv1mode: enforcemax_age: 604800mx: mx1.example.org 对于已经安装 HTTP Echo 模块的 Nginx，直接在 /etc/nginx/nginx.conf 中添加如下条目： 1234567891011121314151617server { listen 443 ssl http2; server_name mta-sts.example.org; error_log /var/log/nginx/log.log; ssl_certificate /etc/letsencrypt/live/example.org/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.org/privkey.pem; ssl_session_timeout 5m; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location /.well-known/mta-sts.txt { echo 'version: STSv1'; echo 'mode: enforce'; echo 'max_age: 604800'; echo 'mx: mx1.example.org'; }} 对于未安装该模块的 Nginx，先添加如下条目： 123456789101112131415server { listen 443 ssl http2; server_name mta-sts.example.org; error_log /var/log/nginx/log.log; ssl_certificate /etc/letsencrypt/live/example.org/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.org/privkey.pem; ssl_session_timeout 5m; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location /.well-known/mta-sts.txt { root /usr/share/nginx/mta-sts; # /usr/share/nginx 是 Nginx 的静态资源默认位置 index /mta-sts.txt; }} 再新建 /usr/share/nginx/mta-sts 文件夹，将指定文本写入 mta-sts.txt 文件中： 123456sudo cat &lt;&lt;EOFversion: STSv1mode: enforcemax_age: 604800mx: mx1.example.orgEOF &gt; /usr/share/nginx/mta-sts/mta-sts.txt 重启 Nginx 服务： 1sudo systemctl restart nginx 检查上述网络路径是否能够正常访问。 DANE设置 TLSA（DANE）需要在 https://www.huque.com/bin/gen_tlsa 生成对应的 DNS 记录。 进入页面后，在“Enter/paste PEM format X.509 certificate here:”下的文本框中输入上文中获取的证书的内容： 1sudo cat /etc/letsencrypt/live/example.org/fullchain.pem 注意：该证书很长，务必复制完全。 下方的“Port Number:”填写 25，Transport Protocol: 填写 tcp，Domain Name: 填写 mx1.example.org。再点击“Generate”生成记录。将 DNS 记录写入 Cloudflare 中。 创建邮件账户在服务器终端中： 12maddyctl creds create postmaster@example.orgmaddyctl imap-acct create postmaster@example.org 此时，邮件账户的用户名为“postmaster@example.org”，密码则在创建账户时要求设置。该账户已经可以在邮件客户端（如 Thunderbird 和 Outlook）中配置并使用。 （可选）开启 DNSSEC 认证DNSSEC（Domain Name System Security Extensions），即域名系统安全扩展，对DNS提供给DNS客户端（解析器）的DNS数据来源进行认证，并验证不存在性和校验数据完整性验证。 Arch Wiki 中给出了一些验证方法。安装 ldns 包后： 1234$ drill -DT example.org # 替换为二级域名# 省略多行[T] example.org. 60 IN A 10.2.3.4;;[S] self sig OK; [B] bogus; [T] trusted 如果命令执行结果如上所示（域名前的 flag 值为“T”），则说明 DNSSEC 认证已开启；反之，请参考 Install a DNSSEC-validating resolver 章节，或参考 DNS 服务商的文档。 以下简单介绍 Cloudflare 为域名开启 DNSSEC 的方法：进入 Cloudflare 控制台后，进入目标域名的详情页面，点击左侧的“DNS”选项卡，在页面尾部的“DNSSEC”部分点击“Enable DNSSEC”。随后 Cloudflare 将给出域名的 DS Record。再进入域名注册商的域名管理页面设置 DS Record。具体设置方法参照 Cloudflare 的官方文档。","link":"/techdev/arch/maddy/"},{"title":"【Arch Linux】misskey 手动部署和配置","text":"misskey 是一款开源的“跨星际”（interplanetary）社交平台，以微博为主要形式，界面美观，内含元素丰富。本文即针对该平台在 Arch Linux 的手动安装方式作说明。 笔者：为什么不用 docker 安装（这是官方认定 recommended 的安装方式）？只是不怎么想用 docker（ 注意：基于 Arch Linux 发行版的特殊性（非开箱即用），笔者会尽可能多地补充安装过程，尽可能让读者能从头到尾依照本文操作。但若存在疏漏，敬请谅解。 检查系统配置misskey 对服务端的性能配置要求较高，建议配置至少 2 核 CPU 和 4GB RAM。笔者使用的服务器部分配置如下（多人共有，但对 misskey 来说也已足够）： 123456$ neofetch# 省略部分输出OS: Arch Linux x86_64Kernel: 5.15.34-1-ltsCPU: AMD EPYC 7282 (4) @ 2.794GHzMemory: 1590MiB / 7950MiB 安装依赖系统安装所有依赖（这里假设读者已经安装了 sudo 并配置好相关权限）： 12345sudo pacman -Syu # 更新系统sudo pacman -S sudo visudo nano base-devel python --neededsudo python -m ensurepip --upgrade # 安装/升级 pipsudo ln -sf /usr/bin/{nano,vi}sudo visudo 在打开的编辑器 nano 中去除 #%wheel ALL=(ALL:ALL) ALL 一行前的注释，依次按 Ctrl+X、y、Enter 保存。 同时考虑到 pip 用户配置下 $PATH 环境变量问题，使用编辑器打开当前终端配置（例如 ~/.bashrc），添加如下行： 1PATH=~/.local/bin:$PATH misskey官方文档中给出的 misskey 需要的依赖有： Node.JS（16.x） PostgreSQL（建议 12.x 或 13.x） Redis yarn（可选，若不安装，后续安装过程中 yarn 应替换为 npx yarn） FFmpeg 考虑到大部分软件的向后兼容性，可以直接安装所有依赖： 1sudo pacman -S nodejs npm postgresql redis yarn ffmpeg --needed 用户因笔者服务器环境中存在多用户、多管理情况，此处的操作与官方文档不同——创建了一个有 sudo 权限、可登录、有家目录的用户。 1useradd -m -G wheel -s /bin/bash misskey 并使用 sudo passwd misskey 设置登录密码。 若依照官方文档，仅需： 1useradd -r -s /usr/bin/nologin misskey 之后切换入该用户继续操作：su - misskey。 下载源码根据上文中用户创建方式，目录的路径可能不能完全如文中所述。请读者根据自身情况合理选择安装路径。 在终端中执行： 12345mkdir .optcd .optgit clone --recursive https://github.com/misskey-dev/misskey.gitcd misskeygit checkout master 注意：截至本文编写时，misskey 源码库克隆大小 88.22MB，子库（misskey-assets）克隆大小 69.76MB。请自行选择是否“科学上网”或使用镜像站。 安装依赖库在终端中执行： 1yarn 注意：请自行选择是否“科学上网”或使用镜像站。 注意：该过程耗时较长。若无人值守，建议使用 tmux 或 screen 防止 ssh 连接中断导致安装过程中断。 编译在终端中执行： 1NODE_ENV=production yarn build 注意：该过程耗时较长。若无人值守，建议使用 tmux 或 screen 防止 ssh 连接中断导致安装过程中断。 初始化数据库Postgresql在终端中执行： 1234567891011sudo -iu postgres # 切换到 postgres 用户initdb -D /var/lib/postgres/data# （可选）修改 locale 和编码：# initdb --locale=en_US.UTF-8 --encoding=UTF8 -D /var/lib/postgres/dataexit # 返回 misskey 用户sudo systemctl enable postgresql --nowsudo systemctl status postgresql # 查看服务状态# （可选）添加 SQL 操作历史文件sudo touch /var/lib/postgres/.psql_historysudo chown postgres:postgres /var/lib/postgres/.psql_historysudo -u postgres psql 进入 Postgresql 操作界面，执行： 1234create database misskey;create user misskey with encrypted password '{YOUR_PASSWORD}';grant all privileges on database misskey to misskey;\\q 其中上面的 '{YOUR_PASSWORD}' 可以任意配置，但需要和后面的 misskey 配置文件保持一致。 Redis在终端中执行： 12sudo systemctl enable redis --nowsudo systemctl status redis # 查看服务状态 前置配置从 .config 文件夹中复制 example.yml 到 default.yml： 1cp .config/{example,default}.yml 然后使用编辑器编辑后者，例如 nano .config/default.yml。其中最重要的配置（不修改就会直接导致 misskey 跑不通）是： 12345678910111213# ┌──────────────────────────┐#───┘ PostgreSQL configuration └────────────────────────────────db: host: localhost port: 5432 # Database name db: misskey # Auth user: example-misskey-user pass: example-misskey-pass 将其中的 user 配置项改为 user: misskey，pass 配置项根据上面的配置保持一致。 初始化在终端中执行： 12yarn run initNODE_ENV=production npm start 若在终端中看到类似如下的输出： 1234567891011121314INFO * [core boot] Welcome to Misskey!INFO * [core boot] Misskey v12.110.1INFO * [core boot env] NODE_ENV: productionINFO * [core boot env] You do not have root privilegesINFO * [core boot nodejs] Version v17.9.0 detected.DONE * [core boot config] LoadedINFO * [core boot db] Connecting...DONE * [core boot db] Connected: v14.2DONE * [core boot] Misskey initializedINFO * [core boot] Starting 1 worker...(node:324552) ExperimentalWarning: Importing JSON modules is an experimental feature. This feature could change at any time(Use `node --trace-warnings ...` to show where the warning was created)DONE * [core boot] All workers startedDONE * [core boot] Now listening on port 3000 on https://example.tld 则表示 misskey 部署成功。 配置systemd 服务可以配置 systemd 服务让其管理 misskey 的运行。新建 /etc/systemd/system/misskey.service，在编辑器中打开并填入如下内容： 1234567891011121314151617[Unit]Description=Misskey daemon[Service]Type=simpleUser=misskeyExecStart=/usr/bin/npm startWorkingDirectory=/home/misskey/.opt/misskeyEnvironment=&quot;NODE_ENV=production&quot;TimeoutSec=60StandardOutput=syslogStandardError=syslogSyslogIdentifier=misskeyRestart=always[Install]WantedBy=multi-user.target 然后分别通过 sudo systemctl start misskey 和 sudo systemctl enable misskey 启动 misskey 并添加开机自启。 端口转发（反向代理）和 TLSmisskey 支持 HTTPS/SSL/TLS 。这需要配置相关证书，并设置端口转发（反向代理）。笔者使用的软件包是 nginx，并已在 Cloudflare 添加一个域名。 注意：部分免费二级域名（如 .cf、.tk）无法使用后文中提及的 Cloudflare API 自动更新 DNS 记录。请读者自行选用其他域名，或使用其他 DNS 服务。 证书首先安装自动签发 Let’s Encrypt 证书的软件包 certbot： 1python -m pip install certbot certbot-cloudflare-dns 为防止证书信息泄露（certbot 默认工作和日志目录均在 /etc、/var 等文件夹中），先创建相关文件夹： 12# 工作目录、日志目录、配置目录（存放证书）mkdir -p ~/.var/letsencrypt ~/.logs/letsencrypt ~/.etc/letsencrypt 再写入 Cloudflare API 的相关配置文件： 12mkdir -p ~/.secrets/certbotecho 'dns_cloudflare_api_token = {API_TOKEN}' &gt; ~/.secrets/certbot/cloudflare.ini 其中 {API_TOKEN} 表示 Cloudflare 账户的 API token。请参见 Cloudflare 和 Certbot 相关文档配置。 为保证安全性，建议为其重新配置权限： 12chmod -R 700 ~/.secretschmod -R 600 ~/.secrets/certbot/cloudflare.ini 最后，在终端中执行： 12# 此处使用 Cloudflare API 更新 DNScertbot certonly --dns-cloudflare --dns-cloudflare-credentials ~/.secrets/certbot/cloudflare.ini -d '{domain}' --config-dir ~/.etc/letsencrypt --work-dir ~/.var/letsencrypt --logs-dir ~/.logs/letsencrypt 其中 '{domain}' 是为 misskey 分配的域名。certbot 运行过程中需要同意相关服务条款并输入邮箱注册。 DNS在 DNS 服务商（如 Cloudflare）中添加一条 A/AAAA 记录，从域名指向服务器的 IP 地址。 端口转发（反向代理）在终端中执行： 12sudo pacman -S nginx-mainline --neededsudo systemctl enable nginx --now 再打开 /etc/nginx/nginx.conf，添加如下类似的配置项： 1234567891011121314151617181920server { listen 443 ssl http2; server_name '{domain}'; error_log /var/log/nginx/log.log; ssl_certificate /home/misskey/.etc/letsencrypt/live/'{domain}'/fullchain.pem; ssl_certificate_key /home/misskey/.etc/letsencrypt/live/'{domain}'/privkey.pem; ssl_session_timeout 5m; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { proxy_pass http://localhost:3000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header Referer http://$host; }} 其中 '{domain}' 表示分配的域名。证书路径以实际情况为准。 最后重启 nginx 服务： 1sudo systemctl restart nginx misskey打开 misskey 配置文件 ~/.opt/misskey/.config/default.yml，修改如下配置项： 12345# ┌─────┐#───┘ URL └─────────────────────────────────────────────────────# Final accessible URL seen by a user.url: '{domain}' 设置为先前分配的域名。 最后重启 misskey 服务： 1sudo systemctl restart misskey 特别致谢感谢一位朋友“梦可味”在撰写本文前提供的在 Ubuntu 发行版中安装 misskey 的教程，其上有对多处踩坑的详细记录，让笔者能更快速地完成安装。之后会发布 misskey 在 Ubuntu 下的安装及配置教程。 参考 misskey 官方文档 build-essential in Arch Linux Users and groups - ArchWiki","link":"/techdev/arch/misskey/"},{"title":"Arch Linux 安装 TiddlyWiki + 配置服务 + 添加自定义插件 + Cloudflare 代理 + Caddy 反向代理","text":"本文将覆盖 TiddlyWiki Node.JS 版本在 Arch Linux 上的安装, 并涉及配置 TiddlyWiki 服务, 添加自定义插件, 在 Cloudflare 代理 DNS 的情形下设置 Caddy 反向代理的内容. 笔者因为自己和身边发生了各种各样的事情, 疲于更新博客. 今天只能随手写写. 较详细的本文将覆盖的内容 TiddlyWiki 安装 配置一个 systemd 服务 将自定义插件放置在统一目录下 Cloudflare 添加 DNS 记录 申请 API token Caddy 编译自定义 build 配置反向代理 添加 HTTP basic auth 测试 相关软件包和工具 TiddlyWiki: 一个非线性个人 wiki; xcaddy: 自定义编译 caddy; caddy: 反向代理. TiddlyWiki安装1npm install -g tiddlywiki 检查版本12$ tiddlywiki --version5.2.7 初始化并监听123456cd /path/to/mywikitiddlywiki . --init# 默认 host=127.0.0.1 port=8080tiddlywiki . --listen# 或者tiddlywiki . --listen host=0.0.0.0 port=8081 若在终端中输出了诸如缺少 &quot;tiddlywiki/filesystem&quot;, &quot;tiddlywiki/tiddlyweb&quot; 插件的消息, 请在 /path/to/mywiki 中的 tiddlywiki.info 对应位置添加如下内容: tiddlywiki.info12345678{ ... &quot;plugins&quot;: [ &quot;tiddlywiki/filesystem&quot;, &quot;tiddlywiki/tiddlyweb&quot; ] ...} 随后重新监听. 配置服务为方便控制启动参数, 可以考虑在 /path/to/mywiki 中新建如下的启动脚本 (例如, 命名为 server.sh): server.sh123#!/bin/shtiddlywiki `dirname $0` --listen $@ 并使用 chmod +x server.sh 使其可以被执行. 确认 TiddlyWiki 可以正常工作后, 新建 /usr/lib/systemd/system/tiddlywiki.service 文件, 添加如下内容: tiddlywiki.service123456789101112[Unit]Description=A non-linear personal web notebookAfter=network.target[Service]EnvironmentFile=-/usr/local/etc/tiddlywiki/envExecStart=/path/to/mywiki/server.shExecReload=/bin/kill -HUP $MAINPIDRestart=on-failure[Install]WantedBy=multi-user.target 其中 /usr/local/etc/tiddlywiki/env 是一个环境变量文件, 可以忽略. 后面的操作可以向其添加必要的环境变量. 统一存储自定义插件TiddlyWiki 在 /path/to/mywiki/plugins 文件夹下的插件是不包含命名空间的[^1], 但若要在插件文件夹内以 &lt;命名空间&gt;/&lt;插件名称&gt; 的形式存储, 又不想修改 /usr/local/lib/node_modules/tiddlywiki/plugins 文件夹的内容, 则可以使用环境变量 TIDDLYWIKI_PLUGIN_PATH 指定一个 “额外” 的插件文件夹[^2]. 假设这个文件夹是 /usr/local/share/tiddlywiki/plugins, 那么只需要在 /usr/local/etc/tiddlywiki/env 文件中添加: 1TIDDLYWIKI_PLUGIN_PATH=/usr/local/share/tiddlywiki/plugins 这样, 在该文件夹下添加诸如 author/name 的插件, 在 tiddlywiki.info 中即可如同添加官方插件一般在 plugins 数组下添加 &quot;author/name&quot; 字符串即可. 本章节相关操作涉及到的需要手动更改的文件 (夹)12345/path/to/mywiki//path/to/mywiki/server.sh/usr/lib/systemd/system/tiddlywiki.service/usr/local/etc/tiddlywiki/env/usr/local/share/tiddlywiki/plugins/ Cloudflare添加 DNS 记录根据实际情况选择 A 记录或 AAAA 记录. Proxy status 选择默认的 “Proxied”. 申请 API token 右上角子菜单; “My profile”; 左侧 “API Tokens”; “Create Token”; “Edit zone DNS” 选择 “Use template”; “Zone Resources” 下可以选择指定的 zone; 如果确定服务器的 IP 可以设置 “Client IP Address Filtering”; “Continue to summary”; 复制 API token.[^3] 设置 SSL/TLS 加密模式 域名管理页面; 左侧 “SSL/TLS”; 子菜单 “Overview”; 模式选择 “Full” 或者 “Full (strict)”[^4].[^3] Caddy因为 Cloudflare 的 DNS 记录设置中选择了 “Proxied”, 现在服务器前相当于添加了一个 Cloudflare 的反向代理, 所以 Caddy 默认获取证书使用的 ACME HTTP-01 模式无法使用, 故利用 Caddy 的一个 Cloudflare 模块使用 ACME DNS-01 模式获取证书 - 这个模式通过修改 Cloudflare 上指定域名的 DNS 记录用以验证.[^5] 但由于这个模块本身并不包含在大部分软件包管理器中, 故需要手动编译包含该模块的 Caddy. 自定义编译自定义编译使用了 Caddy 官方推出的 xcaddy 工具. 编译 Caddy 时需要下载大量 Go 模块, 可能会占用较大量磁盘空间. 安装 xcaddy1yay -S xcaddy-bin [^6] 编译编译时选择临时文件夹 /tmp 作为编译目录. 12cd /tmpxcaddy build --with github.com/caddy-dns/cloudflare 待编译结束后, 将生成的 caddy 可执行文件复制到诸如 /usr/local/bin 文件夹即可. 注意环境变量 $PATH 中 /usr/local/bin 的优先级一般高于 /usr/bin, 故如此操作会使自定义编译的 caddy 优先于发行版软件包管理器中安装的版本. 配置反向代理笔者的 /etc/caddy/Caddyfile 中存在如下的配置: 1import /etc/caddy/conf.d/* 因此选择在 /etc/caddy/conf.d/tiddlywiki 的文件中编写: 1234567&lt;domain&gt;:443 { tls { dns cloudflare &lt;token&gt; } reverse_proxy localhost:8080} 以上假设 TiddlyWiki 暴露在本地网络的端口为 8080. &lt;domain&gt; 为 “添加 DNS 记录” 小节中设置的域名, &lt;token&gt; 为 “申请 API token” 小节中申请到的 API token. 随后, 格式化配置文件: 123sudo caddy fmt --overwrite /etc/caddy/Caddyfile# 或者sudo caddy fmt --overwrite /etc/caddy/conf.d/tiddlywiki 此时则可以重启 Caddy 服务检查是否正确配置 Caddy. 添加 HTTP basic authHTTP basic auth 的效果简单来说, 会在访问页面的时候提示输入用户名和密码. 先使用 Caddy 生成哈希后的密码: 1caddy_naiveproxy hash-password --plaintext &lt;plain password&gt; 其中 &lt;plain password&gt; 为明文密码. 随后修改对应的 Caddyfile: 1234567&lt;domain&gt;:443 { ... basicauth /* { &lt;username&gt; &lt;hashed password&gt; } ...} 其中 &lt;username&gt; 为 HTTP basic auth 中的用户名, &lt;hashed password&gt; 为上一步操作中生成的明文密码的哈希结果. 测试略. [^1]: https://tiddlywiki.com/static/PluginFolders.html.[^2]: https://tiddlywiki.com/static/Environment%2520Variables%2520on%2520Node.js.html.[^3]: https://samjmck.com/en/blog/using-caddy-with-cloudflare/#2-using-a-lets-encrypt-certificate.[^4]: 因为以下示例使用 Caddy 自动申请 Let’s Encrypt 证书, 所以选择 “Full (strict)” 也不会被阻断连接.[^5]: https://samjmck.com/en/blog/using-caddy-with-cloudflare/#configuration-with-proxy-enabled.[^6]: xcaddy-bin 的版本可能略旧于 xcaddy, 但前者省略了编译 xcaddy 的过程.","link":"/techdev/arch/tiddlywiki/"},{"title":"Arch Linux 在 ASUS Zenbook S 13 OLED (UM5302TA) 上的 patch","text":"综述笔者在 ASUS Zenbook S 13 OLED (UM5302TA) 上安装 Arch Linux 时, 发现仅使用 Arch Linux 官方提供的 linux 或 AUR 上的 linux-mainline 等系统 packages 无法修复一些影响使用体验的问题. 其中一些问题已经得到了有效的解决方法, 乃至被添加入 Linux 源码中; 一些问题的 patch 尚未被纳入 Linux 源码库; 还有一些问题仍无解决方案. 修复这些问题的主要方式是在 Linux 内核源码中添加 patch, 或者是使用其他的方式 (例如修改 Bootloader 的行为) 来 “动态” 添加部分系统功能. 这些问题的大部分 patch 已经有了更为自动化的解决方案. 值得注意的是, 本文提及的各种 patch 理论上可以应用于其他发行版. 存在的问题和 patchGitHub 上的 um5302ta 仓库汇集了该机型安装 Linux 后存在的各种问题, 以及针对这些问题的 patch, 本文不再赘述. 撰写本文时, 该仓库的最后一个 commit 为 b40223a. 被纳入 Linux 源码的 patch 分散在不同的内核版本, 最早可追溯到 5.19, 最晚则到了 6.1. 目前 Arch Linux 官方提供的 linux 包已经更新到了 6.1.4.arch1, 本文也以此为例. 根据该仓库的 README.md, 目前尚未解决的问题为指纹, 若无特别提及, 后文提到的 “问题” “所有问题” 并不包含指纹相关的内容. 而尚未被添加到 Linux 源码库中的问题则是扬声器的 DSDT patch 和 S3 级别睡眠的 patch. 扬声器的 patch 有两个, 经笔者测试至少可以解决如下的问题: dsdt/spkr-dsd.patch: 解决扬声器没有声音的问题; kernel/cs35l42-hda-no-acpi-dsd-csc3551.patch: 解决机载麦克风指示灯常亮的问题. S3 睡眠的 patch 未经过笔者测试. 同时对麦克风的 patch 存在已知的音量过小的问题. 本文不会涉及对此的讨论. 实际使用发现, 该机型仍然存在数字小键盘无法使用的问题并未在该仓库中提及. 该机型的数字小键盘和触控板合并, 需要通过触摸触控板某一位置开关. 由于该功能实用性有限, 且存在可能的操作上的困难, 本文也不会涉及到该问题. 主要的解决方案linux-mainline-um5302ta AUR 包 Linux 分支 Linux 版本 是否需要编译系统包 是否需要手动添加 patch 主线 &gt;= 5.19.rc4 是 否 在 Linux 最新的内核版本尚未达到 5.19 时, 所有问题可以通过这个 AUR 包修复. 该包会对 Linux 主线的 tagged version 源码添加必要的 patch, 并进行编译安装. 若系统中已经安装 yay 等 AUR helper, 可以在终端中运行 1yay -S linux-mainline-um5302ta 安装. 这一命令同时会打包并安装 linux-mainline-um5302ta 和 linux-mainline-um5302ta-headers 两个包. 需要注意的是, 编译内核需要一定的时间. 因为 um5302ta 这一仓库的存在, 该 AUR 包的作者已经停止维护, 但是理论上通过修改该包的 PKGBUILD 文件仍然可以在未来的内核版本中实现相同的效果. 其他系统包配合 um5302ta 仓库的 patch Linux 分支 Linux 版本 是否需要编译系统包 是否需要手动添加 patch 任意 &gt;= 6.0.9 是/否 是 按照 um5302ta 仓库提供的方案, 理论上绝大部分符合版本的 Linux 分支或基于前者的分支皆可以修复问题. 值得注意的是, dsdt/spkr-dsd.patch 无需编译完整的 Linux 源码包即可应用, 且一大优点是不会在更新内核的时候被覆盖, 因此对于如下不同需求的读者, 可以按照如下的参考路径解决问题, 并选读本节不同的子章节: 无需 S3 睡眠且不在意麦克风指示灯问题, 且不希望编译完整系统包: 安装 Arch Linux 官方提供的 linux, linux-zen 等系统包, 并阅读编译 CPIO archive子章节; 无需 S3 睡眠且不在意麦克风指示灯问题, 但需要自行安装其他系统包, 或需要解决前述的两个问题: 阅读编译安装系统包和编译 CPIO archive子章节, 并选择适当的 patch; 不希望改动 boot loader 行为: 阅读编译安装系统包子章节, 并选择适当的 patch. 应用适当的 patchArch Linux 官方提供的系统包或从这些包中分支出的 AUR 包可以自动应用 patch. 读者需要做的是将所需的 patch 放置在 PKGBUILD 文件 (会在后文提及) 的父目录中, 然后修改 PKGBUILD 文件的内容, 将 patch 的路径添加到其中的 source 变量中. 理论上仍然需要在 sha256sums 变量中添加对应 patch 的 SHA256, 但可以使用 'SKIP' 跳过校验. 例如, 若需要应用 kernel/cs35l42-hda-no-acpi-dsd-csc3551.patch 这个 patch, 则只需要直接将该 patch 下载到对应的文件夹: 123cd /path/to/package # 提前切换当前文件夹wget https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/patches/kernel/cs35l42-hda-no-acpi-dsd-csc3551.patch # 下载 patchvim PKGBUILD 然后作出类似如下的修改, 将 1234source=( &quot;$_srcname::git+https://github.com/archlinux/linux?signed#tag=$_srctag&quot; config # the main kernel config file) 改为 12345source=( &quot;$_srcname::git+https://github.com/archlinux/linux?signed#tag=$_srctag&quot; config # the main kernel config file kernel/cs35l42-hda-no-acpi-dsd-csc3551.patch) 然后将 12sha256sums=('SKIP' '0571ea17a2e38458096b679418197bbea8c414388f628d122517f3a1f3a31b3a') 改为 123sha256sums=('SKIP' '0571ea17a2e38458096b679418197bbea8c414388f628d122517f3a1f3a31b3a' 'SKIP') 添加多个 patch 的方法类似. 编译安装系统包Arch Linux 官方 fork 了 Linux 社区的源码库, 并提供了编译, 打包, 安装的 “脚本” (交由 pacman 执行, 并不完全等同于 Shell 脚本). 本文以 linux 系统包为例. 与 AUR 包不同, Arch Linux 官方维护的包存储于 GitHub 的 svntogit-packages 仓库, 但所有的软件包的相关数据存储于各个分支中, 故直接克隆该仓库会产生大量的无用数据. 笔者选择直接 pull 需要的分支: 123456mkdir linux &amp;&amp; cd linuxgit initgit remote add origin https://github.com/archlinux/svntogit-packages.gitgit pull origin packages/linuxgit branch -M packages/linux # 可选cd trunk 该文件夹的结构与 AUR 包相同, 可以看到其中存在 PKGBUILD 文件. 此时可以根据 “应用适当的 patch“ 章节的内容将 patch 的信息添加至 PKGBUILD 中. 随后, 在终端中执行 1makepkg -si 编译, 打包并安装. 这会产生 linux, linux-docs, linux-headers 三个包. 编译 CPIO archive重启应用新的内核后, 则需要应用 dsdt/spkr-dsd.patch. 对 DSDT 的介绍见此. 大部分情况下, 读者只需要从 “Recompiling it yourself“ 小节开始阅读. 首先需要安装 acpica 这个软件包. 然后在终端中执行 12345sudo sh -c &quot;cat /sys/firmware/acpi/tables/DSDT &gt; dsdt.dat&quot;iasl -d dsdt.datwget https://github.com/latin-1/um5302ta/blob/b40223a5f9dd394f886c1ada50b46813f31e8444/patches/dsdt/spkr-dsd.patchpatch -Np1 &lt; spkr-dsd.patchiasl -tc dsdt.dsl 此时可以在当前目录找到 dsdt.aml. 再拉取 Linux 的源码, 切换当前目录到源码文件夹, 在终端中执行 1234mkdir -p kernel/firmware/acpicp /path/to/dsdt.aml kernel/firmware/acpi # 将 /path/to/dsdt.aml 更换为正确的路径find kernel | cpio -H newc --create &gt; acpi_overridesudo cp acpi_override /boot acpi_override 是一个 CPIO archive 文件, 可以作为 initrd 被 boot loader 加载. 以 GRUB 为例, 修改 /etc/default/grub 文件, 在文件末尾添加: 12# Load custom acpi_overrideGRUB_EARLY_INITRD_LINUX_CUSTOM=&quot;acpi_override&quot; 此时这个 CPIO archive 则会在 initramfs 前加载. 使用 1sudo grub-mkconfig -o /boot/grub/grub.cfg 生成 grub 的配置文件. 可以检查该文件中是否已经写入 acpi_override, 例如: 1initrd /acpi_override /initramfs-linux.img 重启设备, 该 patch 即被应用. [完]","link":"/techdev/arch/um5302ta/"},{"title":"【Arch Linux】使用 Wine 运行 Galgame","text":"本文主要介绍在 Arch Linux 上通过 Wine 运行 Galgame 的主要步骤. 理论上对其他 Linux 发行版也可作类似操作. 需要注意的是, 以下教程很可能只对日文原版的 Galgame 有效. 考虑到中国大陆大量汉化 Galgame 存在”壳”, 标准的 Wine 配置可能无法应对, 需要据情况自行分析. Wine简介对 Wine 的简要介绍可参见维基百科和 Arch Linux Wiki 同名词条, 并非本文重点, 故不作赘述. 安装Wine 的开发和 Staging (包含一些修复和补丁等) 分支位于官方包仓库的 Multilib 仓库, Stable 分支位于 AUR. 以 Staging 分支为例: 1sudo pacman -S wine-staging 同时可能需要安装 32 位的图形和音频驱动, 分别参见 Arch Linux Wiki 的 Wine#Graphics drivers 和 Wine#Sound 章节. 配置使用 winecfg 进行 Wine 相关的配置. 一般情况下不需要做改动. 对于启动系统 UI 缩放的设备, 可以在 Graphics 选项卡下的 Screen resolution 设置项下等比例设置 DPI, 例如默认值为 96 时, 150% 缩放等级对应的 DPI 为 144. 测试1wine notepad 字体和 locale对于 Wine 来说如上的设置已经可以启动很多应用程序了, 但对于日本生产的 Galgame 来说, 默认简体中文或英文的系统环境极有可能造成”乱码”. 因此我们还需要作一些额外的设置. 日文字体一些教程^1给出的解决方案是从系统语言为日本语的 Windows 系统中复制 C:\\Windows\\Fonts 文件夹中的字体, 不过 AUR 已经有人整理过日本语字体包: 1yay -S ttf-ms-win11-auto-japanese 若出现字体安装失败的情况, 请参照此章节. Shift-JIS locale许多 Galgame 的开发 locale 使用的都是 Shift-JIS, 但其并不在大部分现代 Linux 发行版中内置. 需要另外安装. 参考此教程, 下载作者提供的 mega.nz 或 Google Drive 内的文件并按照要求解压后: 123sudo localedef -i ja_JP -f SHIFT_JIS ja_JP.sjis --no-warnings=asciisudo sed -i '/ja_JP.UTF-8 UTF-8/a ja_JP.SJIS SHIFT_JIS ' /etc/locale.gen# sudo locale-gen # 可能会失败, 但此时 locale 应已配置成功. 此时需要将上一行命令中新生成的一行数据删除或注释. 此时再在终端中切换目录到 Galgame 目录下, 执行: 1LC_ALL=ja_JP.sjis wine &lt;游戏可执行文件&gt;.exe 同时可以尝试 ja_JP.utf8. 在 /etc/locale.gen 中找到 #ja_JP.UTF-8 UTF-8 一行, 删除前面的注释符后执行 sudo locale-gen, 再: 1LC_ALL=ja_JP.utf8 wine &lt;游戏可执行文件&gt;.exe 参考","link":"/techdev/arch/wine-galgame/"},{"title":"【Python|RPG】Continuous Infinity制作实录 - EP.1 框架","text":"我们这次将开始利用Python制作一款简易的TRPG，名字在很久以前已经想好——《Continuous Infinity》，这个名字出自刚立项时的想法——最终实现自动生成无限多的关卡。 我们这次将开始利用Python制作一款简易的TRPG，名字在很久以前已经想好——《Continuous Infinity》，这个名字出自刚立项时的想法——最终实现自动生成无限多的关卡。 为了使本文简洁明了，这个系列就不废话了 (希望如此) 。 Part I. 规划从总体上看整个游戏流程，应该可以分成以下几步： 主页：进行游戏配置，选择进入或退出游戏； 主体：游戏主体部分，项目的核心； 接受玩家操作，产生效果； 检查是否达到退出条件； 程序作出操作，产生效果； 检查是否达到退出条件； 退出游戏或回到1.。 游戏的主要形式即是玩家操纵角色与其他角色 (程序控制的敌人) 进行对战，互相攻击对方，直至一方血量归零，触发事件，执行后续操作——玩家死亡结算、敌方给出新角色、进入下一关等。由此可以归纳出游戏时需要定义的“具体事物”有角色 (mob) 、物品 (item) (包括装备、道具) 、技能 (skill) 等，稍抽象一点的是关卡 (level) (需要定义每个关卡的敌方角色的各种信息) 。 Part II. 源码结构继而我们可以给出如下的源码结构作为参考： 1234567891011121314151617181920212223.│ run.py│├─game│ │ system.py│ ││ ├─data│ │ ├─items│ │ ├─levels│ │ ├─mobs│ │ └─skills│ ├─generator│ │ levels.py│ ││ ├─loader│ │ items.py│ │ levels.py│ │ mobs.py│ │ skills.py│ ││ └─locales└─test .keep 其中run.py是游戏启动的脚本；test文件夹存放单元测试的相关内容；game文件夹存放本游戏的主体内容，包括游戏的绝大多数逻辑、上文所说的具体事物的定义和设计等；game/data文件夹存放的即是所谓的“设计”；game/generator文件夹存放游戏的生成器，用以自定义一系列具体事物以及其自动生成算法；game/loader文件夹存放游戏的加载器，用以读取game/data定义的内容；game/locales文件夹存放游戏的多语言文件 (锦上添花而已，不重要) 。 Part III. 具体事物的信息存储和对战系统逻辑前文提到了对战系统的主要形式是回合制，而较为精细的逻辑则需要涉及到一些具体事物的“使用——生效”机制。当开始某个角色 (不论是玩家还是敌方角色) 的回合时，这个角色可以选择出招 (skill) ，也可以选择使用道具 (item) 增益己方或损害对方，亦可以临时装备一些物品 (item)，或是执行系统级操作——逃跑 (假设未来某天加入游戏中) 、投降 (同上) 、退出当前对局等。不过其中需要伤点脑子的是如何有效地存储一些具体事物的各种信息，以及如何让具体事物在对战时产生效果。 在早期的设计过程中，笔者写出了如下的代码来存储角色的信息： 123456789101112131415161718192021class Mob(object): # Player and enemy def __init__(self, type, name, lvl, exp, hp, pp, hpm, ppm, atk, dfd, spd, pack, coin, skill, weapon, helmet, chestplate, leggings, boots): self.type = type # 类型（职业） self.name = name # 名字 self.lvl = lvl # 等级 self.exp = exp # 经验值 self.hp = hp # 血量 self.pp = pp # 技能点 self.hpm = hpm # 血量上限 self.ppm = ppm # 技能点上限 self.atk = atk # 攻击力 self.dfd = dfd # 防御力 self.spd = spd # 迅捷度 self.pack = pack # 背包列表 self.coin = coin # 金钱 self.skill = skill # 技能列表 self.weapon = weapon # 武器 self.helmet = helmet # 头盔 self.chestplate = chestplate # 胸甲 self.leggings = leggings # 腿甲 self.boots = boots # 靴子 原来的代码中其实连中文注释都没有。但即便按照PEP 8进行格式化，加上了详细的注释，又添上了“docstring”，这段代码依然冗长，而且在定义一个角色的时候需要在参数中加上大量的None，十分不便。这是笔者联想到requests模块的get函数，get函数支持添加许多参数，但模块作者采用了一个较为聪明的方法： 1234567891011In [2]: requests.get?Signature: requests.get(url, params=None, **kwargs)Docstring:Sends a GET request.:param url: URL for the new :class:`Request` object.:param params: (optional) Dictionary, list of tuples or bytes to send in the body of the :class:`Request`.:param \\*\\*kwargs: Optional arguments that ``request`` takes.:return: :class:`Response &lt;Response&gt;` object:rtype: requests.Response 因而我们也可以让定义者显式地传入一个角色的个性化参数，如果没有给出就保持默认值，这样可以极好地便利游戏数据设计者。同时这样的设计可以在形式上将一个角色的所有信息平权，作为“字典型”参数传入时，没有明显的次序之分，总体上是优雅和谐的。 而对于产生效果的方法，一个问题是如何选择目标角色。一项技能和一个物品发挥作用，其目标可以是使用者自身，也可以是己方或对方所有角色，甚至是让使用者自选角色乃至随机角色。为了适应多种需求，我们可以借鉴游戏《Minecraft》上“目标选择器”的机制——利用简单的语法形成的字符串来选择目标。而第二个问题是施加效果，如果便利游戏数据设计者，可以封死自定义复杂函数的通道，只提供一个简单的列表保证一些必要数据 (譬如血量、技能点、装备、物品数量) 的增减；而如果提供充分的自由度，我们可以允许游戏数据设计者向loader提供一个含有指定接口的函数，loader只需利用提供的接口执行更复杂的操作即可。如果为了“双赢”，可以同时实现这两种方式，当然这样的话最累的就是游戏设计者 (其实就是笔者) 。 【完】","link":"/techdev/continuous-infinity/ep-1/"},{"title":"【Python|RPG】Continuous Infinity制作实录 - EP.2 游戏大厅界面","text":"这一期我们准备建设比较粗犷的部分——游戏大厅界面，这部分的代码对应源代码中 run.py 的部分。 这一期我们准备建设比较粗犷的部分——游戏大厅界面，这部分的代码对应源代码中 run.py 的部分。为了不让以前的代 (shi) 码 (shan) 影响我们的思路，现在笔者将旧的代码全部删去。 照例先起个头，装作“万事开头难”的“开头”已经结束了 (自欺欺人+1) ： src/run.py12345678910# -*- coding: utf-8 -*-&quot;&quot;&quot; Project: Continuous Infinity File: src/run.py Author: Little_Ye233 Created: 2021-07-05 Description: Main run shell.&quot;&quot;&quot; Part I. 欢迎界面除去初始化的等待界面，玩家游玩游戏见到的第一个界面多半就是游戏大厅界面了，这也很大程度上决定了玩家的第一印象。不过我们这里只是简单的制作一个可以称得上 TRPG 的东西，所以也没必要搞那么多花里胡哨的，直接上一个简朴的界面： src/game/system/scenes/lobby.py12345678910111213141516171819# -*- coding: utf-8 -*-&quot;&quot;&quot; Project: Continuous Infinity File: src/game/system/scenes/lobby.py Author: Little_Ye233 Created: 2021-07-05 Description: Game algorithms of lobby scene.&quot;&quot;&quot;from ..constants import *class Lobby(object): @staticmethod def show(): print(SYSTEM_SCENES_LOBBY_WELCOME) src/game/system/constants.py123456789101112131415161718192021# -*- coding: utf-8 -*-&quot;&quot;&quot; Project: Continuous Infinity File: src/game/system/constants.py Author: Little_Ye233 Created: 2021-07-05 Description: Definitions of game constants.&quot;&quot;&quot;# Systemversion = '0.1.0' # Literal stringsSYSTEM_SCENES_LOBBY_WELCOME = f'''\\-*-*- Continuous Infinity -*-*--*- Ver {version} -*--*- Author: Little_Ye233 -*-''' 嗯嗯嗯？！为什么多了个 lobby.py 和 constants.py ？还有原来的 system.py 为什么变成了一个同名的文件夹？ 其实这个是笔者先前开发项目时的常有情况——每每做出了一定的规划，最后总会在某个地方需要修改原先的架构。这里也是模仿当时的情况做出的——在实际情况下考虑到单个文件 system.py 放置所有的逻辑可能会导致文件过于冗杂，故分离出多个子文件 (夹) 。其实这里我还埋伏了一手，就是 constants.py 。我们看到这里定义常量的时候我的命名方式是“源文件名 (下划线作文件路径分隔符) +其他标识符”，这也是一种冗长的写法，但笔者先暂时这么写，如果后期发现其他方式命名起来更容易，就尝试进一步修改。 先看这里的 src/game/system/constants.py 定义的内容。第一段 System 下定义的是版本号，变量名定义采用了许多著名模块中的 version (这里注意到变量名称是全部小写) 模块级变量定义方式，其中的字符串遵循“Semantic Versioning” (语义化版本) 中的规定。第二段下定义了一个游戏大厅的欢迎界面，注意到这里利用了 Python 3.6 下引入的字符串格式化输出方式“f-string”。 Part II. 选项有了欢迎界面自然也要有选择的部分。选项的设计可以有简单的两种：第一种是给出所有可选项并标号，玩家自行输入标号；第二种是给出所有可选项，玩家通过方向键控制高亮选项。当然这两种也可以继续细分，实现选项的方式也不止这两种，甚至可以几种方式结合。我们这里为了简便，就采用第一种方式——不过看起来可能比较复杂就是了： src/game/system/scenes/lobby.py1234567891011121314from ..widgets import Optionsclass Lobby: @staticmethod def show(): print(LOBBY_WELCOME) cmd = Options(0, [ START_GAME, SELECT_LEVEL, SETTINGS, CREDITS, EXIT_GAME ]).show() 这是 src/game/system/scenes/lobby.py 的一部分定义。明显发现原来很长的常量名变成了直接表义的名字 LOBBY_WELCOME ，一方面是因为实在太长打起来很累 (终于悔改了) ，另一方面是因为使用只表义但不包含文件路径信息的记法便于在不同位置使用相同的字符串 (比如可能很多地方都会用到“开始游戏”之内的字符串) 。而这里我们又引入了一个新的概念 (坑) ——组件 (Widget) ，以将游戏设计中出现的各种小程序片段统一化。这里我们构造出了第一种组件——选项 (Options) ，来为玩家提供一个简单的选择系统。对于实现的细节我们先按下不表，只需能大致了解它实现出的效果即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374In [1]: from src.game.system.widgets import OptionsIn [2]: cmd = Options('0', ['Option 1', 'Option 2', 'Option 3']).show()---------------------------------------------------------------------------ValueError Traceback (most recent call last)&lt;ipython-input-2-6f1c48425fd6&gt; in &lt;module&gt;----&gt; 1 cmd = Options('0', ['Option 1', 'Option 2', 'Option 3']).show()~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/main.py in __init__(self, style, *params) 38 # CAUTIONS: now `style` can be 0 only 39 if style not in self._avail_style:---&gt; 40 raise ValueError(f'style ID {style} is unavailable') 41 42 self.style = styleValueError: style ID 0 is unavailableIn [3]: cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()Choices:(1) Option 1(2) Option 2(3) Option 3Please choose: a---------------------------------------------------------------------------ValueError Traceback (most recent call last)&lt;ipython-input-3-c0fc1f068dc0&gt; in &lt;module&gt;----&gt; 1 cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/main.py in show(self) 51 'src.game.system.widgets.options.styles' 52 )---&gt; 53 return style.Style.show(*self.params)~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/styles/style0.py in show(*params) 22 s = input('Please choose: ') 23 if not s.isdigit() or int(s) == 0 or int(s) &gt; len(choices):---&gt; 24 raise ValueError(f'invalid input value: {s}') 25 return int(s)ValueError: invalid input value: aIn [4]: cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()Choices:(1) Option 1(2) Option 2(3) Option 3Please choose: 0---------------------------------------------------------------------------ValueError Traceback (most recent call last)&lt;ipython-input-4-c0fc1f068dc0&gt; in &lt;module&gt;----&gt; 1 cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/main.py in show(self) 51 'src.game.system.widgets.options.styles' 52 )---&gt; 53 return style.Style.show(*self.params)~/Documents/code/Python/rpg/ContinuousInfinity/src/game/system/widgets/options/styles/style0.py in show(*params) 22 s = input('Please choose: ') 23 if not s.isdigit() or int(s) == 0 or int(s) &gt; len(choices):---&gt; 24 raise ValueError(f'invalid input value: {s}') 25 return int(s)ValueError: invalid input value: 0In [5]: cmd = Options(0, ['Option 1', 'Option 2', 'Option 3']).show()Choices:(1) Option 1(2) Option 2(3) Option 3Please choose: 1In [6]: cmdOut[6]: 1 这里我们可以看到， Options 类能够根据给定参数产生一个实例，而这个实例的 show 方法则能在默认输出设备——也就是终端 (terminal) ——其实这里我预感没有加上 IO 设备的参数后期会出麻烦，但现在暂时先这么写着。然后如果交互过程没有异常的话，这个方法会将玩家选择的选项的编号 (在当前的 style 中，必定为一个正整数) 作为返回值。依此我们可以编写出如下的游戏大厅页面场景 (scene) 代码： src/game/system/scenes/lobby.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546from ..constants import *from ..widgets import Optionsdef start_game(): print('start_game: Not implemented yet!')def select_level(): print('select_level: Not implemented yet!')def settings(): print('settings: Not implemented yet!')def show_credits(): print(CREDITS_MSG)def exit_game(): print(LOBBY_EXIT) exit(0)actions = [None, start_game, select_level, settings, show_credits, exit_game]class Lobby: @staticmethod def show(): print(LOBBY_WELCOME) while True: try: cmd = Options(0, [ START_GAME, SELECT_LEVEL, SETTINGS, CREDITS, EXIT_GAME ]).show() except ValueError: # wrong `cmd` print() print(WRONG_CMD) else: print() actions[cmd]() print() 一些常量的定义暂时忽略。最终能得到如下的测试结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ python src/run.py-*-*- Continuous Infinity -*-*--*- Ver 0.1.0 -*--*- Author: Little_Ye233 -*-Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 0Got a wrong choice. Please try again.Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 1start_game: Not implemented yet!Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 2select_level: Not implemented yet!Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 3settings: Not implemented yet!Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 4-*-*- Credits -*-*-Author: Little_Ye233Choices:(1) Start Game(2) Select a Level(3) Settings(4) Credits(5) Exit GamePlease choose: 5Goodbye! 【完】","link":"/techdev/continuous-infinity/ep-2/"},{"title":"【文件格式探究】EP.1 对ePub文件格式的初探","text":"这是“文件格式探究”专题的第 1 期——初探 “ePub” 文件格式。 这是“文件格式探究”专题的第 1 期——初探 “ePub” 文件格式。这个专题将会给各位读者呈现笔者探索各种文件格式的过程，具体则是文件的内容是如何呈现出来的。原则上我们假定仅对于这些文件格式的用途有所了解，但具体实现的细节并不清楚 (如果提前掌握了部分内容，笔者全当其不存在) 。探究过程中我们会尝试使用各种方法来逐渐初步掌握其概貌。 文件格式简介根据维基百科大陆简体版本的相关描述： EPub 是一个自由的开放标准，属于一种可以“自动重新排版”的内容；也就是文字内容可以根据阅读设备的特性，以最适于阅读的方式显示。 之所以后面不截是因为再截就剧透了。简单来说，ePub 就是类似于 PDF 那样的“文档型”文件格式，常用于分发电子读物等。 探究过程环境现在笔者手头上有一份用于测试的 ePub 文件，文件路径为 ~/Downloads/咖啡馆推理事件簿系列（全四本）.epub (趁机夹带私货，反正很合我胃口就是了) ，后续所有的探究活动均建立于此文件上。笔者目前的操作系统环境为 Manjaro 21.1.0 on amd64，终端环境为 GNU bash 5.1.8(1)-release 。为了方便，我们先把文件改个名字 (那你还把原来的名字给出来干嘛？！) ： 12345[littleye233@lymjrolt Downloads]$ cd ~[littleye233@lymjrolt ~]$ cd Downloads[littleye233@lymjrolt Downloads]$ mv 咖啡馆推理事件簿系列（全四本）.epub test.epub[littleye233@lymjrolt Downloads]$ ll test.epub-rw-r--r-- 1 littleye233 littleye233 1253964 Aug 22 23:24 test.epub Round I. 文件类型首先我们先尝试用 Linux 系统的内置命令 file 试试水，看看会输出什么东西。键入 file test.epub后执行： 12[littleye233@lymjrolt Downloads]$ file test.epubtest.epub: EPUB document EPUB document 哎呀，真可惜！ file 命令几乎什么有效信息都没给我们。 file 命令的 man 页面明确给出此命令可以判断文件格式，但其实它能做到的有很多，例如如果对一个图片文件使用 file ，可能会出现类似下面的结果： 12[littleye233@lymjrolt Downloads]$ file ~/.local/share/osu/screenshots/osu_2021-08-21_23-40-03.png/home/littleye233/.local/share/osu/screenshots/osu_2021-08-21_23-40-03.png: PNG image data, 1920 x 961, 8-bit/color RGBA, non-interlaced 这样我们可以通过 file 中提供的相关信息顺藤摸瓜，尝试在文件的二进制编码内容中寻找其蛛丝马迹，进而推测对应“位点”所表达的含义 (因为一些文件格式要求在特定的位置表达某些含义) ，如果能提供类似注释的信息就再好不过了。 Round II. 文件结构现在我们回到这个 ePub 文件上来。现在我们尝试能否直接获取其内容，目的是通过文件头部的部分可见字符猜测其文件结构。输入 nano test.epub 直接预览，或使用 head --bytes=120 test.epub 查看前面 120 个字节的内容： 123[littleye233@lymjrolt Downloads]$ head --bytes=120 test.epubPK!oa�mimetypeapplication/epub+zipPU�N�;�ʯ�META-INF/container.xml]�A�0E�= 果不其然，我们看到了一些有趣的字眼： “mimetypeapplication/epub+zip” ，凭经验猜测，这应该是 ePub 文件格式的文件头，而其中的 “zip” 也说明—— ePub 文件可能本质上就是一个压缩档。 其实很多文件格式 (例如 Word 文档 “*.docx”) 其本质都是在一个压缩档中加入各种资源文件和配置文件，只要有对应的软件进行读取并重新加工，用户即能看到效果。 Round III. 目录树结构现在我们可以使用解压缩程序解出 ePub 文件中的内容了。在终端中执行 unzip -l test.epub ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778[littleye233@lymjrolt Downloads]$ unzip -l test.epubArchive: test.epub Length Date Time Name--------- ---------- ----- ---- 20 1980-01-01 00:00 mimetype 251 2019-06-27 10:40 META-INF/container.xml 12307 2019-06-27 10:40 OEBPS/content.opf 112368 2019-06-27 10:40 OEBPS/Images/cover00464.jpeg 128680 2019-06-27 10:40 OEBPS/Images/image00456.jpeg 120936 2019-06-27 10:40 OEBPS/Images/image00457.jpeg 1392 2019-06-27 10:40 OEBPS/Images/image00458.jpeg 101948 2019-06-27 10:40 OEBPS/Images/image00459.jpeg 119124 2019-06-27 10:40 OEBPS/Images/image00460.jpeg 1268 2019-06-27 10:40 OEBPS/Images/image00461.jpeg 42944 2019-06-27 10:40 OEBPS/Images/image00462.jpeg 121284 2019-06-27 10:40 OEBPS/Images/image00463.jpeg 2251 2019-06-27 10:40 OEBPS/Styles/style0001.css 9816 2019-06-27 10:40 OEBPS/Styles/style0002.css 2251 2019-06-27 10:40 OEBPS/Styles/style0003.css 9789 2019-06-27 10:40 OEBPS/Styles/style0004.css 2251 2019-06-27 10:40 OEBPS/Styles/style0005.css 29245 2019-06-27 10:40 OEBPS/Styles/style0006.css 2235 2019-06-27 10:40 OEBPS/Styles/style0007.css 29914 2019-06-27 10:40 OEBPS/Styles/style0008.css 2251 2019-06-27 10:40 OEBPS/Styles/style0009.css 624 2019-06-27 10:40 OEBPS/Text/cover_page.xhtml 851 2019-06-27 10:40 OEBPS/Text/part0000.xhtml 561 2019-06-27 10:40 OEBPS/Text/part0001.xhtml 428 2019-06-27 10:40 OEBPS/Text/part0002.xhtml 1518 2019-06-27 10:40 OEBPS/Text/part0003.xhtml 661 2019-06-27 10:40 OEBPS/Text/part0004.xhtml 2311 2019-06-27 10:40 OEBPS/Text/part0005.xhtml 55157 2019-06-27 10:40 OEBPS/Text/part0006.xhtml 58266 2019-06-27 10:40 OEBPS/Text/part0007.xhtml 59953 2019-06-27 10:40 OEBPS/Text/part0008.xhtml 49789 2019-06-27 10:40 OEBPS/Text/part0009.xhtml 66870 2019-06-27 10:40 OEBPS/Text/part0010.xhtml 57342 2019-06-27 10:40 OEBPS/Text/part0011.xhtml 67449 2019-06-27 10:40 OEBPS/Text/part0012.xhtml 16183 2019-06-27 10:40 OEBPS/Text/part0013.xhtml 561 2019-06-27 10:40 OEBPS/Text/part0014.xhtml 428 2019-06-27 10:40 OEBPS/Text/part0015.xhtml 1575 2019-06-27 10:40 OEBPS/Text/part0016.xhtml 496 2019-06-27 10:40 OEBPS/Text/part0017.xhtml 1446 2019-06-27 10:40 OEBPS/Text/part0018.xhtml 52358 2019-06-27 10:40 OEBPS/Text/part0019.xhtml 75746 2019-06-27 10:40 OEBPS/Text/part0020.xhtml 63420 2019-06-27 10:40 OEBPS/Text/part0021.xhtml 57399 2019-06-27 10:40 OEBPS/Text/part0022.xhtml 58590 2019-06-27 10:40 OEBPS/Text/part0023.xhtml 40263 2019-06-27 10:40 OEBPS/Text/part0024.xhtml 66099 2019-06-27 10:40 OEBPS/Text/part0025.xhtml 15143 2019-06-27 10:40 OEBPS/Text/part0026.xhtml 561 2019-06-27 10:40 OEBPS/Text/part0027.xhtml 612 2019-06-27 10:40 OEBPS/Text/part0028.xhtml 1344 2019-06-27 10:40 OEBPS/Text/part0029.xhtml 640 2019-06-27 10:40 OEBPS/Text/part0030.xhtml 6144 2019-06-27 10:40 OEBPS/Text/part0031.xhtml 25197 2019-06-27 10:40 OEBPS/Text/part0032.xhtml 54594 2019-06-27 10:40 OEBPS/Text/part0033.xhtml 87394 2019-06-27 10:40 OEBPS/Text/part0034.xhtml 97557 2019-06-27 10:40 OEBPS/Text/part0035.xhtml 109901 2019-06-27 10:40 OEBPS/Text/part0036.xhtml 17181 2019-06-27 10:40 OEBPS/Text/part0037.xhtml 5238 2019-06-27 10:40 OEBPS/Text/part0038.xhtml 561 2019-06-27 10:40 OEBPS/Text/part0039.xhtml 644 2019-06-27 10:40 OEBPS/Text/part0040.xhtml 1163 2019-06-27 10:40 OEBPS/Text/part0041.xhtml 1473 2019-06-27 10:40 OEBPS/Text/part0042.xhtml 38427 2019-06-27 10:40 OEBPS/Text/part0043.xhtml 90589 2019-06-27 10:40 OEBPS/Text/part0044.xhtml 51278 2019-06-27 10:40 OEBPS/Text/part0045.xhtml 58321 2019-06-27 10:40 OEBPS/Text/part0046.xhtml 29670 2019-06-27 10:40 OEBPS/Text/part0047.xhtml 12903 2019-06-27 10:40 OEBPS/Text/part0048.xhtml 7364 2019-06-27 10:40 OEBPS/toc.ncx--------- ------- 2422768 72 files 同时可以直接解压： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374[littleye233@lymjrolt Downloads]$ unzip test.epub -d test_epubArchive: test.epub extracting: test_epub/mimetype inflating: test_epub/META-INF/container.xml inflating: test_epub/OEBPS/content.opf inflating: test_epub/OEBPS/Images/cover00464.jpeg inflating: test_epub/OEBPS/Images/image00456.jpeg inflating: test_epub/OEBPS/Images/image00457.jpeg inflating: test_epub/OEBPS/Images/image00458.jpeg inflating: test_epub/OEBPS/Images/image00459.jpeg inflating: test_epub/OEBPS/Images/image00460.jpeg inflating: test_epub/OEBPS/Images/image00461.jpeg inflating: test_epub/OEBPS/Images/image00462.jpeg inflating: test_epub/OEBPS/Images/image00463.jpeg inflating: test_epub/OEBPS/Styles/style0001.css inflating: test_epub/OEBPS/Styles/style0002.css inflating: test_epub/OEBPS/Styles/style0003.css inflating: test_epub/OEBPS/Styles/style0004.css inflating: test_epub/OEBPS/Styles/style0005.css inflating: test_epub/OEBPS/Styles/style0006.css inflating: test_epub/OEBPS/Styles/style0007.css inflating: test_epub/OEBPS/Styles/style0008.css inflating: test_epub/OEBPS/Styles/style0009.css inflating: test_epub/OEBPS/Text/cover_page.xhtml inflating: test_epub/OEBPS/Text/part0000.xhtml inflating: test_epub/OEBPS/Text/part0001.xhtml inflating: test_epub/OEBPS/Text/part0002.xhtml inflating: test_epub/OEBPS/Text/part0003.xhtml inflating: test_epub/OEBPS/Text/part0004.xhtml inflating: test_epub/OEBPS/Text/part0005.xhtml inflating: test_epub/OEBPS/Text/part0006.xhtml inflating: test_epub/OEBPS/Text/part0007.xhtml inflating: test_epub/OEBPS/Text/part0008.xhtml inflating: test_epub/OEBPS/Text/part0009.xhtml inflating: test_epub/OEBPS/Text/part0010.xhtml inflating: test_epub/OEBPS/Text/part0011.xhtml inflating: test_epub/OEBPS/Text/part0012.xhtml inflating: test_epub/OEBPS/Text/part0013.xhtml inflating: test_epub/OEBPS/Text/part0014.xhtml inflating: test_epub/OEBPS/Text/part0015.xhtml inflating: test_epub/OEBPS/Text/part0016.xhtml inflating: test_epub/OEBPS/Text/part0017.xhtml inflating: test_epub/OEBPS/Text/part0018.xhtml inflating: test_epub/OEBPS/Text/part0019.xhtml inflating: test_epub/OEBPS/Text/part0020.xhtml inflating: test_epub/OEBPS/Text/part0021.xhtml inflating: test_epub/OEBPS/Text/part0022.xhtml inflating: test_epub/OEBPS/Text/part0023.xhtml inflating: test_epub/OEBPS/Text/part0024.xhtml inflating: test_epub/OEBPS/Text/part0025.xhtml inflating: test_epub/OEBPS/Text/part0026.xhtml inflating: test_epub/OEBPS/Text/part0027.xhtml inflating: test_epub/OEBPS/Text/part0028.xhtml inflating: test_epub/OEBPS/Text/part0029.xhtml inflating: test_epub/OEBPS/Text/part0030.xhtml inflating: test_epub/OEBPS/Text/part0031.xhtml inflating: test_epub/OEBPS/Text/part0032.xhtml inflating: test_epub/OEBPS/Text/part0033.xhtml inflating: test_epub/OEBPS/Text/part0034.xhtml inflating: test_epub/OEBPS/Text/part0035.xhtml inflating: test_epub/OEBPS/Text/part0036.xhtml inflating: test_epub/OEBPS/Text/part0037.xhtml inflating: test_epub/OEBPS/Text/part0038.xhtml inflating: test_epub/OEBPS/Text/part0039.xhtml inflating: test_epub/OEBPS/Text/part0040.xhtml inflating: test_epub/OEBPS/Text/part0041.xhtml inflating: test_epub/OEBPS/Text/part0042.xhtml inflating: test_epub/OEBPS/Text/part0043.xhtml inflating: test_epub/OEBPS/Text/part0044.xhtml inflating: test_epub/OEBPS/Text/part0045.xhtml inflating: test_epub/OEBPS/Text/part0046.xhtml inflating: test_epub/OEBPS/Text/part0047.xhtml inflating: test_epub/OEBPS/Text/part0048.xhtml inflating: test_epub/OEBPS/toc.ncx 为了更清楚地显示文件树结构，我们也可以使用 tree 命令 (这个命令在 Windows 中是内置的，在 Linux 中需要安装 tree 这个包，使用软件包管理器或编译安装均可) ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081[littleye233@lymjrolt test_epub]$ tree.├── META-INF│ └── container.xml├── mimetype└── OEBPS ├── content.opf ├── Images │ ├── cover00464.jpeg │ ├── image00456.jpeg │ ├── image00457.jpeg │ ├── image00458.jpeg │ ├── image00459.jpeg │ ├── image00460.jpeg │ ├── image00461.jpeg │ ├── image00462.jpeg │ └── image00463.jpeg ├── Styles │ ├── style0001.css │ ├── style0002.css │ ├── style0003.css │ ├── style0004.css │ ├── style0005.css │ ├── style0006.css │ ├── style0007.css │ ├── style0008.css │ └── style0009.css ├── Text │ ├── cover_page.xhtml │ ├── part0000.xhtml │ ├── part0001.xhtml │ ├── part0002.xhtml │ ├── part0003.xhtml │ ├── part0004.xhtml │ ├── part0005.xhtml │ ├── part0006.xhtml │ ├── part0007.xhtml │ ├── part0008.xhtml │ ├── part0009.xhtml │ ├── part0010.xhtml │ ├── part0011.xhtml │ ├── part0012.xhtml │ ├── part0013.xhtml │ ├── part0014.xhtml │ ├── part0015.xhtml │ ├── part0016.xhtml │ ├── part0017.xhtml │ ├── part0018.xhtml │ ├── part0019.xhtml │ ├── part0020.xhtml │ ├── part0021.xhtml │ ├── part0022.xhtml │ ├── part0023.xhtml │ ├── part0024.xhtml │ ├── part0025.xhtml │ ├── part0026.xhtml │ ├── part0027.xhtml │ ├── part0028.xhtml │ ├── part0029.xhtml │ ├── part0030.xhtml │ ├── part0031.xhtml │ ├── part0032.xhtml │ ├── part0033.xhtml │ ├── part0034.xhtml │ ├── part0035.xhtml │ ├── part0036.xhtml │ ├── part0037.xhtml │ ├── part0038.xhtml │ ├── part0039.xhtml │ ├── part0040.xhtml │ ├── part0041.xhtml │ ├── part0042.xhtml │ ├── part0043.xhtml │ ├── part0044.xhtml │ ├── part0045.xhtml │ ├── part0046.xhtml │ ├── part0047.xhtml │ └── part0048.xhtml └── toc.ncx5 directories, 72 files Round IV. 内部文件到这里我们大概就能猜出来： META-INF 文件夹：里面存放的应该是“容器” (也就是这个 ePub 文件) 的相关配置文件； mimetype 文件：里面定义了这个文件的类型为 “ePub” (其中 “MIME” 是 “Multipurpose Internet Mail Extensions” 的缩写，从字面上也能看出其具有指示 “Extension” 的机能) ； OEBPS 文件夹：虽暂不知其确切含义，但应存放 ePub 的文字、图片以及其他的界面数据； content.opf 文件：里面存放的应该是目录信息——或是定义各种文件的“次序”； Images Styles 和 Text 文件夹：明显分别存放图片、层叠样式表和文字数据； toc.ncx 文件：可能是真正的目录 (“toc” 是 “table of contents” 的缩写)。 接下来我们将挨个分析。 Round IV.I. 容器先看 META-INF/container.xml ： 12[littleye233@lymjrolt test_epub]$ file META-INF/container.xmlMETA-INF/container.xml: XML 1.0 document, ASCII text 输出其内容： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&gt; &lt;rootfiles&gt;&lt;rootfile full-path=&quot;OEBPS/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&gt; &lt;/rootfiles&gt;&lt;/container&gt; 显然是一个标准的 XML 文件，其中我们可以注意到 /container/rootfiles/rootfile[@class='full-path'][^1] 中定义了一个我们之前认定的目录文件，但此处可以规范化，故这个文件在大多数 ePub 档中应该是相同的。 Round IV.II. 文件类型定性接下来看 mimetype 文件： 12[littleye233@lymjrolt test_epub]$ cat mimetypeapplication/epub+zip 这也是相当显然的，也不再赘述。 Round IV.III. 目录？再看 OEBPS/content.opf ： 12[littleye233@lymjrolt test_epub]$ file OEBPS/content.opfOEBPS/content.opf: XML 1.0 document, Unicode text, UTF-8 text, with very long lines (504) 这也是一个 XML 文件，令人惊讶的是 file 命令竟能看出这个文件中最长的行有 504 个字符，属实让人害怕。 点此查看 `OEBPS/content.opf` 的全部内容 (已经过格式化) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;package xmlns=&quot;http://www.idpf.org/2007/opf&quot; version=&quot;2.0&quot; unique-identifier=&quot;uid&quot;&gt; &lt;metadata xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:opf=&quot;http://www.idpf.org/2007/opf&quot;&gt; &lt;dc:title opf:file-as=&quot;kafeiguantuilishijianbuxilie（quansiben）&quot;&gt;咖啡馆推理事件簿系列（全四本）&lt;/dc:title&gt; &lt;dc:language&gt;zh&lt;/dc:language&gt; &lt;dc:identifier id=&quot;uid&quot;&gt;3899198450&lt;/dc:identifier&gt; &lt;dc:creator opf:file-as=&quot;（ri）gangqizuomo&quot;&gt;（日）冈崎琢磨&lt;/dc:creator&gt; &lt;dc:date opf:event=&quot;publication&quot;&gt;2018-03-15&lt;/dc:date&gt; &lt;!-- Extra MetaData from RESC&lt;dc:coverage/&gt;--&gt; &lt;meta name=&quot;cover&quot; content=&quot;x_cover-image&quot;/&gt; &lt;meta name=&quot;output encoding&quot; content=&quot;utf-8&quot;/&gt; &lt;meta name=&quot;primary-writing-mode&quot; content=&quot;horizontal-lr&quot;/&gt; &lt;!-- BEGIN INFORMATION ONLY&lt;meta name=&quot;Cover ThumbNail Image&quot; content=&quot;Images/image00466.jpeg&quot; /&gt;&lt;meta name=&quot;Drm Ebookbase Book Id&quot; content=&quot;0006008690412&quot; /&gt;&lt;meta name=&quot;ASIN&quot; content=&quot;B07BFTVX98&quot; /&gt;&lt;meta name=&quot;Creator-Software&quot; content=&quot;201&quot; /&gt;&lt;meta name=&quot;Author-Pronunciation&quot; content=&quot;（ri）gangqizuomo&quot; /&gt;&lt;meta name=&quot;Embedded-Record-Count&quot; content=&quot;11&quot; /&gt;&lt;meta name=&quot;Unknown_(403)_(hex)&quot; content=&quot;00&quot; /&gt;&lt;meta name=&quot;HasFakeCover&quot; content=&quot;0&quot; /&gt;&lt;meta name=&quot;Creator-Major-Version&quot; content=&quot;2&quot; /&gt;&lt;meta name=&quot;cdeType&quot; content=&quot;EBOK&quot; /&gt;&lt;meta name=&quot;override-kindle-fonts&quot; content=&quot;false&quot; /&gt;&lt;meta name=&quot;CDEContentKey&quot; content=&quot;B07BFTVX98&quot; /&gt;&lt;meta name=&quot;Compression-Upgraded&quot; content=&quot;Source-Target:c1-c2 KT_Version:2.9 Build:0805-4a0c57c&quot; /&gt;&lt;meta name=&quot;HD-Media-Containers-Info&quot; content=&quot;2400x3840:0-11|&quot; /&gt;&lt;meta name=&quot;548 (hex)&quot; content=&quot;496e4d656d6f7279&quot; /&gt;&lt;meta name=&quot;Unknown_(407)_(hex)&quot; content=&quot;0000000000000000&quot; /&gt;&lt;meta name=&quot;Amazon_Creator_Info&quot; content=&quot;kjw&quot; /&gt;&lt;meta name=&quot;Clipping-Limit&quot; content=&quot;100&quot; /&gt;&lt;meta name=&quot;Tamper-Proof-Keys_(hex)&quot; content=&quot;01000000d000000001940000000191000000019500000001960000000197&quot; /&gt;&lt;meta name=&quot;Title-Pronunciation&quot; content=&quot;kafeiguantuilishijianbuxilie（quansiben）&quot; /&gt;&lt;meta name=&quot;Creator-Minor-Version&quot; content=&quot;9&quot; /&gt;&lt;meta name=&quot;MetadataResourceURI&quot; content=&quot;kindle:embed:000A&quot; /&gt;&lt;meta name=&quot;Updated_Title&quot; content=&quot;咖啡馆推理事件簿系列（全四本）&quot; /&gt;&lt;meta name=&quot;Ownership-Type_(hex)&quot; content=&quot;00&quot; /&gt;&lt;meta name=&quot;547 (hex)&quot; content=&quot;496e4d656d6f7279&quot; /&gt;&lt;meta name=&quot;Content-Language-Tag&quot; content=&quot;zh&quot; /&gt;&lt;meta name=&quot;sample&quot; content=&quot;0&quot; /&gt;&lt;meta name=&quot;Metadata-Record-Offset&quot; content=&quot;4294967295&quot; /&gt;&lt;meta name=&quot;Creator-Build-Tag&quot; content=&quot;0721-dedaf5&quot; /&gt;&lt;meta name=&quot;Publisher-Pronunciation&quot; content=&quot;xiandaichubanshe&quot; /&gt;&lt;meta name=&quot;StartOffset&quot; content=&quot;4294967295&quot; /&gt;&lt;meta name=&quot;Watermark_(hex)&quot; content=&quot;6174763a6b696e3a323a49396e41307a4239625565766a514961583462736b66476a394535335a51616a696368585638364447746b65544379504d504c4d75445a35524f39676b584d35515a6433694f424b5531546643766f5a62507763705a6b49486f6f366a6639785944327a4158494263536c495879676b6a38616b566e4763327a2b2b50434c454c464b2b4e30495a4556437a6331516f656f4451546b3865374a6f61696251526d6f682b7574586b3661466a554477704a3165636c68665367414a35664745413a68614f61636b496839662b61786c457733397665774b32554a57453d&quot; /&gt;&lt;meta name=&quot;Text-to-Speech-Disabled&quot; content=&quot;0&quot; /&gt;&lt;meta name=&quot;Font-Signature_(hex)&quot; content=&quot;0300000000480f08100000000000008000200000000000000000000000000000bef4edec01b701d7409440984099409c409d40a64a804c9c608160826080608b60e8618b60cd60c661aa61f361d661e9629c73df0213c9021fd90173cd01429f037e9a037e8c037e81037e9f&quot; /&gt;&lt;meta name=&quot;Rental-Expiration-Time&quot; content=&quot;0000000000000000&quot; /&gt;&lt;meta name=&quot;Container_Id&quot; content=&quot;ZkM0&quot; /&gt;&lt;meta name=&quot;Mobi8-Boundary-Section&quot; content=&quot;420&quot; /&gt;&lt;meta name=&quot;Creator-Build-Number&quot; content=&quot;0&quot; /&gt;END INFORMATION ONLY --&gt; &lt;/metadata&gt; &lt;manifest&gt; &lt;item id=&quot;x_cover&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/cover_page.xhtml&quot;/&gt; &lt;item id=&quot;x_TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0000.xhtml&quot;/&gt; &lt;item id=&quot;x_a1cover.html&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0001.xhtml&quot;/&gt; &lt;item id=&quot;x_a1bookname&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0002.xhtml&quot;/&gt; &lt;item id=&quot;x_a1TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0003.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter001&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0004.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter002&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0005.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter003&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0006.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter004&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0007.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter005&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0008.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter006&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0009.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter007&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0010.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter008&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0011.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter009&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0012.xhtml&quot;/&gt; &lt;item id=&quot;x_a1Chapter010&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0013.xhtml&quot;/&gt; &lt;item id=&quot;x_a2cover.html&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0014.xhtml&quot;/&gt; &lt;item id=&quot;x_a2bookname&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0015.xhtml&quot;/&gt; &lt;item id=&quot;x_a2TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0016.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter001&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0017.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter002&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0018.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter003&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0019.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter004&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0020.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter005&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0021.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter006&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0022.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter007&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0023.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter008&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0024.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter009&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0025.xhtml&quot;/&gt; &lt;item id=&quot;x_a2Chapter010&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0026.xhtml&quot;/&gt; &lt;item id=&quot;x_a3cover.html&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0027.xhtml&quot;/&gt; &lt;item id=&quot;x_a3bookname&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0028.xhtml&quot;/&gt; &lt;item id=&quot;x_a3TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0029.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter001&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0030.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter002&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0031.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter003&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0032.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter004&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0033.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter005&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0034.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter006&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0035.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter007&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0036.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter008&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0037.xhtml&quot;/&gt; &lt;item id=&quot;x_a3Chapter009&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0038.xhtml&quot;/&gt; &lt;item id=&quot;x_a4cover.html&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0039.xhtml&quot;/&gt; &lt;item id=&quot;x_a4bookname&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0040.xhtml&quot;/&gt; &lt;item id=&quot;x_a4TableOfContents&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0041.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter001&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0042.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter002&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0043.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter003&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0044.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter004&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0045.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter005&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0046.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter006&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0047.xhtml&quot;/&gt; &lt;item id=&quot;x_a4Chapter007&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;Text/part0048.xhtml&quot;/&gt; &lt;item id=&quot;item50&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0001.css&quot;/&gt; &lt;item id=&quot;item51&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0002.css&quot;/&gt; &lt;item id=&quot;item52&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0003.css&quot;/&gt; &lt;item id=&quot;item53&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0004.css&quot;/&gt; &lt;item id=&quot;item54&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0005.css&quot;/&gt; &lt;item id=&quot;item55&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0006.css&quot;/&gt; &lt;item id=&quot;item56&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0007.css&quot;/&gt; &lt;item id=&quot;item57&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0008.css&quot;/&gt; &lt;item id=&quot;item58&quot; media-type=&quot;text/css&quot; href=&quot;Styles/style0009.css&quot;/&gt; &lt;item id=&quot;item59&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00456.jpeg&quot;/&gt; &lt;item id=&quot;item60&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00457.jpeg&quot;/&gt; &lt;item id=&quot;item61&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00458.jpeg&quot;/&gt; &lt;item id=&quot;item62&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00459.jpeg&quot;/&gt; &lt;item id=&quot;item63&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00460.jpeg&quot;/&gt; &lt;item id=&quot;item64&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00461.jpeg&quot;/&gt; &lt;item id=&quot;item65&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00462.jpeg&quot;/&gt; &lt;item id=&quot;item66&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/image00463.jpeg&quot;/&gt; &lt;item id=&quot;x_cover-image&quot; media-type=&quot;image/jpeg&quot; href=&quot;Images/cover00464.jpeg&quot;/&gt; &lt;item id=&quot;ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot; href=&quot;toc.ncx&quot;/&gt; &lt;/manifest&gt; &lt;spine toc=&quot;ncx&quot;&gt; &lt;itemref idref=&quot;x_cover&quot; linear=&quot;no&quot;/&gt; &lt;itemref idref=&quot;x_TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1cover.html&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1bookname&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter001&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter002&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter003&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter004&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter005&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter006&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter007&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter008&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter009&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a1Chapter010&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2cover.html&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2bookname&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter001&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter002&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter003&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter004&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter005&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter006&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter007&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter008&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter009&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a2Chapter010&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3cover.html&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3bookname&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter001&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter002&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter003&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter004&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter005&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter006&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter007&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter008&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a3Chapter009&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4cover.html&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4bookname&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4TableOfContents&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter001&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter002&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter003&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter004&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter005&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter006&quot; linear=&quot;yes&quot;/&gt; &lt;itemref idref=&quot;x_a4Chapter007&quot; linear=&quot;yes&quot;/&gt; &lt;/spine&gt; &lt;tours&gt;&lt;/tours&gt; &lt;guide&gt; &lt;reference type=&quot;text&quot; title=&quot;Start&quot; href=&quot;Text/part0004.xhtml&quot;/&gt; &lt;reference type=&quot;toc&quot; title=&quot;Table of Contents&quot; href=&quot;Text/part0000.xhtml&quot;/&gt; &lt;reference type=&quot;cover&quot; title=&quot;Cover&quot; href=&quot;Text/cover_page.xhtml&quot;/&gt; &lt;/guide&gt;&lt;/package&gt; 说明我之前并没有猜错，这个文件存放的是超越“目录”的东西，而是“次序”——更进一步说。是“索引”。这个文件类似于其他文件格式或目录树中的 index.* ，将 ePub 中的各种数据编上号码，同时这里也定义了标题、语言、作者、出版 (发布) 日期等元信息。至于之前看到的超长行，似乎是一种十六进制的水印 (watermark) ，或许是为了防侵权等。 其中的 /package/manifest/item 定义了所有的索引，以及文件对应的类型； /package/spine/itemref 暂不知进一步的作用，但从中可看出能定义是否“线性” (linear) ； /package/guide/reference 定义了 ePub 的封面等索引，可供文件管理器和 ePub 阅读器使用 (显示预览页) 。 Round IV.IV. 目录！再看 OEBPS/toc.ncx ： 12[littleye233@lymjrolt test_epub]$ file OEBPS/toc.ncxOEBPS/toc.ncx: XML 1.0 document, Unicode text, UTF-8 text 感觉再讨论文件类型已经无关紧要了。再次查看内容： 点此查看 `OEBPS/toc.ncx` 的全部内容 (已经过格式化) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ncx xmlns=&quot;http://www.daisy.org/z3986/2005/ncx/&quot; version=&quot;2005-1&quot; xml:lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta content=&quot;3899198450&quot; name=&quot;dtb:uid&quot;/&gt; &lt;meta content=&quot;2&quot; name=&quot;dtb:depth&quot;/&gt; &lt;meta content=&quot;mobiunpack.py&quot; name=&quot;dtb:generator&quot;/&gt; &lt;meta content=&quot;0&quot; name=&quot;dtb:totalPageCount&quot;/&gt; &lt;meta content=&quot;0&quot; name=&quot;dtb:maxPageNumber&quot;/&gt; &lt;/head&gt; &lt;docTitle&gt; &lt;text&gt;咖啡馆推理事件簿系列（全四本）&lt;/text&gt; &lt;/docTitle&gt; &lt;navMap&gt; &lt;navPoint id=&quot;np_1&quot; playOrder=&quot;1&quot;&gt; &lt;navLabel&gt; &lt;text&gt;总目录&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0000.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_2&quot; playOrder=&quot;2&quot;&gt; &lt;navLabel&gt; &lt;text&gt;咖啡馆推理事件簿：下次见面时，请让我品尝你煮的咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0001.xhtml&quot;/&gt; &lt;navPoint id=&quot;np_3&quot; playOrder=&quot;3&quot;&gt; &lt;navLabel&gt; &lt;text&gt;序章&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0005.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_4&quot; playOrder=&quot;4&quot;&gt; &lt;navLabel&gt; &lt;text&gt;一 事件始于第二次光顾&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0006.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_5&quot; playOrder=&quot;5&quot;&gt; &lt;navLabel&gt; &lt;text&gt;二 Bittersweet Black&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0007.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_6&quot; playOrder=&quot;6&quot;&gt; &lt;navLabel&gt; &lt;text&gt;三 隐藏在乳白色中的心&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0008.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_7&quot; playOrder=&quot;7&quot;&gt; &lt;navLabel&gt; &lt;text&gt;四 棋盘上的狩猎&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0009.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_8&quot; playOrder=&quot;8&quot;&gt; &lt;navLabel&gt; &lt;text&gt;五 past，present，f******？&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0010.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_9&quot; playOrder=&quot;9&quot;&gt; &lt;navLabel&gt; &lt;text&gt;六 Animals in the closed room&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0011.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_10&quot; playOrder=&quot;10&quot;&gt; &lt;navLabel&gt; &lt;text&gt;七 下次见面时，请让我品尝你煮的咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0012.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_11&quot; playOrder=&quot;11&quot;&gt; &lt;navLabel&gt; &lt;text&gt;终章&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0013.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_12&quot; playOrder=&quot;12&quot;&gt; &lt;navLabel&gt; &lt;text&gt;咖啡馆推理事件簿2：她梦到了欧蕾咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0014.xhtml&quot;/&gt; &lt;navPoint id=&quot;np_13&quot; playOrder=&quot;13&quot;&gt; &lt;navLabel&gt; &lt;text&gt;序曲 她的梦&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0018.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_14&quot; playOrder=&quot;14&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第一章 敬启致未来的你&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0019.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_15&quot; playOrder=&quot;15&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第二章 狐狸的迷惑&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0020.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_16&quot; playOrder=&quot;16&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第三章 打碎乳白色的心&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0021.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_17&quot; playOrder=&quot;17&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第四章 咖啡侦探蕾拉事件簿&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0022.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_18&quot; playOrder=&quot;18&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第五章 （She Wanted To Be）WANTED&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0023.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_19&quot; playOrder=&quot;19&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第六章 the Sky Occluded in the Sun&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0024.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_20&quot; playOrder=&quot;20&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第七章 在星空之下同命相连&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0025.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_21&quot; playOrder=&quot;21&quot;&gt; &lt;navLabel&gt; &lt;text&gt;终章 她梦到了欧蕾咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0026.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_22&quot; playOrder=&quot;22&quot;&gt; &lt;navLabel&gt; &lt;text&gt;咖啡馆推理事件簿3：扰人心神的咖啡&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0027.xhtml&quot;/&gt; &lt;navPoint id=&quot;np_23&quot; playOrder=&quot;23&quot;&gt; &lt;navLabel&gt; &lt;text&gt;序曲 五年前&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0031.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_24&quot; playOrder=&quot;24&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第一章 参加大赛&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0032.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_25&quot; playOrder=&quot;25&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第二章 前夜&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0033.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_26&quot; playOrder=&quot;26&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第三章 第一天&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0034.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_27&quot; playOrder=&quot;27&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第四章 第二天&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0035.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_28&quot; playOrder=&quot;28&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第五章 真相&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0036.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_29&quot; playOrder=&quot;29&quot;&gt; &lt;navLabel&gt; &lt;text&gt;第六章 日后&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0037.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_30&quot; playOrder=&quot;30&quot;&gt; &lt;navLabel&gt; &lt;text&gt;尾声 五年前&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0038.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_31&quot; playOrder=&quot;31&quot;&gt; &lt;navLabel&gt; &lt;text&gt;咖啡馆推理事件簿4：休闲时光的五种风味&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0039.xhtml&quot;/&gt; &lt;navPoint id=&quot;np_32&quot; playOrder=&quot;32&quot;&gt; &lt;navLabel&gt; &lt;text&gt;午后三点前的无聊风景&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0043.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_33&quot; playOrder=&quot;33&quot;&gt; &lt;navLabel&gt; &lt;text&gt;帕列塔之恋&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0044.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_34&quot; playOrder=&quot;34&quot;&gt; &lt;navLabel&gt; &lt;text&gt;消失的礼物飞镖&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0045.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_35&quot; playOrder=&quot;35&quot;&gt; &lt;navLabel&gt; &lt;text&gt;可视化的原生艺术&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0046.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_36&quot; playOrder=&quot;36&quot;&gt; &lt;navLabel&gt; &lt;text&gt;在塔列兰咖啡馆的庭院里&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0047.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint id=&quot;np_37&quot; playOrder=&quot;37&quot;&gt; &lt;navLabel&gt; &lt;text&gt;特别篇 如释重负&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/part0048.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;/navMap&gt;&lt;/ncx&gt; 我们不妨将目光转向较为重要的“目录”的定义上。为了方便观察，笔者偷点懒，使用桌面环境中自带的阅读器观察： 从中可以看出目录是二层结构，恰好和 OEBPS/toc.ncx 中的定义保持一致。而其中的部分重要属性均可“望文生义”，此处不再进一步研究。 Round IV.V. 其余部分最后剩下的是图片、文字和层叠样式表。虽然这部分是在整个 ePub 文件中占比最大也可以说是最重要的部分，但由于这一块的内容实在是太过直白，再讲下去恐怕要开始补习 HTML 和 CSS 知识了，故同样略去。 总结根据上文中的简要探究， ePub 是一种以 XML 文件格式为配置文件类型的、包含有图片及文字等数据的、以压缩档为本质的文件格式。查阅相关资料后可知其实质与上文中分析类似。 而通过上文的分析，我们初步体验到分析一种陌生文件格式的规律和技巧，可以用于后续对更复杂的文件格式的探究。 但最后，别忘了把那个 ePub 文件的名字改回来 XD ： 1[littleye233@lymjrolt Downloads]$ mv test.epub 咖啡馆推理事件簿系列（全四本）.epub 【完】 脚注[^1]: 此处为 XPath 语法，用于描述类 XML 文件各种元素的位置，后文类似者不再注明。","link":"/techdev/format/epub/"},{"title":"【文件格式探究】EP.2 WAV 音频文件格式","text":"“WAV” 全名 “Waveform Audio File Format”, 是一种常见的存储音频信息的文件格式标准, 从其名称上即可看出其存储的是音频的波形信息. 一般 WAV 存储的音频是未压缩的, 且遵循 RIFF 标准来构建文件内容, 相较于其他音频格式省去了解压缩等处理, 复杂度较低. 本文将通过一个真实的 WAV 格式文件示例, 一一说明 WAV 文件格式中各个数据块的含义和位置, 并提供简单地读写 WAV 文件的代码实现, 并最终尝试生成自定义波形的 WAV 文件. 本文除涉及 WAV 格式最重要的文件头和数据块之外, 还将讲解 LIST-INFO 元信息格式在 WAV 中的应用. 前置知识: 音频的数位化表示声现象的本质是振动. 发声源通过产生人耳可听范围内某一频率的振动, 人耳即可以听到声音. 若将扬声器的表面看作一个富有弹性的平面, 且初始状态静止于零形变处, 那么扬声器在工作时, 可以认为其表面不停地向内或向外产生相对于初始状态的位移 - 这被称为 “振幅”. 扬声器工作时其表面的位移量, 可以看作是一个关于时间的函数. 上述场景在真实世界中很容易理解, 但在计算机中需要考虑一些很重要的问题, 例如: 计算机存储数据的精度是有限的, 而真实世界中完全可能出现在时间等于 $\\pi$ 秒时振幅为 $\\sqrt{2}$; 同理, 扬声器的振幅可以为 $1$, 也可以为 $1e10$. 计算机如何存储精度要求极高或如此巨大的数字? 答案很简单: 不存储. 但我们自然希望尽可能精确且全面地记录下这些振幅以及对应的时刻, 这就牵扯到后面提到的 “PCM” (Pulse-code modulation, 脉冲编码调制). PCM调制可以理解为将输入信号转变为另一个信号的过程. 而在我们上述的场景中, 当我们面对一个信息量巨大且信息精度很高的 “真实世界信号” (或者应该称之为 “模拟信号”) 时, 我们希望通过一种调制方式将其转变为计算机可接受的 “数字信号”. 一种应用相当普遍的调制方式即为 PCM, 它经常用于模数转换. 简单来说, PCM 是在时域上对模拟信号的时间轴和振幅轴同时做量化处理, 使之可以用一系列有限值来表示. 为方便起见, 本文仅考虑 LPCM (Linear pulse-code modulation) - 一种量化等级线性均匀排布的调制方式. 因为这种调制方式太过常见, 若无特别说明, 以下的 “PCM” 均指代 “LPCM”. 从数学上来说, 若要将振幅范围 $[0,A]$ 线性映射到一系列量化值 ${0,1,\\cdots,N}$, 则对于某一振幅 $x\\in[0,A]$, 其将会被量化到 $\\mathrm{round}\\left(\\dfrac{x}{A}N\\right)$, 其中 $\\mathrm{round}(\\cdot)$ 表示四舍五入. 显然 $N$ 决定了我们量化的精度. 较大的 $N$ 对于较大的 $A$ 也可以保持较好的量化效果 (如果不去除这些振幅较大的值), 对于较小的 $A$ 可以使其量化结果更接近于真实值. 一般来说, 量化范围内能表示的所有整数所需要的比特位数被称为位深 (bit depth), 常见的位深有 8-bit, 16-bit, 24-bit, 分别表示量化范围内可以表示 $2^8$, $2^{16}$, $2^{24}$ 个连续整数. 实际应用中, 一般 8-bit PCM 的量化范围为 $[0,2^8)$, (或 $[0,256)$) 也就是无符号整数; 而超过这一位深的量化范围 (以 16-bit 为例) 通常表示为 $[-2^{15},2^{15})$ (或 $[-32768,32768)$), 也就是有符号整数. 对于前者, 其零振幅时的量化值为 $2^7$ (或 128); 对于后者, 其零振幅时的量化值为 0. 此时仍然还有一个需要讨论的问题 - 时间轴如何量化? 一般来说我们仅考虑线性均匀采样, 以一个固定的采样率 (sample rate). 这是与位深类似的概念 - 显然采样率越高, 采样就越精确, 但这会带来很大的存储和处理成本; 而采样率下降, 甚至可能连模拟信号的频率信息都会丢失 (想象频率为 1Hz 的正弦波以 1Hz 均匀采样, 每次采样的结果都是相同的振幅). 对于采样率的下限, 在数字信号处理领域有著名的 Nyquist-Shannon sampling theorem (奈奎斯特-香农采样定理), 表明采样率应不小于波形最高频率的 2 倍, 才可能保证波形的各个分量的频率信息不丢失. 而根据傅里叶变换, 任何函数都可以分解为不同频率的正余弦函数之和. 因此, 在仅考虑幅度超过一定阈值的频率分量的情况下 (这是考虑到傅里叶变换的结果可能包含无穷多个频率分量, 但一般实际情况高频分量的幅度都很小; 限定幅度阈值后可以认为波形的正余弦分量有最高频率), 任何波形都可以应用这一定理, 从而推得采样率的下限. 实际上, 在很多场合下, 采样率仅仅超过最高频率的 2 倍是远远不够的. 在工程相关领域, 这个倍数可以达到 6 倍左右. 一般我们接触到的音频文件的采样率多在 44,100Hz, 少数能达到 48,000Hz 或更高. 人耳能听到的振动频率范围在 20Hz~20,000Hz 左右, 显然 44,100Hz 已经超过 Nyquist-Shannon sampling theorem 所要求的采样率下限. 一般音乐的波形频率不会达到如此高的频率. 以 MIDI 能表示的音高为例, 音符事件的音调最大值 127 (对应音高为 G9) 对应的频率约为 12544Hz, 接近于采样率的四分之一. 对于 PCM 而言, 最重要的两个参数即是上述的位深和采样率. WAV 文件格式的结构接下来我们将正式开始讨论 WAV 文件格式是如何构建的. 前文中提到 WAV 格式遵循 RIFF 标准, 因此 WAV 格式本身即是 RIFF 标准中的一个 “RIFF” chunk, 并具有规定的文件头. 除去文件头剩余的文件内容被分为一些 sub-chunk, 例如规定音频格式具体信息的 “fmt “ (注意这里的空格, 很快将知道为什么) sub-chunk 和定义音频波形具体数据的 “data” sub-chunk, 还可能包含 “LIST” 元信息 sub-chunk. 按照 RIFF 标准, “RIFF” 和 “LIST” chunk 的剩余文件内容 (或者也可以理解为这些 chunks 的数据部分) 是其他 sub-chunks, 而 “fmt “ 和 “data” 此类普通的 sub-chunks 的数据部分就是普通的二进制数据流. 更详细地, 按照 RIFF 标准, 所有的数据都是以 chunk 的形式存储. 这些 chunk 都具有如下的结构: 长度 (字节数) 含义 4 chunk 的 ASCII 标识符 (“RIFF”, “LIST” 等) 4 chunk 的 “数据部分” 的长度 剩余 chunk 的 “数据部分” 其中对于 “RIFF” 和 “LIST” 两种特殊的 chunks, 其 “数据部分” 又可以拆分为: 长度 (字节数) 含义 4 chunk “数据部分” 的 ASCII 标识符(例如 WAV 格式的 “WAVE”, 元信息的 “INFO”) 剩余 sub-chunk 1, sub-chunk 2, … 显然这里的 ASCII 标识符的长度必须为 4 个字节, 因此 “fmt” 后添加了一个空格以填充空隙. 类似的有 AVI 格式的 “RIFF” chunk, 其 “数据部分” 的 ASCII 标识符为 “AVI “, 同样包含一个末尾的空格. 值得注意的是, 这里涉及到各个 chunk 的不同域 (field), 只有 ASCII 标识符是大端序 (big-endian) 的, 其他的都是小端序 (little-endian). 在后续的例子中我们可以看出这二者的区别. 以及, 对于某些情况, 整个 chunk 如果长度不为偶数, 通常会加入一个 padding space (以 \\x00 填充). 在本文所述的场景中, \\x00 被填充在整个 chunk 的末尾, 并不将其计入整个 chunk 的长度. 这也会在后续的例子中说明. 接下来将详细讨论不同的 sub-chunks. 为方便起见, 对于它们我们仍然称为 “chunks”. “fmt “ chunk除去该 chunk 的前 8 个固定字节不谈, 我们仅讨论其 “数据部分” 的结构: 长度 (字节数) 域名 (field name) 含义 2 AudioFormat 音频格式, 表征普通的 PCM 或压缩处理 2 NumChannels 频道 (声道) 数 4 SampleRate 采样率 (单位 Hz) 4 ByteRate 每秒钟所占字节数 2 BlockAlign 每个样本在所有频道所占字节数之和 2 BitsPerSample 位深 2 ExtraParamSize (可选) 额外参数长度 剩余 ExtraParams 额外参数 对于部分 fields 有如下的说明 (以下数字取值均用十进制表示): AudioFormat PCM 未压缩: 1 其他压缩形式: 其他值 NumChannels 单声道: 1 双声道: 2 7.1 声道: 8 ByteRate: 计算式为 SampleRate * NumChannels * BitsPerSample / 8 BlockAlign: 计算式为 NumChannels * BitsPerSample / 8 “LIST” chunk (可选)上文提及该 chunk 是用来记录 WAV 格式的元信息, 诸如歌曲名, 艺术家, 专辑等等. 这些信息存储在下属的 sub-chunks 内, 且原则上都是可选的. 需要注意在必要的时候为 chunk 的末尾补 padding space. 以下列举可能出现的 sub-chunk 的标识符及其含义. 标识符 含义 INAM 音频 (track) 标题 IPRD 专辑标题 IART 创作者 ICRD 创作日期 (格式为 “YYYY-MM-DD”, 但通常只会保留年份 “YYYY”) ITRK 音频在专辑中的序号 ICMT 注释 (comment) 文本 IKEY 工程或文件的关键词 ISFT 创建该音频的软件 IENG 参与创建该音频的工程师 (engineer). 若有多人则用 ; 和半角空格隔开. IGNR 流派 ICOP 版权信息 ISBJ 主题 (subject) ISRC 提供音频原始主题的人或组织 “data” chunk这个 chunk 最终依照时间顺序存储各个样本 (sample) 的 PCM 量化数据. 直接考虑其 “数据部分” - 这是一个 (通常很长的) 连续二进制流. 这个二进制流由诸多 samples 组成, 每个 sample 顺序存储不同声道的数据 (且每个 sample 需要结束在偶数字节位置, 不过对于 16-bit 位深的音频通常一定是满足这个条件的), 而每个声道在该样本下的数据为一个固定比特位数的整数 (这个位数由位深决定). 更具体的解释见后文的示例文件. WAV 文件示例以下截取ハルカトミユキ的音乐作品《17才》的一个 WAV 格式音频文件的前 0xead0 (十进制 60,112) 行部分内容, 并以 hexdump 命令的形式呈现. 1234567891011121314151600000000 52 49 46 46 4e 68 e1 02 57 41 56 45 4c 49 53 54 |RIFFNh..WAVELIST|00000010 90 00 00 00 49 4e 46 4f 49 41 52 54 0f 00 00 00 |....INFOIART....|00000020 a5 cf a5 eb a5 ab a5 c8 a5 df a5 e6 a5 ad 00 00 |................|00000030 49 4e 41 4d 05 00 00 00 31 37 b2 c5 00 00 49 50 |INAM....17....IP|00000040 52 44 16 00 00 00 31 37 b2 c5 20 5b c6 da e9 67 |RD....17.. [...g|00000050 c9 fa ae 62 cf de b6 a8 b1 50 5d 00 49 47 4e 52 |...b.....P].IGNR|00000060 14 00 00 00 49 6e 64 69 65 20 2f 20 41 6c 74 65 |....Indie / Alte|00000070 72 6e 61 74 69 76 65 00 49 54 4f 43 1a 00 00 00 |rnative.ITOC....|00000080 34 2b 39 36 2b 35 30 44 39 2b 39 31 46 43 2b 44 |4+96+50D9+91FC+D|00000090 32 45 39 2b 31 31 42 37 34 00 49 54 52 4b 02 00 |2E9+11B74.ITRK..|000000a0 00 00 31 00 66 6d 74 20 12 00 00 00 01 00 02 00 |..1.fmt ........|000000b0 44 ac 00 00 10 b1 02 00 04 00 10 00 00 00 64 61 |D.............da|000000c0 74 61 90 67 e1 02 00 00 00 00 00 00 00 00 00 00 |ta.g............|000000d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|*0000ead0 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 |................| 简单说明上述的数据呈现形式: 最左侧的 8 位十六进制数表示该行首个字节在文件中的位置 (offset); 每行中间排列 16 个 2 位十六进制数 (8 位二进制数, 1 个字节); 最右侧是各个对应数据的 ASCII 形式; 大量相同行的数据将会以 * 省略. 后面我们将要涉及到前文暂按下不表的 “小端序”. 简单来说, 小端序指的是将一个超过 8 位的整数按照字节切分后逆向排列各个部分存储在计算机中的方式. 举例来说, 若一个 32 位整数在计算机中存储为 “01 02 03 04” (忽略方便阅读的空格, 后同), 则该整数的实际值应为 0x04030201. 与之相对, 大端序即是将其顺向排列, 也就是 0x04030201 存储为 “04 03 02 01”. 接下来, 我们将一一剖析其中的各种信息. “RIFF” chunk 头这可谓是整个小姐最容易分析的部分: 考虑位置 0x0 ~ +8 (表示从 0x0 位置到 0x0+8=0x8 位置, 包含左端点但不包含右端点, 后同), 前 4 个字节是该 chunk 的标识符 “RIFF”, 后 4 个字节表征该文件去除该 chunk 文件头后的字节数. 4e 68 e1 02 应该理解为 0x02e1684e, 也即 48326734 (约 46 MiB, 与文件系统显示的大小相符). 位置 0x8 ~ +4 为 “RIFF” chunk 的 “数据部分” 的 ASCII 标识符 “WAVE”. “LIST” chunk 的结构位置 0x12 ~ +12 类似上一小节. 略去. 位置 0x24 ~ +24 为 “IART” chunk. “IART” 的 ASCII 标识符略去. 注意到位置 0x28 ~ +4 标示的 chunk “数据部分” 大小为 0x0000000f 也即 15. 位置 0x20 ~ +15 的字节流使用 GB18030 编码解码后恰好得到的是 “ハルカトミユキ” (不包含引号, 后同) 附加一个空字符 \\x00 - 这应该是 CD 在 Windows 平台抓取时平台默认在元信息后增加空白字符所致, 不影响分析; 后续出现类似情况不再赘述. 位置 0x2f 则是 padding space. 后续 “IPRD”, “IGNR”, “ITOC”, “ITRK” chunks 的分析类似. 另外可以看到 “IPRD” chunk 后即没有 padding space, 符合前文的分析. “fmt “ chunk 的结构相较于其他的 chunks, 这个 chunk 因为连续排布了很多信息, 很容易看错. 这个 chunk 的位置为 0xa4 ~ +26. 略去与前述小节类似的 0xa4 ~ +8 的部分, 直接考虑后续的 18 个字节. 以下以表格形式呈现不同位置的数据及其表达的信息. 位置 域名 (field name) 原始数据 实际十进制数 0xac ~ +2 AudioFormat 01 00 1 0xae ~ +2 NumChannels 02 00 2 0xb0 ~ +4 SampleRate 44 ac 00 00 44100 0xb4 ~ +4 ByteRate 10 b1 02 00 176400 0xb8 ~ +2 BlockAlign 04 00 4 0xba ~ +2 BitsPerSample 10 00 16 0xbc ~ +2 ExtraParamSize 00 00 0 “data” chunk 的结构从位置 0xbe 开始直至文件末尾都是 “data” chunk. 前 4 个字节同样略去不解释. 这里可以看到位置 0xd0 ~ 0xead0 几乎都全是空字节 \\x00, 表示没有音频输出. 0xead0 - 0xd0 为十进制 59,904, 在采样率 44,100Hz 前提下大约为持续 1.4 秒, 符合音乐录音开头空白的通常时长. 因为原音频文件中很难找到各个 sample 之间差异较大的位置, 我将以虚构的一段 “data” chunk 的 “数据部分” 作解释 (假设位深和声道数不变): 101 02 03 04 05 06 07 08 上述 8 个字节总共包含 4 个 samples - 01 02, 03 04, 05 06, 07 08. 每个 sample 包含 2 个声道的数据, 以第 1 个 sample 举例则是 01 和 02. 其中第 1 个声道的数据为 01, 表示其 PCM 量化值为十进制的 1. 代码实现 待补充. 参考文献本文大量引用如下网络资源: WAV - Wikipedia. Pulse-code modulation - Wikipedia. iphone - PCM audio amplitude values? - Stack Overflow. 音高和频率的关系. Resource Interchange File Format - Wikipedia. http://tiny.systems/software/soundProgrammer/WavFormatDocs.pdf. Wav Meta Data - Audio - RobotPlanet.","link":"/techdev/format/wav/"},{"title":"Kotlin 简要语法快速学习","text":"前言因为一些机缘巧合, 笔者需要研究一下 Android 应用程序的二次开发, 作为目标的软件恰好是使用 Kotlin 编写的, 而笔者尚无该编程语言的基础, 因此需要快速掌握 Kotlin 的一些重要语法. 笔者对 Kotlin 语法糖多早有所耳闻. 考虑到官方文档 (或者说, 笔者本次参考的资料) 未必对所有的语法特性都能面面俱到, 笔者在这篇文章中, 可能只会涉及到部分语法糖. 需要注意的是, 本文只会聚焦于 Kotlin 的语法规则, 并辅以一些具体例子, 并不会在这里谈 Kotlin 是如何编译源代码的, Kotlin 是如何应用到 Android 开发的, 诸如此类. 借用 Arch Linux 软件仓库 community/kotlin 包的描述: Statically typed programming language that can interoperate with Java. 可以预料的是, Kotlin 和 Java 的语法规则有一定相似之处, 但笔者同样没有 Java 基础, 因此对这两门语言都比较陌生的读者也不用担心笔者跳过二者相似的部分不谈. 准备参考教程笔者主要参考的教程即为 Kotlin 的官方文档, 并从 Basic syntax 章节开始. 同时, Kotlin 为已有变成基础的学习者提供了 Learning materials overview 的页面, 其中的第一章节同样是 Basic syntax. 开发环境Kotlin 官方文档中建议使用 IntelliJ IDEA 和 Android Studio 来进行 Kotlin 开发, 但对于语法学习则不必要使用这些 IDE (更何况后者从名字上就像是针对 Android 开发的). 本次学习过程中, 笔者选择在 Arch Linux 中直接安装 community/kotlin 的包 (版本号为 1.7.22) 作为编译环境, extra/jdk17-openjdk 包 (版本号为 17.0.5.u1) 作为生成的 JAR 包的运行环境. 读者可以搭配装载 Kotlin 相关插件的 Visual Studio Code 用以编辑 Kotlin 源代码. 编译运行这里笔者略去 JVM 等细节, 仅说明命令行环境下如何编译单文件 Kotlin 源代码. 假设需要编译的源代码文件路径为 /path/to/kotlin-learning/helloworld.kt. 保证 Java 运行时环境和 Kotlin 编译器安装的情况下, 执行 123cd /path/to/kotlin-learningkotlinc helloworld.kt -include-runtime -d helloworld.jarjava -jar helloworld.jar 包的声明与导入熟悉 Java 语法的读者应该很习惯诸如 1package com.example.myapp; 的代码. 在 Kotlin 中一般仍然需要编写类似的结构, 这是因为 Kotlin 同样依赖”包” (package) 的结构来组织代码. 显而易见的是点分隔符 . 规定了包之间的层级关系. 暂时可以简单理解为这声明了代码文件的”ID”. 不过需要注意的是, Kotlin 中的包声明不必要与实际的文件系统结构一致, 也就是说, 声明了 com.example.myapp 的代码文件的路径不必要是 com/example/myapp.kt. 声明包名之后, 就可以通过 import 语句导入其他包, 乃至其他 (诸如顶级函数和属性, 枚举类型常数等): package_example.kt12345678910package ktlearning,package_example// 导入包 `OneFile`import ktlearning.one_package.OneFile// 导入包 `another_package` 下的所有子包import ktlearning.another_package.*// 避免包名冲突import ktlearning.another_another_package.OneFile as AnotherFile// 导入顶级函数 `TopLevelFunc`import ktlearning.another_another_package.AnotherFile.TopLevelFunc 主函数Kotlin 需要主函数作为程序的入口. 主函数通常写作: 123fun main(args: Array&lt;String&gt;) { // 函数体} 这类似于 Java 中的 123public static void main(String[] args) { // 函数体} 从 Kotlin 的代码中, 可以看出这个主函数 main(args) 接受一个 String 类型的数组 (Array). 当然在当前版本的 Kotlin 中, 主函数可以省去 args 这一参数. 函数体中未使用该参数反而会触发警告. 对于这个参数, 一个常见的操作是直接将其转化为字符串并输出: example.kt1println(args.contentToString()) 例如 java -jar example.jar foo 1024 &quot;bar baz&quot; 的输出将为 1[foo, 1024, bar baz] 有趣的是, 若将 .contentToString() 删去, Kotlin 依然可以编译, 但最终可能会输出诸如 1[Ljava.lang.String;@4f47d241 的错误结果. 输出到标准输出 (standard output)helloworld.kt12345678package ktlearning.helloworldfun main() { println(&quot;Hello world!&quot;) print(1) print(&quot; more &quot;) print(&quot;hello world!\\n&quot;)} 输出: 12Hello world!1 more hello world! Kotlin 支持 print(message) 和 println(message) 两种输出到标准输出的方式. 需要注意的是这两个函数只接受单一变量参数. 属性“属性” (property) 这个概念被归类于 Classes and objects 这一章节中. 这个术语可能更常在面向对象编程中提及. 当然, 本文之前涉及到的完整的可编译代码似乎并没有显式地涉及到面向对象 (例如, 没有出现 class 这一关键字), 不过 Kotlin 中依然将诸如其他编程语言中很早提及的 “不可变变量” (immutable variable) 和 “可变变量” (mutable variable) 都视为一种 “属性” - 这表明它们可以具有传统的 “变量” 所缺失的特性. Kotlin 中同样有 “编译时常量” (compile-time constant) 的概念. 根据官方文档相关的表述, 这类属性若在编译时值已知, Kotlin 编译器则可以在编译期间将对其的引用替换为实际的值. 试图定义传统意义上的 “变量” 和 “常量” 时: 123456// 定义不可变变量val a: Int = 1// 定义可变变量var b = &quot;foo&quot;// 定义编译时常量const val PI = 3.14159 getters 和 setters如果可以提前涉及到一些面向对象的内容的话, 既然这些概念都可以被抽象为 “属性”, 那面向对象中 getter 和 setter 的存在就不可被略过了. Kotlin 中对可变属性的完整定义语法如下: 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 不可变属性的则如下: 123val &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] // 不允许定义 setter 一些简单的定义示例如下: 1234567// 自动推断为 `Int` 类型, 具有默认的 getter 和 settervar initialized = 1// 为 `Int` 类型不可变属性设置自定义 getterval area: Int get() = this.width * this.height// 同时根据 getter 自动推断val area2 get() = this.width * this.height backing fields若涉及到在属性的 setter 中为属性本身赋值时, 为避免出现无限递归的情形, Kotlin 引入了一个 “内部属性” field 用以 “临时” 存储属性值: 123456var counter = 0 set(value) { if (value &gt;= 0) { field = value } } 如果将上述代码块中的 field = value 改为 counter = value, 编译器则会抛出堆栈溢出的错误. 数据类型Kotlin 中任何事物皆是对象. 这里仅讨论一些基本的数据类型. 整型 类型 字节数 Byte 1 Short 2 Int 4 Long 8 与一些编程语言相同, 在类型自动推断中, 可以在数字末尾添加 L (例如 1L) 来声明其类型为 Long 而不是默认的 Int. 参见 Integer types. 浮点型 类型 字节数 significant bits exponent bits decimal digits Float 4 24 8 6-7 Double 8 53 11 15-16 同样, 在数字末尾添加 f 或 F (例如 3.14f) 来声明其类型为 Float 而不是默认的 Double. 需要注意的是, 浮点型和整型之间不会自动转换. 例如如下的代码会抛出编译错误: 123fun sum(a: Double, b: Double) = a + b// `1` 不是 `Double` 类型sum(1, 2.0) 参见 Floating-point types. 无符号整型只需要在原有的数据类型前添加 U (例如 UByte) 即可. 同样, 在数字末尾添加 u (例如 1u) 来声明其类型为无符号类型. 类似的, ul 或 UL 声明其类型为 ULong. 特殊的数字表示除了上文提及的 f / F 和 L, Kotlin 还支持其他特别的数字表示方法: 特殊表示 示例 二进制整型 0b00001111 八进制整型 不支持 十六进制整型 0x0F 科学计数法 1.0e24 同时, Kotlin 支持在数字之间增加下划线 (_) 来增加可读性: 12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 函数上文中已经出现了主函数的定义和使用方法. 对于一个通常的函数, 例如实现两个整数的加法: func_sum.kt1234567891011121314151617181920212223package ktlearning.func_sum// 通常的函数定义fun sum1(a: Int, b: Int): Int { return a + b}// 直接定义其返回值的函数定义, 同时实现了类型推断fun sum2(a: Int, b: Int) = a + b// 定义无返回值的函数 (`Unit` 可以省略)fun printSum(a: Int, b: Int): Unit { println(&quot;Sum of $a and $b is ${a + b}&quot;)}fun main() { val a = 2 var b = 3 println(&quot;Sum of $a and $b is ${sum1(a, b)}&quot;) println(&quot;Sum of $a and $b is ${sum2(a, b)}&quot;) printSum(a, b)} 面向对象直接用例子说明: oop_shape.kt123456789101112131415161718192021222324252627282930313233343536373839404142package ktlearning.oop_shape// 可继承的类前加 `open`open class Shape(name: String) { // the primary constructor var name = name open fun say() { println(&quot;My name is ${this.name}!&quot;) } open val area: Double = 0.0}class Rectangle(name: String, width: Double, height: Double) : Shape(name) { var width = width var height = height // 重载父类的属性 override val area: Double get() = this.width * this.height}class Circle(name: String, radius: Double) : Shape(name) { val PI = 3.1415926 var radius = radius override val area: Double get() = PI * this.radius * this.radius}fun main() { val rect = Rectangle(&quot;My Rectangle&quot;, 2.0, 3.5) val circ = Circle(&quot;My Circle&quot;, 2.0) rect.say() circ.say() println(&quot;The area of ${rect.name} is ${rect.area}&quot;) println(&quot;The area of ${circ.name} is ${circ.area}&quot;)} 输出为: 1234My name is My Rectangle!My name is My Circle!The area of My Rectangle is 7.0The area of My Circle is 12.5663704 参见 Creating classes and instances. 注释123456789101112131415// 行注释/* 块注释*//* 下面是内层块注释. /* 内层块注释 */ 上面是内层块注释*/ 条件结构if 语句块12345if (a &gt; b) println(a)else { println(b)} 条件表达式1fun max(a: Int, b: Int) = if (a &gt; b) a else b 相对的, C 中为 123int max(int a, int b) { return (a &gt; b) ? a : b;} Python 中为 12def max(a: int, b: int) -&gt; int: return a if a &gt; b else b (个人认为 Python 的条件表达式的结构经常写错, 因为条件被插入在两个分支表达式之间.) whenKotlin 中的 when 类似于 C 中的 switch, 但其用法更加灵活: 1234567891011121314151617181920212223242526when (x) { // 左侧可以是一个表达式, 用以匹配 1 -&gt; println(&quot;x == 1&quot;) 2 -&gt; println(&quot;x == 2&quot;) // 不匹配上述所有表达式 else -&gt; { println(&quot;x is neither 1 nor 2&quot;) }}// `when` 也可以作为表达式fun describe(obj: Any): String = when (obj) { 1 -&gt; &quot;One&quot; &quot;Hello&quot; -&gt; &quot;Greeting&quot; // 可以包含条件表达式 is Long -&gt; &quot;Long&quot; !is String -&gt; &quot;Not a string&quot; else -&gt; &quot;Unknown&quot; }fun isPositive(x: Int) = when (x) { // 当覆盖所有可能性时, 无需 `else` 分支 x &gt; 0 -&gt; true x &lt;= 0 -&gt; false} 循环结构for 循环12345678910111213141516171819for (i in 1..3) { println(i)}for (i in 6 downTo 0 step 2) { println(i)}for (elem in array) { println(elem)}for (i in array.indices) { println(array[i])}for ((i, elem) in array.withIndex()) { println(&quot;array[$i] = $elem&quot;)} while 循环1234567while (x &gt; 0) { x--}do { val y = retrieveData()} while (y != null) 可空值 (nullable values) 和空值检查 (null checks)可空类型需要在类型后添加 ? 标识. null 则表示空值. null_check.kt123456789101112131415161718192021222324// 若字符串不能表示一个整型, 则转化为 `null`fun parseInt(str: String): Int? { return str.toIntOrNull()}fun printProduct(arg1: String, arg2: String) { val x = parseInt(arg1) val y = parseInt(arg2) // 不能直接使用 `x * y`, 因为 `x` 和 `y` 可能为 `null` if (x != null &amp;&amp; y != null) { // 空值检查后, 其类型自动转化为非空的整型 println(x * y) } else { println(&quot;'$arg1' or '$arg2' is not a number&quot;) } }fun main() { printProduct(&quot;6&quot;, &quot;7&quot;) printProduct(&quot;a&quot;, &quot;7&quot;) printProduct(&quot;a&quot;, &quot;b&quot;)} 输出为: 12342'a' or '7' is not a number'a' or 'b' is not a number","link":"/techdev/kotlin/quick-learning/"},{"title":"LeetCode Problem 3: Longest Substring Without Repeating Characters","text":"LeetCode Problem 3 Java 一解. 分析需要注意的是, 这并不是一个时间复杂度最优的方法. 以下方法的时间复杂度为 $O(N^2)$. 本题不需要什么动态规划之类, 只需要最基本的模拟 (implementation). 观察本题的数据范围, 容易猜到本题的时间复杂度. 对于这种单一字符串寻找子串, 可以使用双指针的方法: 假设 left 指针一开始处于字符串最左侧, right 指针不断地向右移动, 途中维护一个无序集合 chars 存储子串每一个不同字符; 若遇到曾出现的字符, 则 left 指针不断向右移动直到该字符只出现一次. 理论上只需要将 left 直接移动到旧的 left 指针之后的字符串第一次出现该字符的位置的右侧一格, 但是需要注意的是这个 “移动” 过程中我们仍然需要不断维护无序集合 chars, 因此不能只修改 left 的值, 而是不断地确认是否需要从 chars 中移除元素. 代码123456789101112131415161718192021class Solution { public int lengthOfLongestSubstring(String s) { HashSet&lt;Character&gt; chars = new HashSet&lt;Character&gt;(); int result = 0; int left = 0; for (int right = left; right &lt; s.length(); right++) { Character ch = s.charAt(right); if (chars.contains(ch)) { while (s.charAt(left) != ch) { chars.remove(s.charAt(left)); left++; } left += 1; } else { chars.add(ch); result = Math.max(right - left + 1, result); } } return result; }}","link":"/acmoi/leetcode/3/"},{"title":"Codeforces 1327A: Sum of Odd Integers","text":"Codeforces C++ 一解. 分析本题需要对任意的 $n$ 确认其能否表示成各不相同的正奇数之和. 标有 “math” tag 的题目往往只需要很简短的代码就可以实现. 注意到从 1 开始的前 $k$ 个奇数之和为 $$\\sum_{i=1}^{k}(2i-1)=\\frac{(1+(2k-1))*k}{2}=k^2.$$ 所以很自然地, $n&lt;k^2$ 时显然不可能表示出来. 再考虑奇偶性, 显然 $n$ 和 $k$ 的奇偶性不同时也是无法表示的. 那剩下的数字怎么办? 这里需要用到数学竞赛中经常使用的构造特例的方法: 构造下列奇数列 $1,3,5,\\cdots,2(k-1)-1,r$, 其中 $r=n-1-3-5-\\cdots-(2(k-1)-1)$. 首先容易得到 $n\\geq k^2$ 所以 $r&gt;2(k-1)-1$; 再者, $n$ 减去 $k-1$ 个奇数, 在 $n$ 和 $k$ 奇偶性相同时, 其结果一定是奇数. 这就说明对于其他情况, 一定存在这样的表示方式. 综上, 我们只需要对 $n$ 的大小以及 $n$ 与 $k$ 的奇偶性做判断就可以了. 代码12345678910111213141516171819202122#include &lt;cstdio&gt;using namespace std;bool check(long long n, long long k) { return (n &gt;= k * k) &amp;&amp; (n % 2 == k % 2);}int main() { long long t, n, k; scanf(&quot;%lld&quot;, &amp;t); for (int i = 0; i &lt; t; ++i) { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); if (check(n, k)) { printf(&quot;YES\\n&quot;); } else { printf(&quot;NO\\n&quot;); } } return 0;}","link":"/acmoi/codeforces/1327a/"},{"title":"Codeforces 363B: Fence &amp; Rust for Competitive Programming","text":"Codeforces 363B C++/Rust 一解, 以及 Rust 在竞赛中的一些事项. 分析这道题本身比较简单, 所谓的动态规划就是前缀和: 跑完一遍前缀和之后遍历一遍找出最小值即可. 本文主要是记录 Rust 写竞赛题时需要注意的和 C++ 不太一样的地方. 当然相对而言 C++ 常常能写出短小的代码, 但是 Rust 更能在编译时跟踪许多错漏, 以至于目前的所有 Rust 提交都是一遍 AC. 一些需要注意的地方: Rust 默认的变量都是不可变的, 记得添加 mut 关键字; Rust 的索引必须为 usize 类型, 不能随便乱用 i32 或 i64; Rust 开固定大小数组的方式: Vec::with_capacity(n), 注意 n 也为 usize 类型; Rust 虽然要关注所有权的问题, 但是一般的代码还是不需要用到 &amp;; Rust 很多函数和方法用到了 Result, Some, Option 等特殊类型作为返回类型, 需要注意如何处理这些数据 (例如 .unwrap(), .ok()). 代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int h[150001], s[150001];int main() { int n, k, minsum = 0x7fffffff, minsumpos; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; h[i]; s[i] = s[i - 1] + h[i]; } for (int i = 1; i &lt;= n - k + 1; ++i) { if (s[i + k - 1] - s[i - 1] &lt; minsum) { minsum = s[i + k - 1] - s[i - 1]; minsumpos = i; } } cout &lt;&lt; minsumpos &lt;&lt; endl; return 0;} Rust 部分最重要的代码部分位于 // Write code here 以下, 其他的部分是读入数据的模板, 不必过多在意. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#[allow(unused_imports)]use std::io::{BufWriter, stdin, stdout, Write};#[derive(Default)]struct Scanner { buffer: Vec&lt;String&gt;}impl Scanner { fn next&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(&quot;Failed parse&quot;); } let mut input = String::new(); stdin().read_line(&amp;mut input).expect(&quot;Failed read&quot;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } }}fn main() { let mut scan = Scanner::default(); let out = &amp;mut BufWriter::new(stdout()); // Write code here let n: usize = scan.next(); let k: usize = scan.next(); let mut hs: Vec&lt;i32&gt; = Vec::with_capacity(n); for _ in 0..n { let h: i32 = scan.next(); hs.push(h); } let mut hhs: Vec&lt;i32&gt; = Vec::with_capacity(n + 1); hhs.push(0); for i in 0..n { hhs.push(&amp;hs[i] + &amp;hhs[i]); } let mut m = 0x7fffffff; let mut mpos = 0; for i in k..=n { if hhs[i] - hhs[i - k] &lt; m { m = hhs[i] - hhs[i - k]; mpos = i - k + 1; } } writeln!(out, &quot;{}&quot;, mpos).ok();}","link":"/acmoi/codeforces/363b/"},{"title":"Codeforces 1324B: Yet Another Palindrome Problem","text":"Codeforces 1324B Rust 二解. 分析这题本身是很水的. 所谓的存在回文子序列也就是存在两个相同的数字其中间还有其他数字. 这道题很好想到 $O(N^2)$ 的算法: 直接双重循环暴力搜索是否存在这两个数字就行了 (也就是改改循环上下限的问题); 另一个 $O(N)$ 或 $O(1)$ 的算法是使用哈希表维护每个数字在整个数组中最初和最末的位置. 代码$O(N^2)$ 算法, 借鉴于 Codeforces 官方 Tutorial: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#[allow(unused_imports)]use std::io::{BufWriter, stdin, stdout, Write};#[derive(Default)]struct Scanner { buffer: Vec&lt;String&gt;}impl Scanner { fn next&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(&quot;Failed parse&quot;); } let mut input = String::new(); stdin().read_line(&amp;mut input).expect(&quot;Failed read&quot;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } }}// codeforces' tutorial:fn solve(v: &amp;[u32]) -&gt; bool { let l = v.len(); for i in 0..l { for j in (i + 2)..l { if v[i] == v[j] { return true; } } } false}fn main() { let mut scan = Scanner::default(); let out = &amp;mut BufWriter::new(stdout()); // Write code here let t: usize = scan.next(); for _ in 0..t { let n: usize = scan.next(); let v: Vec&lt;u32&gt; = (0..n).map(|_| scan.next()).collect(); if solve(&amp;v) { writeln!(out, &quot;YES&quot;).ok(); } else { writeln!(out, &quot;NO&quot;).ok(); } }} $O(N)$ 或 $O(1)$ 的算法是自己最先想到的. 以下仅提供 solve() 等关键部分: 1234567891011121314151617181920#[derive(Debug)]struct MN(usize, usize); // 分别存储最小最大索引位置fn solve(v: &amp;[u32]) -&gt; bool { let mut m: HashMap&lt;u32, MN&gt; = HashMap::new(); for (i, j) in v.iter().enumerate() { if m.contains_key(j) { // can be simplified let mn = m.get(j).unwrap(); m.insert(*j, MN(min(mn.0, i), max(mn.1, i))); } else { m.insert(*j, MN(i, i)); } } for (_, mn) in &amp;m { if mn.1 - mn.0 &gt;= 2 { return true; } } false}","link":"/acmoi/codeforces/1324b/"}],"tags":[{"name":"ACG","slug":"ACG","link":"/tags/ACG/"},{"name":"Music","slug":"Music","link":"/tags/Music/"},{"name":"Ceui","slug":"Ceui","link":"/tags/Ceui/"},{"name":"现在就想告诉哥哥，我是妹妹！","slug":"现在就想告诉哥哥，我是妹妹！","link":"/tags/%E7%8E%B0%E5%9C%A8%E5%B0%B1%E6%83%B3%E5%91%8A%E8%AF%89%E5%93%A5%E5%93%A5%EF%BC%8C%E6%88%91%E6%98%AF%E5%A6%B9%E5%A6%B9%EF%BC%81/"},{"name":"Information Security","slug":"Information-Security","link":"/tags/Information-Security/"},{"name":"GPG","slug":"GPG","link":"/tags/GPG/"},{"name":"OpenPGP","slug":"OpenPGP","link":"/tags/OpenPGP/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"Simplified Chinese","slug":"Simplified-Chinese","link":"/tags/Simplified-Chinese/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Arch Linux","slug":"Arch-Linux","link":"/tags/Arch-Linux/"},{"name":"Time","slug":"Time","link":"/tags/Time/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Performance","slug":"Performance","link":"/tags/Performance/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"Solution","slug":"Solution","link":"/tags/Solution/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"OI","slug":"OI","link":"/tags/OI/"},{"name":"Lanqiao","slug":"Lanqiao","link":"/tags/Lanqiao/"},{"name":"Problem","slug":"Problem","link":"/tags/Problem/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"Boot Loader","slug":"Boot-Loader","link":"/tags/Boot-Loader/"},{"name":"Desktop","slug":"Desktop","link":"/tags/Desktop/"},{"name":"Kernel","slug":"Kernel","link":"/tags/Kernel/"},{"name":"AUR","slug":"AUR","link":"/tags/AUR/"},{"name":"Compilation","slug":"Compilation","link":"/tags/Compilation/"},{"name":"Localization","slug":"Localization","link":"/tags/Localization/"},{"name":"maddy","slug":"maddy","link":"/tags/maddy/"},{"name":"Email","slug":"Email","link":"/tags/Email/"},{"name":"misskey","slug":"misskey","link":"/tags/misskey/"},{"name":"TiddlyWiki","slug":"TiddlyWiki","link":"/tags/TiddlyWiki/"},{"name":"Cloudflare","slug":"Cloudflare","link":"/tags/Cloudflare/"},{"name":"Caddy","slug":"Caddy","link":"/tags/Caddy/"},{"name":"ASUS","slug":"ASUS","link":"/tags/ASUS/"},{"name":"UM5302TA","slug":"UM5302TA","link":"/tags/UM5302TA/"},{"name":"DSDT","slug":"DSDT","link":"/tags/DSDT/"},{"name":"ACPI","slug":"ACPI","link":"/tags/ACPI/"},{"name":"Wine","slug":"Wine","link":"/tags/Wine/"},{"name":"Galgame","slug":"Galgame","link":"/tags/Galgame/"},{"name":"RPG","slug":"RPG","link":"/tags/RPG/"},{"name":"Continuous Infinity","slug":"Continuous-Infinity","link":"/tags/Continuous-Infinity/"},{"name":"File Format","slug":"File-Format","link":"/tags/File-Format/"},{"name":"ePub","slug":"ePub","link":"/tags/ePub/"},{"name":"WAV","slug":"WAV","link":"/tags/WAV/"},{"name":"Audio","slug":"Audio","link":"/tags/Audio/"},{"name":"PCM","slug":"PCM","link":"/tags/PCM/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"}],"categories":[{"name":"Share","slug":"Share","link":"/categories/Share/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"Translation","slug":"Translation","link":"/categories/Translation/"},{"name":"Tutorial","slug":"Essay/Tutorial","link":"/categories/Essay/Tutorial/"},{"name":"Record","slug":"Record","link":"/categories/Record/"}],"pages":[{"title":"","text":"Getting started 出生年份为 2003 年, 截至目前为中国大陆现役大学本科生. 惯用网名为 “LittleYe233”, 或者是其各个部分的自由变形组合. 出生指派性别为男, 截至目前基于个人认同的性别为女 / Rather not say (后者看心情). 异性恋 -&gt; 泛性恋 / 无性恋 (?). PGP: https://keys.openpgp.org/vks/v1/by-fingerprint/C594DC05A5742D26E3CB35C54EB8635857488D3F 12uid Zhifan Ye &lt;littleye233@gmail.com&gt;uid LittleYe233 (git) &lt;littleye233@gmail.com&gt; 因为可以料到的, 以及其他各种各样的原因, 精神状态不太好. 兴趣爱好","link":"/about/index.html"},{"title":"","text":"Await implementation…","link":"/media/index.html"},{"title":"","text":"Await implementation…","link":"/music/index.html"},{"title":"","text":"Await implementation…","link":"/self-talking/index.html"}]}